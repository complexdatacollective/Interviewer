/* global $, window, Swiper, note*/
/* exported ContextGenerator */
module.exports = function ContextGenerator() {
	'use strict';
	//global vars
	var moduleEvents = [];
	var contexts = [];
	var contextGenerator = {};
	var promptSwiper;
	var dragging = false;
	var currentPrompt = 0;
	var mergeContextForm;
	var temporaryFields = {
		contexts: {
			title: 'contexts',
			type: 'hidden'
		}
	};

	contextGenerator.options = {
		targetEl: $('.container'),
		egoData: 'contexts',
		nodeDestination: 'contexts',
		createNodes: true,
		prompts: [
			'Prompt 1',
			'Prompt 2',
			'Prompt 3',
			'Prompt 4'
		],
	};

	contextGenerator.destroy = function() {
		note.info('Context generator destroyed.');

		window.forms.nameGenForm.removeFields(temporaryFields);

		promptSwiper.destroy();
		$('.new-context-form').remove();
		$('.merge-context-form').remove();
		window.tools.Events.unbind(moduleEvents);
	};

	contextGenerator.nodeAdded = function(e) {
		contextGenerator.addNodeToContext(e.originalEvent.detail);
	};

	contextGenerator.init = function(options) {
		note.info('Context generator initialised.');

		// Add temporary fields to newNodeForm
		window.forms.nameGenForm.addFields(temporaryFields);

		window.tools.extend(contextGenerator.options, options);
		// Events
		var event = [{
			event: 'changeStageStart',
			handler: contextGenerator.destroy,
			targetEl:  window
		},
		{
			event: 'nodeAdded',
			handler: contextGenerator.nodeAdded,
			targetEl:  window
		}];
		window.tools.Events.register(moduleEvents, event);

		// containers
		contextGenerator.options.targetEl.append('<div class="contexthull-title-container"></div><div class="contexthull-hull-container"></div>');

		// Prompts
		$('.contexthull-title-container').append('<div class="swiper-container"><div class="swiper-wrapper"></div><div class="swiper-pagination"></div></div>');
		for (var i = 0; i < contextGenerator.options.prompts.length; i++) {
			$('.swiper-wrapper').append('<div class="swiper-slide"><h2>'+contextGenerator.options.prompts[i]+'</h2></div>');
		}
		promptSwiper = new Swiper ('.swiper-container', {
			pagination: '.swiper-pagination',
			speed: 1000
		});

		// Update current prompt counter
		promptSwiper.on('slideChangeEnd', function () {
    		currentPrompt = promptSwiper.activeIndex;
		});

		// bin
		contextGenerator.options.targetEl.append('<div class="contexthull-bin-footer"><span class="contexthull-bin fa fa-4x fa-trash-o"></span></div>');
		$('.contexthull-bin').droppable({
			// accept: '.circle-responsive',
			tolerance: 'touch',
			hoverClass: 'delete',
			over: function( event, ui ) {
				$(this).addClass('delete');
				$(ui.draggable).addClass('delete');
			},
			out: function( event, ui ) {
				$(this).removeClass('delete');
				$(ui.draggable).removeClass('delete');
			},
			drop: function( event, ui ) {
				if ($(ui.draggable).hasClass('circle-responsive')) {
					contextGenerator.removeContext($(ui.draggable).data('index'));
				} else {
					contextGenerator.removeNode($(ui.draggable).data('id'));
				}

			}
		});

		// New context buttons
		contextGenerator.options.targetEl.append('<div class="new-context-button text-center"><span class="fa fa-2x fa-pencil"></span></div>');

		// New context form
		$('body').append('<div class="new-context-form"></div>');
		var newContextForm = new window.netCanvas.Modules.FormBuilder('newContextForm');
		newContextForm.build($('.new-context-form'), {
			title: 'Create a New Context',
			fields: {
				name: {
					type: 'text',
					placeholder: 'Name of Context',
					required: true,

				}
			},
			submit: function(data) {
				if (contexts.indexOf(data.name) === -1) {
					// Update ego
					var properties = {};
					properties[contextGenerator.options.nodeDestination] = contexts;
					window.network.updateNode(window.network.getEgo().id, properties);
					contextGenerator.addContext(data.name);
					newContextForm.reset();
					newContextForm.hide();
				} else {
					newContextForm.showError('Error: the name you have chosen is already in use.');
				}
			},
			options: {
				buttons: {
					submit: {
						label: 'Create',
						id: 'context-submit-btn',
						type: 'submit',
						class: 'btn-primary'
					},
					cancel: {
						label: 'Cancel',
						id: 'context-cancel-btn',
						type: 'button',
						class: 'btn-default',
						action: function() {
							newContextForm.reset();
							newContextForm.hide();
						}
					}
				}
			}
		});

		event = [{
			event: 'click',
			handler: window.forms.newContextForm.show,
			targetEl:  '.new-context-button'
		}];
		window.tools.Events.register(moduleEvents, event);

		$('body').append('<div class="merge-context-form"></div>');
		mergeContextForm = new window.netCanvas.Modules.FormBuilder('mergeContextForm');
		mergeContextForm.build($('.merge-context-form'), {
			title: 'What should the merged context be called?',
			fields: {
				merged_name: {
					type: 'text',
					placeholder: 'Name of Context',
					required: true,

				},
				source: {
					'type':'hidden',
					'title':'source',
					'name': 'source',
				},
				target: {
					'type':'hidden',
					'title':'target',
					'name': 'target',
				}
			},
			submit: function(data) {
				contextGenerator.mergeContexts(data.source, data.target, data.merged_name);
				window.forms.mergeContextForm.reset();
				window.forms.mergeContextForm.hide();
			},
			options: {
				buttons: {
					submit: {
						label: 'Create',
						id: 'merge-submit-btn',
						type: 'submit',
						class: 'btn-primary'
					},
					cancel: {
						label: 'Cancel',
						id: 'merge-cancel-btn',
						type: 'button',
						class: 'btn-default',
						action: function() {
							mergeContextForm.reset();
							window.forms.mergeContextForm.hide();
						}
					}
				}
			}
		});

		// Add existing data, if present
		if (typeof window.network.getEgo()[contextGenerator.options.egoData] === 'undefined') {
			note.warn('Ego didn\'t have the community variable you specified, so it was created as a blank array.');
			var properties = {};
			properties[contextGenerator.options.egoData] = [];
			window.network.updateNode(window.network.getEgo().id, properties);
		} else {
			contextGenerator.addExistingContexts();
		}

	};

	contextGenerator.addNodeToContext = function(node) {
		note.info('contextGenerator.addNodeToContext():'+node.first_name);
		// fix the context variable as an array.
		if (typeof node.contexts !== 'object') {
			var contextArray = [];
			contextArray.push(node.contexts);
			var updateNode = window.network.getNode(node.id);
			updateNode.contexts = contextArray;
			window.netCanvas.Modules.session.saveData();
		}

		note.debug('contextGenerator: adding node to context');
		note.debug(node);
		var thisContext = window.tools.htmlUnEscape(node[contextGenerator.options.nodeDestination]);
		console.log(thisContext);
		var context = contexts.indexOf(thisContext);
		note.debug(contexts);
		console.log(context);
		$('.circle-responsive[data-index="'+context+'"]').append('<div class="node-circle-container"><div class="node-circle" data-id="'+node.id+'">'+node.label+'</div></div>');
		contextGenerator.makeNodesDraggable();
	};

	contextGenerator.showBin = function() {
		$('.contexthull-bin-footer').addClass('show');
	};

	contextGenerator.hideBin = function() {
		$('.contexthull-bin-footer').removeClass('show');
	};

	contextGenerator.addExistingContexts = function() {
		note.info('contextGenerator.addExistingContexts()');
		// First, we create a super array of all unique items across all variable arrays.
		var egoData = window.network.getEgo()[contextGenerator.options.egoData];

		$.each(egoData, function(index, value) {
			contextGenerator.addContext(value);
		});

		// Add any nodes to the contexts (filter to ignore ego)
		var nodes = window.network.getNodes({}, function (results) {
			var filteredResults = [];
			$.each(results, function(index,value) {
				if (value.type !== 'Ego') {
					filteredResults.push(value);
				}
			});

			return filteredResults;
		});

		$.each(nodes, function(nodeIndex, nodeValue) {
			// only deal with nodes that have a single context. is this right?
			if (typeof nodeValue[contextGenerator.options.nodeDestination] !== 'undefined' && nodeValue[contextGenerator.options.nodeDestination].length === 1) {
				// Check if the context exists
				if (contexts.indexOf(nodeValue[contextGenerator.options.nodeDestination][0] !== -1)) {
					contextGenerator.addNodeToContext(nodeValue);
				} else {
					note.warn('A node was found with a context that didn\'t exist!');
				}
 			} else {
				note.debug('Ignored a node because it either had multiple or no contexts.'+nodeValue.id);
			}

		});

	};

	contextGenerator.makeDraggable = function() {
		$('.circle-responsive').draggable({
			// zIndex: 100,
			revert: true,
			refreshPositions: true,
			revertDuration: 200,
			stack: '.circle-responsive',
			scroll: false,
			start: function() {
				dragging = true;
				contextGenerator.showBin();
				$(this).addClass('smaller');

			},
			stop: function() {
				setTimeout(function(){dragging = false;}, 100);
				$(this).removeClass('smaller');
				contextGenerator.hideBin();
			}
		});

		$('.circle-responsive').droppable({
			// accept: '.circle-responsive',
			// tolerance: 'fit',
			hoverClass: 'merge',
			over: function(event, ui) {
				// $(this).addClass('merge');
				$(ui.draggable).addClass('merge');
			},
			out: function( event, ui ) {

				$(ui.draggable).removeClass('merge');
			},
			drop: function( event, ui ) {
				setTimeout(function(){dragging = false;}, 100);
				if ($(ui.draggable).hasClass('circle-responsive')) {
					$(this).removeClass('merge');
					$(ui.draggable).removeClass('merge');
					var props = {
						merged_name: $(ui.draggable).data('context')+'/'+$(this).data('context'),
						source: $(ui.draggable).data('index'),
						target: $(this).data('index')
					};
					console.log(props);
					window.forms.mergeContextForm.addData(props);
					window.forms.mergeContextForm.show();
					// window.forms.nameGenForm.hide(); // Why did I do this?

				} else if ($(ui.draggable).hasClass('node-circle')) {
					$(this).removeClass('merge');
					$(ui.draggable).removeClass('merge');
					// check if we are dropping back where we started, and cancel if so.
					if ($(this).data('context') !== $(ui.draggable).parent().parent().data('context')) {
						contextGenerator.moveNode($(ui.draggable).data('id'), $(this).data('index'));
					}

				} else {
					$(this).removeClass('merge');
					$(ui.draggable).removeClass('merge');
					// contextGenerator.removeNode($(ui.draggable).data('id'));
				}

			}
		});
	};

	contextGenerator.makeNodesDraggable = function() {
		$('.node-circle').draggable({
			stack: '.circle-responsive',
			revert: true,
			revertDuration: 200,
			refreshPositions: true,
			scroll: false,
			start: function() {
				$(this).addClass('border');
				contextGenerator.showBin();
			},
			stop: function() {
				$(this).removeClass('border');
				contextGenerator.hideBin();
			}
		});

	};

	contextGenerator.mergeContexts = function (sourceIndex, targetIndex, newName) {
		if (!sourceIndex || !targetIndex || !newName) {
			note.error('ContextGenerator: mergeContexts() needs better parameters!');
			return false;
		}

		note.warn('I\'m not clever enough to check for nodes not visible that are already in both contexts...but I soon will be.');

		// Create a new context with the combined name.
		var newContextIndex = contextGenerator.addContext(newName);

		// Move nodes from the source and target to the new context
		var sourceNodes = contextGenerator.getContextNodes(sourceIndex);
		var targetNodes = contextGenerator.getContextNodes(targetIndex);
		$.each(sourceNodes, function(index, value) {
			contextGenerator.moveNode(value, newContextIndex);
		});
		$.each(targetNodes, function(index, value) {
			contextGenerator.moveNode(value, newContextIndex);
		});

		// Remove previous contexts
		contextGenerator.removeContext(sourceIndex);
		contextGenerator.removeContext(targetIndex);

	};

	contextGenerator.addContext = function(name) {
		if (!name) {
			note.error('No name provided for new context.');
			throw new Error('No name provided for new context.');
		}
		contexts.push(name);

		// use lowest available color
		var color = 0;
		while ($('.circle-responsive[data-index='+color+']').length > 0) {
			color++;
		}
		$('.contexthull-hull-container').append('<div class="circle-responsive" data-index="'+color+'" data-context="'+window.tools.htmlEscape(name)+'"><div class="circle-content">'+name+'</div></div>');
		contextGenerator.makeDraggable();
		if (contextGenerator.options.createNodes === true) {
			var event = [{
				event: 'click',
				handler: contextGenerator.showNewNodeForm,
				targetEl:  '.circle-responsive[data-index="'+color+'"]'
			}];
			window.tools.Events.register(moduleEvents, event);
		}

		return color;

	};

	contextGenerator.showNewNodeForm = function() {
		if (!dragging) {
			var target = $(this).data('context');
			window.forms.nameGenForm.addData({contexts: target});
			window.forms.nameGenForm.show();
		}
	};

	contextGenerator.removeContext = function(index) {
		console.log(contexts);
		console.log(index);
		var name = contexts[index];

		console.log(name);
		if (!name) {
			note.error('No name provided to contextGenerator.deleteContext().');
			throw new Error('No name provided to contextGenerator.deleteContext().');
		}

		if (contexts.remove(name) !== 0) {
			var properties = {};
			properties[contextGenerator.options.egoData] = contexts;
			window.network.updateNode(window.network.getEgo().id, properties);

			// Remove nodes
			var childNodes = $('div[data-index="'+index+'"]').children('.node-circle-container');
			$.each(childNodes, function(nodeIndex, nodeValue) {
				var thisId = $(nodeValue).children('.node-circle');
				contextGenerator.removeNode($(thisId).data('id'));
			});
			console.log('trying to remove element');
			console.log(name);
			console.log(index);
			$('div[data-index="'+index+'"]').remove();
			return true;
		} else {
			note.warn('contextGenerator.deleteContext() couldn\'t find a context with name '+name+'. Nothing was deleted.');
			return false;
		}

	};

	contextGenerator.getContextNodes = function(index) {
		if (!index) {
			note.error('No context index provided to contextGenerator.getContextNodes().');
		}

		var nodes = [];
		// Remove nodes
		var childNodes = $('div[data-index="'+index+'"]').children('.node-circle-container');
		$.each(childNodes, function(nodeIndex, nodeValue) {
			var thisId = $(nodeValue).children('.node-circle');
			nodes.push($(thisId).data('id'));
		});

		return nodes;

	};

	contextGenerator.removeNode = function(id) {
		if (!id) {
			note.error('No id provided to contextGenerator.deleteNode().');
			throw new Error('No id provided to contextGenerator.deleteNode().');
		}

		if (window.network.removeNode(id)) {
			$('div[data-id="'+id+'"]').remove();
			note.info('Deleted node with id '+id);
			return true;
		} else {
			note.warn('contextGenerator.removeNode() tried to remove node with ID '+id+', but failed.');
			return false;
		}
	};

	contextGenerator.moveNode = function(node, targetContext) {

		var properties = {};
		properties[contextGenerator.options.nodeDestination] = [];
		properties[contextGenerator.options.nodeDestination].push(contexts[targetContext]);
		window.network.updateNode(node, properties, function() {
			var target = $('div[data-index="'+targetContext+'"]');
			var element = $('div[data-id="'+node+'"]').parent();
			$(element).appendTo(target);
			return true;
		});
	};

	return contextGenerator;
};
;/* global window,$ */
/* exported DateInterface */

module.exports = function DateInterface() {
    'use strict';

    // dateInterface globals

    var dateInterface = {};
    var edges;

    dateInterface.options = {
        targetEl: $('.container'),
        edgeType: 'Dyad',
        heading: 'Default Heading'
    };



    dateInterface.init = function(options) {
        window.tools.extend(dateInterface.options, options);
        dateInterface.options.targetEl.append('<div class="node-question-container"></div>');
        $('.node-question-container').append('<h1>'+dateInterface.options.heading+'</h1>');
        $('.node-question-container').append('<p class="lead">'+dateInterface.options.subheading+'</p>');
        dateInterface.options.targetEl.append('<div class="date-container"></div>');

        // get edges according to criteria
        edges = window.network.getEdges(dateInterface.options.criteria);
        var counter = 0;
        var row = 0;
        $.each(edges, function(index,value) {

            var dyadEdge = window.network.getEdges({type:'Dyad', from:window.network.getNodes({type_t0:'Ego'})[0].id, to:value.to})[0];

            var markup =
            '<div class="date-picker-item overlay">'+
                '<div class="row">'+
                    '<div class="col-sm-12">'+
                        '<h2>Regarding <span>'+dyadEdge.nname_t0+'</span></h2>'+
                    '</div>'+
                '</div>'+
                '<div class="row">'+
                    '<div class="col-sm-12 alert alert-danger logic-error" role="alert">'+
                        '<span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span>'+
                        '<span class="sr-only">Error:</span> Your last sexual encounter cannot come before your first. Please correct the dates before continuing.'+
                    '</div>'+
                    '<div class="col-sm-5">'+
                        '<div class="form-group">'+
                            '<p class="lead">When was the first time you had sex?</p>'+
                            '<div class="input-group date first row'+row+'" id="datetimepicker'+counter+'">'+
                                '<input type="text" class="form-control" />'+
                                '<span class="input-group-addon"><span class="glyphicon glyphicon-calendar"></span></span>'+
                            '</div>'+
                            '<div class="checkbox">'+
                                '<label><input type="checkbox" name="checkbox-time" class="checkbox-time checkbox'+counter+'"> More than 6 months ago.</label>'+
                            '</div>'+
                        '</div>'+
                    '</div>'+
                    '<div class="col-sm-5 col-sm-offset-2">'+
                        '<div class="form-group">'+
                            '<p class="lead">When was the last time you had sex?</p>'+
                            '<div class="input-group date second row'+row+'" id="datetimepicker'+(counter+1)+'">'+
                                '<input type="text" class="form-control" />'+
                                '<span class="input-group-addon"><span class="glyphicon glyphicon-calendar"></span></span>'+
                            '</div>'+
                        '</div>'+
                    '</div>'+
                '</div>'+
            '</div>';

            $(markup).appendTo('.date-container');
            var dateoptions = {format: 'MM/DD/YYYY'};

            $('#datetimepicker'+counter).datetimepicker(dateoptions);
            $('#datetimepicker'+(counter+1)).datetimepicker(dateoptions);

            $('#datetimepicker'+counter+', #datetimepicker'+(counter+1)).on('dp.change',function (e) {
                var properties = {};
                var target, first, second, incomingDate;

                var $current = $(this);

                if ($(this).hasClass('first')) {

                    if ($('.checkbox'+$current.attr('id').slice(-1)).is(':checked')) {
                        properties.sex_first_before_range = true;
                        incomingDate = null;
                    } else {
                        properties.sex_first_before_range = false;
                        incomingDate = $current.data('DateTimePicker').date().format('MM/DD/YYYY');
                    }

                    target = parseInt($current.attr('id').slice(-1))+1;
                    first = parseInt($current.attr('id').slice(-1));
                    second = parseInt($current.attr('id').slice(-1))+1;

                    if (e.date !== null ) {
                        // $('#datetimepicker'+second).data('DateTimePicker').minDate(e.date);
                    }

                    properties.sex_first_t0 = incomingDate;

                } else {

                    if ($('.checkbox'+$current.attr('id').slice(-1)).is(':checked')) {
                        properties.sex_last_before_range = true;
                        incomingDate = null;
                    } else {
                        properties.sex_last_before_range = false;
                        incomingDate = $current.data('DateTimePicker').date().format('MM/DD/YYYY');
                    }

                    target = parseInt($current.attr('id').slice(-1))-1;
                    first = parseInt($current.attr('id').slice(-1))-1;
                    second = parseInt($current.attr('id').slice(-1));

                    if (e.date !== null) {
                        // $('#datetimepicker'+first).data("DateTimePicker").maxDate(e.date);
                    }

                    properties.sex_last_t0 = incomingDate;

                }

                window.network.updateEdge(value.id, properties);

                if (window.moment($('#datetimepicker'+first).data('DateTimePicker').date()).isAfter($('#datetimepicker'+second).data('DateTimePicker').date())) {
                    $current.parent().parent().parent().children('.logic-error').fadeIn();
                    $('.arrow-next').attr('disabled','disabled');
                } else {
                    $current.parent().parent().parent().children('.logic-error').fadeOut();
                    $('.arrow-next').removeAttr('disabled');
                }

            });

            if (typeof value.sex_first_t0 !== 'undefined') {
                if (value.sex_first_t0 === null) {
                    $('.checkbox'+counter).prop('checked', true);
                    $('#datetimepicker'+counter).data('DateTimePicker').date(window.moment().subtract(6, 'months').format('MM/DD/YYYY'));
                    $('#datetimepicker'+counter).children().css({opacity:0.5});
                    $('#datetimepicker'+counter).data('DateTimePicker').disable();

                } else {
                    $('#datetimepicker'+counter).data('DateTimePicker').date(value.sex_first_t0);
                }

            }
            if (typeof value.sex_last_t0 !== 'undefined') {
                if (value.sex_last_t0 === null) {
                    $('.checkbox'+(counter+1)).prop('checked', true);
                    $('#datetimepicker'+(counter+1)).data('DateTimePicker').date(window.moment().subtract(6, 'months').format('MM/DD/YYYY'));
                    $('#datetimepicker'+(counter+1)).children().css({opacity:0.5});
                    $('#datetimepicker'+(counter+1)).data('DateTimePicker').disable();

                } else {
                    $('#datetimepicker'+(counter+1)).data('DateTimePicker').date(value.sex_last_t0);
                }

            }

            $('.checkbox'+counter+', .checkbox'+(counter+1)).change(function(e) {
                var $target = $(e.target);
                if(this.checked) {
                    $target.parent().parent().parent().children('.date').data('DateTimePicker').date(window.moment().subtract(6, 'months').format('MM/DD/YYYY'));
                    $target.parent().parent().parent().children('.date').data('DateTimePicker').disable();
                    $target.parent().parent().parent().children('.date').children().css({opacity:0.5});
                } else {
                    $target.parent().parent().parent().children('.date').data('DateTimePicker').enable();
                    $target.parent().parent().parent().children('.date').children().css({opacity:1});
                    $target.parent().parent().parent().children('.date').data('DateTimePicker').date(window.moment().format('MM/DD/YYYY'));
                }
            });


            counter=counter+2;
            row++;
        });



    };

    dateInterface.destroy = function() {
        // Used to unbind events
    };

    return dateInterface;
};
;/* global $, window, jQuery, note, alert */
/* exported FormBuilder */

module.exports = function FormBuilder(formName) {
    'use strict';

    var formBuilder = {};
    var thisForm;
    var formOptions = {
        open: false,
        inline: false
    };
    var html = '<form></form>';
    var deferredTasks = [];
    var moduleEvents = [];
    var formFields;
    var temporaryFields = [];
    var targetEl;
    var name = formName ? formName : 'Default';
    window.forms = window.forms || {};
    window.forms[name] = formBuilder;

    formBuilder.init = function() {

        note.info('FormBuilder initialised.');
    };

    formBuilder.getID = function() {
        return thisForm.id;
    };

    formBuilder.reset = function() {
        $(html).find('.alert').fadeOut();
        $(html)[0].reset();

        // Reset all custom components
        $.each (thisForm.fields, function(fieldIndex, fieldValue) {
            if (fieldValue.type === 'custom') {
                thisForm.options.customFields[fieldValue.customType].reset();
            }
        });

    };

    formBuilder.showError = function(error) {
        $(html).find('.alert').fadeIn();
        $(html).find('.error').html(error);
    };

    formBuilder.addDeferred = function(item) {
        note.debug('FormBuilder ['+name+']: adding deferred form task.');
        deferredTasks.push(item);
    };

    formBuilder.runDeferred = function() {
        note.debug('FormBuilder ['+name+']: running deferred form initialisation actions.');
        for (var i = 0; i < deferredTasks.length; i++) {
            if (typeof deferredTasks[i].action === 'function') {
                deferredTasks[i].action();
            }
        }

        deferredTasks = [];
    };

    // show and hide methods
    formBuilder.show = function() {
        thisForm.show();
        note.debug('FormBuilder ['+name+']: show.');
        targetEl.addClass('show');
        $('.black-overlay').addClass('show');
        setTimeout(function() {
            $('#'+$(html).attr('id')+' :input:visible:enabled:first').focus();
        }, 500);

    };

    formBuilder.hide = function () {
        note.debug('FormBuilder ['+name+']: hide.');
        targetEl.removeClass('show');
        $('.black-overlay').removeClass('show');
        setTimeout(function() {
            formBuilder.removeTemporaryFields();
            $(thisForm).trigger('reset');
        }, 1500);



    };

    formBuilder.build = function(element, form, options) {
        // element = target element to inject the form into
        // form = an object containing the form fields and configuration options. Also contains load, show, hide, and submit events.
        // options = buttons and custom field type definitions.

        var userOptions = options || {};
        $.extend(formOptions, userOptions);
        thisForm = form;
        targetEl = element;
        // Form options
        if (formOptions.inline === true) {
            html = $(html).addClass('inline-form');
        }

        if (typeof form.heading !== 'undefined') {
            html = $(html).append('<div class="page-header"><h1>'+form.heading+'</h1></div>');
        }

        if (typeof form.title !== 'undefined') {
            html = $(html).append('<legend>'+form.title+'</legend><div class="alert alert-danger" role="alert" style="display: none;"><span class="glyphicon glyphicon-exclamation-sign" aria-hidden="true"></span> <span class="error"></span></div>');
        }

        // Form fields
        formFields = '<div class="form-fields"></div>';
        formBuilder.addFields(form.fields);

        html = $(html).append(formFields);

        // Buttons
        var buttonGroup = '<div class="text-right button-group"></div>';
        $.each(form.options.buttons, function(buttonIndex, buttonValue){
            buttonGroup = $(buttonGroup).append('<button id="'+buttonValue.id+'" type="'+buttonValue.type+'" class="btn '+buttonValue.class+'">'+buttonValue.label+'</button>&nbsp;');

        });
        html = $(html).append(buttonGroup);

        // Check if we are outputting html or writing to DOM
        if (element instanceof jQuery) {
            note.debug('Formbuilder ['+name+'] outputting to jQuery object.');
            // Write to DOM
            html = $(html).uniqueId();
            thisForm.id = $(html).prop('id');
            element.append(html);
            formBuilder.addEvents();
            // Data population
            if (typeof form.data !== 'undefined') {
                formBuilder.addData(form.data);
            }
            $(html).trigger('formLoaded');
        } else if (element === 'html') {
            note.debug('Formbuilder ['+name+'] outputting HTML.');
            // return the html for the form
            html = $(html).uniqueId();
            thisForm.id = $(html).prop('id');
            return html;
        } else {
            throw new Error('Formbuilder ['+name+'] didn\'t understand the intended output destination of the build method.');
        }

    };

    formBuilder.removeTemporaryFields = function() {
        note.debug('FormBuilder ['+name+']: removeTemporaryFields()');
        console.log(temporaryFields);
        $.each(temporaryFields, function(fieldIndex, fieldValue) {
            formBuilder.removeField(fieldValue.id);
        });
    };

    formBuilder.addTemporaryFields = function(fields) {
        note.debug('FormBuilder ['+name+']: addTemporaryFields()');
        $.each(fields, function(fieldIndex, fieldValue) {
            fieldValue.id = fieldIndex;
            temporaryFields.push(fieldValue);
        });

        formBuilder.addFields(fields);
    };

    formBuilder.addFields = function(fields) {
        var wrapper, variableComponent, variableLabel, checkLabel, placeholder, required;
        note.debug('Adding fields');
        $.each(fields, function(formIndex, formValue) {
            note.debug('adding '+formIndex);
            if (!formBuilder.fieldExists(formIndex)) {
                variableComponent = ''; variableLabel = ''; checkLabel = '';
                placeholder = formValue.placeholder? formValue.placeholder : '';
                required = formValue.required? 'required' : '';

                if (formValue.type === 'text') {
                    wrapper = '<div class="form-group" data-component="'+formIndex+'"></div>';
                    if (typeof formValue.title !== 'undefined') {
                        variableLabel = '<label for="'+formIndex+'">'+formValue.title+'</label>';
                    }

                    variableComponent = '<input type="'+formValue.type+'" class="form-control" id="'+formIndex+'" name="'+formIndex+'" placeholder="'+placeholder+'" autocomplete="off" '+required+'>';
                    wrapper = $(wrapper).append(variableLabel+variableComponent);
                    formFields = $(formFields).append(wrapper);
                } else if (formValue.type === 'custom') {
                    note.warn('formBuilder.addFields(): Custom form field detected');

                    // Check if we have been supplied a definition
                    if (typeof formValue.customType !== 'undefined' && typeof thisForm.options.customFields[formValue.customType] !== 'undefined') {
                        // Check if the definition has a markup function
                        if (typeof thisForm.options.customFields[formValue.customType].markup !== 'undefined') {
                            wrapper = '<div class="form-group" data-component="'+formIndex+'"></div>';
                            // Pass the markup method the fields options, incase it needs them
                            wrapper = $(wrapper).append(thisForm.options.customFields[formValue.customType].markup(formValue.options));
                            formFields = $(formFields).append(wrapper);


                            // Initialise components as required
                            if (typeof thisForm.options.customFields[formValue.customType].markup !== 'undefined') {
                                formBuilder.addDeferred({
                                    action: thisForm.options.customFields[formValue.customType].initialise
                                });
                            }

                        } else {
                            note.warn('formBuilder.addFields(): Form of type "'+formValue.customType+'" did not have any markup.');
                        }
                    } else {
                        note.warn('formBuilder.addFields(): Could not find a definition for custom form type "'+formValue.customType+'"');
                    }

                    // formValue.customType
                } else if (formValue.type === 'hidden') {
                    wrapper = '<div class="hidden-form-group" data-component="'+formIndex+'"></div>';

                    variableComponent = '<input type="'+formValue.type+'" class="form-control" id="'+formIndex+'" name="'+formIndex+'" placeholder="'+placeholder+'" autocomplete="off" '+required+'>';
                    wrapper = $(wrapper).append(variableLabel+variableComponent);
                    formFields = $(formFields).append(wrapper);

                } else if (formValue.type === 'number') {

                    // Create component container
                    var component = '<div class="form-group" data-component="'+formIndex+'"></div>';

                    // Append Label
                    component = $(component).append('<label for="'+formIndex+'">'+formValue.title+'</label>');

                    // Create input group container
                    var inputGroup = '<div class="input-group"></div>';

                    // Check if we have a prefix
                    if (typeof formValue.prefix !== 'undefined') {
                        // If we do, append it
                        inputGroup = $(inputGroup).append('<span class="input-group-addon">'+formValue.prefix+'</span>');
                    }

                    // Create an input element
                    var input = '<input type="number" class="form-control" id="'+formIndex+'" name="'+formIndex+'" placeholder="'+placeholder+'" autocomplete="off" '+required+'>';

                    // Set the input attributes
                    var properties = {};
                    properties.min = formValue.min ? formValue.min : '0';
                    properties.max = formValue.max ? formValue.max : '';
                    input = $(input).attr(properties);

                    // Append the input to the input group or the component
                    if (typeof formValue.prefix !== 'undefined') {
                        inputGroup = $(inputGroup).append(input);
                        // Appent the input group to the componens
                        component = $(component).append(inputGroup);

                    } else {
                        component = $(component).append(input);
                    }

                    // Append the component to the form
                    formFields = $(formFields).append(component);
                } else if (formValue.type === 'slider') {
                    wrapper = '<div class="form-group" data-component="'+formIndex+'"></div>';
                    variableLabel = '<label for="'+formIndex+'">'+formValue.title+'</label>';
                    variableComponent = '<input type="text" class="form-control slider" id="'+formIndex+'" name="'+formIndex+'">';
                    // Initialise sliders through deferred action
                    formBuilder.addDeferred({
                        action: function() {
                            $('#'+formIndex).bootstrapSlider({min: 0, max: 100, value: formValue.initial });
                        }
                    });

                    wrapper = $(wrapper).append(variableLabel+variableComponent);
                    formFields = $(formFields).append(wrapper);
                } else if (formValue.type === 'email') {
                    wrapper = '<div class="form-group" data-component="'+formIndex+'"></div>';
                    variableLabel = '<label for="'+formIndex+'">'+formValue.title+'</label>';
                    variableComponent = '<input type="email" class="form-control" id="'+formIndex+'" name="'+formIndex+'" placeholder="'+placeholder+'" autocomplete="off" '+required+'>';
                    wrapper = $(wrapper).append(variableLabel+variableComponent);
                    formFields = $(formFields).append(wrapper);
                } else if (formValue.type === 'textarea') {
                    wrapper = '<div class="form-group" data-component="'+formIndex+'"></div>';
                    variableLabel = '<label for="'+formIndex+'">'+formValue.title+'</label>';
                    variableComponent = '<textarea class="form-control" id="'+formIndex+'" name="'+formIndex+'" rows="'+formValue.rows+'" cols="'+formValue.cols+'" autocomplete="off" placeholder="'+placeholder+'" '+required+'></textarea>';
                    wrapper = $(wrapper).append(variableLabel+variableComponent);
                    formFields = $(formFields).append(wrapper);
                } else if (formValue.type === 'radio') {
                    wrapper = '<div class="form-group" data-component="'+formIndex+'"></div>';
                    variableComponent = '';
                    variableLabel = '<label class="control-label">'+formValue.title+'</label>';
                    wrapper = $(wrapper).append(variableLabel);

                    $.each(formValue.variables, function(checkIndex, checkValue){
                        variableComponent = '<input type="radio" name="'+formIndex+'" value="'+checkValue.value+'" id="'+checkValue.id+'" '+required+'>';
                        checkLabel = '<label class="radio-inline" for="'+checkValue.id+'">'+checkValue.label+'</label>';
                        wrapper = $(wrapper).append(variableComponent+checkLabel);
                    });
                    formFields = $(formFields).append(wrapper);
                } else if (formValue.type === 'checkbox') {
                    // inline or regular?
                    var inline = formValue.inline ? 'checkbox-inline' : 'checkbox';

                    // Create wrapper element
                    wrapper = '<div class="form-group" data-component="'+formIndex+'"></div>';
                    variableComponent = '';
                    variableLabel = '<label class="control-label">'+formValue.title+'</label>';
                    wrapper = $(wrapper).append(variableLabel);

                    // Append checkboxes
                    $.each(formValue.variables, function(checkIndex, checkValue){
                        variableComponent = '<input type="checkbox" data-field="'+formIndex+'" name="'+formIndex+'" value="'+checkValue.id+'" id="'+checkValue.id+'" '+required+'>';
                        checkLabel = '<label class="'+inline+'" for="'+checkValue.id+'">'+checkValue.label+'</label>';
                        wrapper = $(wrapper).append(variableComponent+checkLabel);
                    });
                    formFields = $(formFields).append(wrapper);
                } else if (formValue.type === 'button-checkbox') {
                    // Create wrapper element
                    wrapper = '<div class="form-group" data-component="'+formIndex+'"></div>';
                    variableComponent = '';
                    variableLabel = '<label class="control-label">'+formValue.title+'</label>';
                    wrapper = $(wrapper).append(variableLabel);

                    // Append checkboxes
                    $.each(formValue.variables, function(checkIndex, checkValue){
                        variableComponent = '<input type="checkbox" data-field="'+formIndex+'" name="'+checkValue.id+'" id="'+checkValue.id+'" '+required+'>';
                        checkLabel = '<label class="checkbox-inline" for="'+checkValue.id+'">'+checkValue.label+'</label>';
                        wrapper = $(wrapper).append(variableComponent+checkLabel);
                    });
                    formFields = $(formFields).append(wrapper);
                }
            } else if(formBuilder.fieldExists(formIndex)) {
                variableComponent = ''; variableLabel = ''; checkLabel = '';
                placeholder = formValue.placeholder? formValue.placeholder : '';
                required = formValue.required? 'required' : '';


                if (formValue.type === 'button-checkbox') {
                    // This field exists. If we are trying to define it again, perhaps it is a checkbox group
                    // If it is, we should append the label and input to the existing form group
                    // Create wrapper element

                    // Append checkboxes
                    $.each(formValue.variables, function(checkIndex, checkValue){
                        variableComponent = '<input type="checkbox" data-field="'+formIndex+'" name="'+checkValue.id+'" id="'+checkValue.id+'" '+required+'>';
                        checkLabel = '<label class="checkbox-inline" for="'+checkValue.id+'">'+checkValue.label+'</label>';
                        $(formFields).find('[data-component="'+formIndex+'"]').append(variableComponent+checkLabel);
                    });
                }

            } else {
                note.error('FormBuilder ['+name+']: Field with id "'+formIndex+'" already exists!');
            }

        });

        formBuilder.runDeferred();
    };

    formBuilder.removeFields = function(fields) {
        note.debug('FormBuilder ['+name+']: removeFields()');
        $.each(fields, function(fieldIndex) {
            formBuilder.removeField(fieldIndex);
        });
    };

    formBuilder.removeField = function(id) {
        $('[data-component="'+id+'"]').remove();
    };

    formBuilder.fieldExists = function(id) {
        if ($('#'+thisForm.id).find('#'+id).length > 0) {
            note.debug('field '+id+' exists');
            return true;
        } else if ($('#'+thisForm.id).find('[data-component="'+id+'"]').length > 0) {
            note.debug('field '+id+' exists as a checkbox.');
            return true;
        } else {
            console.log('field '+id+' not found');
            return false;
        }
    };

    formBuilder.fieldType = function(id) {
        if (formBuilder.fieldExists(id)) {
            return $($('#'+thisForm.id).find('#'+id)[0]).prop('type');
        } else {
            return false;
        }
    };

    formBuilder.addEvents = function() {

        // submit
        window.tools.Events.register(moduleEvents,
        [
            {
                targetEl: $(html),
                event: 'submit',
                handler: function(e) {
                    note.debug('FormBuilder ['+name+']: Form submitted.');

                    e.preventDefault();

                    var data = $(this).serializeArray();
                    console.log('raw form');
                    console.log(data);
                    var cleanData = {};
                    for (var i = 0; i < data.length; i++) {

                        // To handle checkboxes, we check if the key already exists first. If it
                        // does, we append new values to an array. This keeps compatibility with
                        // single form fields, but might need revising.

                        // Handle checkbox values
                        if (data[i].value === 'on') { data[i].value = 1; }

                        // This code takes the serialised output and puts it in the structured required to store within noded/edges.
                        if (typeof cleanData[data[i].name] !== 'undefined' && typeof cleanData[data[i].name] !== 'object') {
                            console.log('ONE');
                            // if it isn't an object, its a string. Create an empty array and store by itself.
                            cleanData[data[i].name] = [cleanData[data[i].name]];
                            cleanData[data[i].name].push(data[i].value);
                        } else if (typeof cleanData[data[i].name] !== 'undefined' && typeof cleanData[data[i].name] === 'object'){
                            console.log('TWO');
                            // Its already an object, so append our new item
                            cleanData[data[i].name].push(data[i].value);
                        } else {
                            console.log('THREE');
                            // This is for regular text fields. Simple store the key value pair.
                            cleanData[data[i].name] = data[i].value;
                        }

                    }

                    note.debug(cleanData);

                    if (typeof thisForm.submit !== 'undefined') {
                        thisForm.submit(cleanData);
                    }

                }
            },
            {
                targetEl: $('input'),
                event: 'change paste keyup',
                handler: function() {
                    $('#'+thisForm.options.buttons.submit.id).html(thisForm.options.buttons.submit.update_label);
                }
            }
        ]);

        // onLoad
        if (typeof thisForm.load !== 'undefined') {
            window.tools.Events.register(moduleEvents, [{
                targetEl: $(html),
                event: 'formLoaded',
                handler: function() {
                    thisForm.load(thisForm);
                }
            }]);
        }

        $.each(thisForm.options.buttons, function(buttonIndex, buttonValue){
            if(typeof buttonValue.action !== 'undefined') {
                window.tools.Events.register(moduleEvents, [{
                    targetEl: $('#'+buttonValue.id),
                    event: 'click',
                    handler: buttonValue.action
                }]);
            }
        });

    };

    formBuilder.isOpen = function() {
        return true;
    };

    formBuilder.isClosed = function() {
        return false;
    };

    formBuilder.destroy = function() {
        window.tools.Events.unbind(moduleEvents);
    };

    formBuilder.addData = function(data) {
        note.debug('FormBuilder ['+name+']: addData()');

        $.each(data, function(dataIndex, dataValue) {
            console.log('formbuilder.addData() analysing data for '+dataIndex);
            if (formBuilder.fieldExists(dataIndex)) {
                // For standard inputs
                var currentType = formBuilder.fieldType(dataIndex);

                // But we need this for checkboxes
                currentType = currentType ? currentType : 'checkbox';
                console.log('Identified '+dataIndex+' as type '+currentType);
                if (currentType === 'text' || currentType === 'email' || currentType === 'number' || currentType === 'hidden') {
                    console.log('assigning '+dataValue+' to '+dataIndex);
                    $(html).find('#'+dataIndex).val(dataValue);
                } else if (currentType === 'slider') {
                    var dataValueArray = dataValue.split(',').map(Number);
                    if (dataValueArray.length>1) {
                        $(html).find('#'+dataIndex).val(dataValue);
                        $(html).find('#'+dataIndex).bootstrapSlider({min: 0, max: 100, value: dataValueArray });
                    } else {
                        $(html).find('#'+dataIndex).val(dataValue[0]);
                        $(html).find('#'+dataIndex).bootstrapSlider({min: 0, max: 100, value: dataValue[0] });
                    }
                } else if (currentType === 'textarea') {
                    $(html).find('#'+dataIndex).html(dataValue);
                } else if (currentType === 'radio') {
                    $('input:radio[name="'+dataIndex+'"][value="'+dataValue+'"]').prop('checked', true);
                } else if (currentType === 'checkbox') {
                    console.log('adding checkbox data');
                    console.log(dataIndex);
                    console.log(dataValue);
                    // If single value, use directly
                    if (typeof dataValue !== 'undefined' && typeof dataValue === 'object') {
                        // If array, iterate
                        for (var i = 0; i < dataValue.length; i++) {
                            $(html).find('input:checkbox[value="'+dataValue[i]+'"]').prop('checked', true);
                        }
                    } else if (typeof dataValue !== 'undefined' && typeof dataValue === 'string') {
                        $(html).find('input:checkbox[value="'+dataValue+'"]').prop('checked', true);
                    } else if (typeof dataValue !== 'undefined' && typeof dataValue === 'number') {
                        $(html).find('#'+dataIndex).prop('checked', true);

                    }

                } else {
                    console.warn('currentType '+currentType+' not understood.');
                }
            } else {
                // If the dataIndex doesn't exist as a key in the fields object, it could be a sub-key
                // if, for example, it is the child of a checkbox variable
                note.debug('FormBuilder ['+name+']: Data provided for undefined field "'+dataIndex+'"');
            }
        });
    };

    formBuilder.init();

    return formBuilder;
};
;/* exported Interview */
/* global $ */
var Interview = function Interview() {
    'use strict';
    var interview = {};
    var currentStage = 0;
    var $content = $('#content');

    interview.id = 0;
    interview.date = new Date();
    interview.stages = 2;

    interview.init = function() {
        interview.goToStage(0);
        $('.arrow-next').click(function() {
            interview.nextStage();
        });
        $('.arrow-prev').click(function() {
            interview.prevStage();
        });
    };

    interview.loadData = function(path) {
        var data = JSON.parse(path);
        $.extend(interview, data);
    };

    interview.goToStage = function(stage) {
        var newStage = stage;
        $content.transition({ opacity: '0'},700,'easeInSine').promise().done( function(){
            $content.load( 'stages/'+stage+'.html', function() {
                $content.transition({ opacity: '1'},700,'easeInSine');
            });
        });
        currentStage = newStage;
    };

    interview.nextStage = function() {
        interview.goToStage(currentStage+1);
    };

    interview.prevStage = function() {
        interview.goToStage(currentStage-1);
    };


    return interview;
};
;/* global window, require, note, nodeRequire, isNodeWebkit */
/* exported IOInterface */

var IOInterface = function IOInterface() {
    'use strict';
    var Datastore = require('nedb');
    var path = require('path');
    var db;
    var id;
    var ioInterface = {};
    var initialised = false;

    ioInterface.init = function(callback) {

        var dbLocation = path.join('database/', window.netCanvas.Modules.session.name+'.db');

        // Use the node version of nedb when in the node webkit environment.
        if(isNodeWebkit === true) {
            Datastore = nodeRequire('nedb');
            path = nodeRequire('path');
            dbLocation = path.join(nodeRequire('nw.gui').App.dataPath, window.netCanvas.Modules.session.name+'.db');
        }

        if (!callback) {
            return false;
        }
        // After init, first priority is to tro to load previous session for this protocol.
        // We might not be able to, because of space constraints.
        // Whatever happens, the result of this should call the callback function passing the session id as the only parameter
        note.info('ioInterface initialising.');
        note.debug('Using '+window.netCanvas.Modules.session.name+' as database name.');

        db = new Datastore({ filename: dbLocation, autoload: true });
        db.find({}).sort({'sessionParameters.date': 1 }).exec(function (err, docs) {
            if (err) {
                return false;
                // handle error
            }
            if (docs.length !== undefined && docs.length > 0) {
                note.debug('ioInterface finished initialising.');
                initialised = true;
                callback(docs[0]._id);

                return true;
            } else {
                var sessionDate = new Date();
                db.insert([{'sessionParameters':{'date':sessionDate}}], function (err, newDoc) {
                    if(err) {
                        note.error(err);
                        return false;
                    }

                    // Two documents were inserted in the database
                    // newDocs is an array with these documents, augmented with their _id
                    id = newDoc[0]._id;

                    initialised = true;
                    callback(newDoc[0]._id);
                    note.debug('ioInterface finished initialising.');
                    return true;
                });
            }

        });

    };

    ioInterface.getDB = function() {
        return db;
    };

    ioInterface.initialised = function() {
        if (initialised) {
            return true;
        } else {
            return false;
        }
    };

    ioInterface.save = function(sessionData, id) {
        delete window.netCanvas.Modules.session.sessionData._id;
        note.info('IOInterface saving.');
        note.debug(sessionData);

        db.update({_id: id }, sessionData, {}, function (err) {
            if (err) {
                return false;
            }
            note.debug('Saving complete.');
        });

    };

    ioInterface.update = function(key, sessionData,id) {
        note.debug('IOInterface being asked to update data store.');
        db.update({_id: id }, sessionData, {}, function (err) {
            if (err) {
                return false;
            }
            note.debug('Updating complete.');
        });

    };

    ioInterface.reset = function(callback) {
        // db.find with empty object returns all objects.
        db.find({}, function (err, docs) {
            if (err) {
                note.error(err);
                return false;
            }

            var resultLength = docs.length;
            for (var i = 0; i < resultLength; i++) {
                ioInterface.deleteDocument(docs[i]._id);
            }

            if (callback) { callback(); }
        });
    };

    ioInterface.deleteDocument = function(callback) {
        note.info('ioInterface deleting document.');
        db.remove({ _id: window.netCanvas.Modules.session.id }, {}, function (err) {
            if (err) {
                note.error(err);
                return false;
            }
            note.debug('Deleting complete.');
            if(callback) { callback(); }
        });
    };

    ioInterface.load = function(callback, id) {
        note.info('ioInterface loading data.');
        db.find({'_id': id}, function (err, docs) {
            if (err) {
                // handle error
                return false;
            }
            callback(docs[0]);
        });
    };

    return ioInterface;
};

module.exports = new IOInterface();
;/* global $, window */
/* exported ListSelect */
module.exports = function ListSelect() {
    'use strict';
    //global vars
    var listSelect = {};
    listSelect.options = {
        targetEl: $('.container'),
        variables: [],
        heading: 'This is a default heading',
        subheading: 'And this is a default subheading'
    };

    var itemClickHandler = function() {
        //   console.log('item click handler');
        var properties = {};
        var nodeid = $(this).data('nodeid');
        // console.log('nodeid: '+nodeid);

        if ($(this).data('selected') === true) {
            // console.log("$(this).data('selected') === true");
            $(this).data('selected', false);
            $(this).css({'border':'2px solid #eee','background':'#eee'});

            // remove values
            $.each(listSelect.options.variables, function(index,value) {
                if (value.value === nodeid) {
                    properties[value.value] = undefined;
                }
            });
            window.network.updateNode(window.network.getNodes({type_t0:'Ego'})[0].id, properties);

        } else {
            $(this).data('selected', true);
            $(this).css({'border':'2px solid red','background':'#E8C0C0'});

            // update values

            $.each(listSelect.options.variables, function(index,value) {
                if (value.value === nodeid) {
                    properties[value.value] = 1;
                }

            });

            window.network.updateNode(window.network.getNodes({type_t0:'Ego'})[0].id, properties);

        }

    };

    var stageChangeHandler = function() {
        listSelect.destroy();
    };

    var processSubmitHandler = function() {
        window.session.nextStage();

    };

    listSelect.destroy = function() {
        // Event Listeners
        window.tools.notify('Destroying listSelect.',0);
        $(window.document).off('click', '.inner', itemClickHandler);
        $(window.document).off('click', '.continue', processSubmitHandler);
        window.removeEventListener('changeStageStart', stageChangeHandler, false);

    };

    listSelect.init = function(options) {
        window.tools.extend(listSelect.options, options);
        // Add header and subheader
        listSelect.options.targetEl.append('<h1 class="text-center">'+listSelect.options.heading+'</h1>');
        listSelect.options.targetEl.append('<p class="lead text-center">'+listSelect.options.subheading+'</p>');
        listSelect.options.targetEl.append('<div class="form-group list-container"></div>');

        $.each(listSelect.options.variables, function(index,value) {
            var el = $('<div class="item"><div class="inner" data-nodeid="'+value.value+'"><h3>'+value.label+'</h3></div></div>');
            var properties = {
                type_t0: 'Ego'
            };

            properties[value.value] = 1;
            if (window.network.getNodes(properties).length>0) {
                el.find('.inner').data('selected', true);
                el.find('.inner').css({'border':'2px solid red','background':'#E8C0C0'});
            }
            $('.list-container').append(el);
        });


        // Event Listeners
        $(window.document).on('click', '.inner', itemClickHandler);
        $(window.document).on('click', '.continue', processSubmitHandler);
        window.addEventListener('changeStageStart', stageChangeHandler, false);


    };

    return listSelect;
};
;/* exported Logger */
/* global window, note */

var Logger = function Logger() {
    'use strict';
    var logger = {};

    // todo: add custom events so that other scripts can listen for log changes (think vis).

    logger.init = function() {
        note.info('Logger initialising.');

        window.log = window.netCanvas.Modules.session.registerData('log', true);

        // listen for log events on node webkit only due to space constraints.
        if (window.isNodeWebkit) {
            window.addEventListener('log', function (e) {
                logger.addToLog(e.detail);
            }, false);
        }
        return true;
    };

    logger.addToLog = function(e) {
        if (!e) { return false; }

        var data = {
            'eventType': e.eventType,
            'targetObject':e.eventObject,
            'eventTime': new Date()
        };

        window.netCanvas.Modules.session.addData('log', data, true);
        var eventLogged = new window.CustomEvent('eventLogged', {'detail':data});
        window.dispatchEvent(eventLogged);
        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);
        return true;
    };

    return logger;
};

module.exports = new Logger();
;/* global window, nodeRequire, FastClick, document, Konva, $, L, log, note, tools, isNodeWebkit, UAParser */
$(document).ready(function() {
    'use strict';

    window.$ = $;
    window.L = L;
    window.Konva = Konva;
    window.gui = {};
    window.netCanvas = {};


    window.isNode = (typeof process !== 'undefined' && typeof require !== 'undefined'); // this check doesn't work, because browserify tries to be clever.
    window.isCordova = !!window.cordova;
    window.isNodeWebkit = false;
    var moment = require('moment');
    window.moment = moment; // needed for module access.
    window.netCanvas.devMode = false;
    window.netCanvas.studyProtocol = 'dphil-protocol';

    //Is this Node.js?
    if(window.isNode) {
        //If so, test for Node-Webkit
        try {
            window.isNodeWebkit = (typeof nodeRequire('nw.gui') !== 'undefined');
            window.gui = nodeRequire('nw.gui');
            window.isNodeWebkit = true;
        } catch(e) {
            window.isNodeWebkit = false;
        }
    }

    // Arguments
    /** build an object (argument: value) for command line arguments independant of platform **/
    window.getArguments = function() {
        var args = false;
        if (window.isNodeWebkit) {
            args = window.gui.App.argv;
            var newArgs = {};
            for (var i= 0; i < args.length; i++) {
                if (args[i].indexOf('--') === 0) { // Argument begins with --
                    var currentArg = args[i].substring(2);
                    currentArg = currentArg.split('=');
                    // remove quotes around strings
                    if (currentArg[1].charAt(0) === '"' && currentArg[1].charAt(currentArg[1].length -1) === '"') {
                        currentArg[1] = currentArg[1].substr(1,currentArg[1].length -2);
                    }
                    newArgs[currentArg[0]] = currentArg[1];
                }
            }
            return newArgs;
        } else if (window.isCordova) {
            // what can we do here?
            return args;
        } else {
            // browser
            var match,
            pl     = /\+/g,  // Regex for replacing addition symbol with a space
            search = /([^&=]+)=?([^&]*)/g,
            decode = function (s) { return decodeURIComponent(s.replace(pl, ' ')); },
            query  = window.location.search.substring(1);

            args = {};
            while ((match = search.exec(query))) {
                args[decode(match[1])] = decode(match[2]);
            }

            return args;
        }
    };

    // Initialise logging and custom notification
    window.note = log.noConflict();
    note.setLevel('warn', false);

    window.logger = require('./logger.js');

    var args = window.getArguments();

    // Enable dev mode.
    if (args && typeof args.dev !== 'undefined' && args.dev !== false && args.dev !== 0) {

        // Set the debug level
        note.setLevel('info', false);
        note.info('Development mode enabled.');

        // Set dev mode to true
        window.netCanvas.devMode = true;

        // Show dev tools if we are in node webkit
        if (window.isNodeWebkit) {
            window.gui.Window.get().showDevTools();
        } else {
            // no way to show dev tools on web browser
        }

        // Show the refresh button
        $('.refresh-button').show();

        // Disable caching of AJAX requests
        $.ajaxSetup({ cache: false });
    } else {
        $('.refresh-button').hide();
        if (window.isNodeWebkit) {
            window.gui.Window.get().enterFullscreen();
        } else {
            // no way to enter full screen automatically on web browser.
            // could show button or prompt?
        }
    }

    // enable custom log level
    if (args && typeof args.debugLevel !== 'undefined') {
        try {
            note.setLevel(args.debugLevel, false);
            note.info('Console logging level set to '+args.debugLevel);
        } catch (e) {
            note.error('Invalid debugLevel parameter "'+args.debugLevel+'"');
        }
    }

    $('.refresh-button').on('click', function() {
        if(window.isNodeWebkit) {
            var _window = window.gui.Window.get();
            _window.reloadDev();
        } else if (window.isCordova) {
            window.location.reload();
        } else {
            window.location.reload();
        }

    });

    // Override notifications on node webkit to use native notifications
    if (isNodeWebkit === true) {
        var oldError = note.error;
        var oldWarn = note.warn;

        note.error = function(msg) {
            tools.nwNotification({
                icon: 'img/error.png',
                body: msg
            });

            oldError(msg);
        };

        note.warn = function(msg) {
            tools.nwNotification({
                icon: 'img/alert.png',
                body: msg
            });

            oldWarn(msg);
        };
    }

    // print some version stuff
    if (window.isNodeWebkit) {
        var version = window.process.versions['node-webkit'];
        note.info('netCanvas '+window.gui.App.manifest.version+' running on NWJS '+version);
    } else if (window.isCordova) {
        // can we get meaningful version info on cordova? how about a get request to the package.json?
        note.info('netCanvas running on cordova '+window.cordova.version+' on '+window.cordova.platformId);
    } else {
        // anything we can do in browser? yes.
        var parser = new UAParser();
        note.info('netCanvas running on '+parser.getBrowser().name+' '+parser.getBrowser().major+' on '+parser.getOS().name+' '+parser.getOS().version);
    }

    var protocolExists = function(protocol, callback) {
        var response = false;
        var availableProtocols = ['RADAR', 'default', 'dphil-protocol'];

        if (availableProtocols.indexOf(protocol) !== -1) {
            response = true;
        }

        callback(response);
    };

    // Require tools
    window.tools = require('./tools');

    // Interface Modules
    window.netCanvas.Modules = {};
    window.netCanvas.Modules.Network = require('./network.js');
    window.netCanvas.Modules.NameGenerator = require('./namegenerator.js');
    window.netCanvas.Modules.NameGeneratorMulti = require('./namegeneratormulti.js');
    window.netCanvas.Modules.DateInterface = require('./dateinterface.js');
    window.netCanvas.Modules.OrdBin = require('./ordinalbin.js');
    window.netCanvas.Modules.IOInterface = require('./iointerface.js');
    window.netCanvas.Modules.GeoInterface = require('./map.js');
    window.netCanvas.Modules.RoleRevisit = require('./rolerevisit.js');
    window.netCanvas.Modules.ListSelect = require('./listselect.js');
    window.netCanvas.Modules.MultiBin = require('./multibin.js');
    window.netCanvas.Modules.Sociogram = require('./sociogram.js');
    window.netCanvas.Modules.SociogramMulti = require('./sociogrammulti.js');
    window.netCanvas.Modules.SociogramMissing = require('./sociogrammissing.js');
    window.netCanvas.Modules.FormBuilder = require('./formbuilder.js');
    window.netCanvas.Modules.ContextGenerator = require('./contextgenerator.js');
    window.netCanvas.Modules.Menu = require('./menu.js');


    // Initialise datastore
    window.dataStore = require('./iointerface.js');


    // Set up a new session
    window.netCanvas.Modules.session = require('./session.js');


    // study protocol
    if (args && typeof args.protocol !== 'undefined') {
        window.netCanvas.studyProtocol = args.protocol;
    }

    // to do: expand this function to validate a proposed session, not just check that it exists.
    protocolExists(window.netCanvas.studyProtocol, function(exists){
        if (!exists) {
            note.warn('WARNING: Specified study protocol was not found. Using default.');
            window.netCanvas.studyProtocol = 'default';
        }
        // Initialise session now.
        window.netCanvas.Modules.session.init(function() {
            window.netCanvas.Modules.session.loadProtocol();
        });
        window.logger.init();
        if ('addEventListener' in document) {
            document.addEventListener('DOMContentLoaded', function() {
                FastClick.attach(document.body);
            }, false);
        }

    });

});
;/* global $, window */
/* exported GeoInterface */

/*
 Map module.
*/

module.exports = function GeoInterface() {
    'use strict';
  	// map globals
    var log;
    var taskComprehended = false;
 	var geoInterface = {};
 	var leaflet;
 	var edges;
 	var variable = 'res_chicago_location_p_t0';
 	var currentPersonIndex = 0;
 	var geojson;
 	var mapNodeClicked = false;
    var colors = ['#67c2d4','#1ECD97','#B16EFF','#FA920D','#e85657','#20B0CA','#FF2592','#153AFF','#8708FF'];

  	// Private functions

	function toggleFeature(e) {
        if (taskComprehended === false) {
            var eventProperties = {
                zoomLevel: leaflet.getZoom(),
                stage: window.netCanvas.Modules.session.currentStage(),
                timestamp: new Date()
            };
            log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
            window.dispatchEvent(log);
            taskComprehended = true;
        }

        var mapEventProperties = {
            zoomLevel: leaflet.getZoom(),
            timestamp: new Date()
        };
        log = new window.CustomEvent('log', {'detail':{'eventType': 'mapMarkerPlaced', 'eventObject':mapEventProperties}});
        window.dispatchEvent(log);
		var layer = e.target;
		var properties;

		// is there a map node already selected?
		if (mapNodeClicked === false) {
	 		// no map node selected, so highlight this one and mark a map node as having been selected.
	  		highlightFeature(e);
	  		// updateInfoBox('You selected: <strong>'+layer.feature.properties.name+'</strong>. Click the "next" button to place the next person.');

	  		// Update edge with this info
	  		properties = {};
	  		properties[variable] = layer.feature.properties.name;
	  		window.network.updateEdge(edges[currentPersonIndex].id, properties);
	  		$('.map-node-location').html('<strong>Currently marked as:</strong> <br>'+layer.feature.properties.name);
		} else {
	  	// Map node already selected. Have we clicked the same one again?
	  		if (layer.feature.properties.name === mapNodeClicked) {
	    		// Same map node clicked. Reset the styles and mark no node as being selected
	      		resetHighlight(e);
	      		mapNodeClicked = false;
		  		properties = {};
		  		properties[variable] = undefined;
		  		window.network.updateEdge(edges[currentPersonIndex].id, properties);

	  		} else {
          resetAllHighlights();
          highlightFeature(e);
          properties = {};
          properties[variable] = layer.feature.properties.name;
          window.network.updateEdge(edges[currentPersonIndex].id, properties);
		    // TODO: Different node clicked. Reset the style and then mark the new one as clicked.
	  		}

		}

	}

  	function highlightCurrent() {

      if (edges[currentPersonIndex][variable] !== undefined) {
        mapNodeClicked = edges[currentPersonIndex][variable];
        if (edges[currentPersonIndex][variable] === 'Homeless' || edges[currentPersonIndex][variable] === 'Jail') {
          resetPosition();
          var text = 'Homeless';
          if (edges[currentPersonIndex][variable] === 'Jail') {
            text = 'in Jail';
          }
          $('.map-node-location').html('<strong>Currently marked as:</strong> <br>'+text);
        } else {
          $.each(geojson._layers, function(index,value) {
            if (value.feature.properties.name === edges[currentPersonIndex][variable]) {
              $('.map-node-location').html('<strong>Currently marked as:</strong> <br>'+edges[currentPersonIndex][variable]);
              selectFeature(value);
            }
          });
        }

  		} else {
  			resetPosition();
  		}

  	}


  	function highlightFeature(e) {
        var layer = e.target;
        leaflet.fitBounds(e.target.getBounds(), {maxZoom:14});

        layer.setStyle({
        	fillOpacity: 0.8,
          fillColor: colors[1]
        });

        if (!window.L.Browser.ie && !window.L.Browser.opera) {
        	layer.bringToFront();
        }

        mapNodeClicked = layer.feature.properties.name;
    }

  	function selectFeature(e) {
        var layer = e;
        leaflet.fitBounds(e.getBounds(), {maxZoom:14});

        layer.setStyle({
        	fillOpacity: 0.8,
          fillColor: colors[1]
        });

        if (!window.L.Browser.ie && !window.L.Browser.opera) {
        	layer.bringToFront();
        }
    }

  	function resetHighlight(e) {
  		$('.map-node-location').html('');
  		mapNodeClicked = false;
  		geojson.resetStyle(e.target);
  	}

  	function resetAllHighlights() {
  		$('.map-node-location').html('');
  		mapNodeClicked = false;
		$.each(geojson._layers, function(index,value) {
			geojson.resetStyle(value);
		});
  	}

  	function onEachFeature(feature, layer) {
  		layer.on({
  			click: toggleFeature
  		});
  	}

  	function resetPosition() {
  		leaflet.setView([41.798395426119534,-87.839671372338884], 11);
  	}

    function setHomeless() {
        resetAllHighlights();
        var properties = {};
        properties[variable] = 'Homeless';
        window.network.updateEdge(edges[currentPersonIndex].id, properties);
        $('.map-node-location').html('<strong>Currently marked as:</strong> <br>Homeless');
    }

    function setJail() {
        resetAllHighlights();
        var properties = {};
        properties[variable] = 'Jail';
        window.network.updateEdge(edges[currentPersonIndex].id, properties);
        $('.map-node-location').html('<strong>Currently marked as:</strong> <br>in Jail');
    }

    var stageChangeHandler = function() {
        geoInterface.destroy();
    };

  	// Public methods

  	geoInterface.nextPerson = function() {

  		if (currentPersonIndex < edges.length-1) {
  			resetAllHighlights();
	  		currentPersonIndex++;
	        $('.current-id').html(currentPersonIndex+1);
	        $('.map-node-status').html('Tap on the map to indicate the general area where <strong>'+edges[currentPersonIndex].nname_t0+'</strong> lives.');

  			// if variable already set, highlight it and zoom to it.
  			highlightCurrent();
        if (currentPersonIndex === edges.length-1) {
          $('.map-forwards').hide();
        } else {
          $('.map-forwards').show();
        }
        if (currentPersonIndex === 0) {
          $('.map-back').hide();
        } else {
          $('.map-back').show();
        }
  		}

  	};

  	geoInterface.previousPerson = function() {
	  	if (currentPersonIndex > 0) {

	  		resetAllHighlights();
	  		currentPersonIndex--;
	        $('.current-id').html(currentPersonIndex+1);
	        $('.map-node-status').html('Tap on the map to indicate the general area where <strong>'+edges[currentPersonIndex].nname_t0+'</strong> lives.');

  			// if variable already set, highlight it and zoom to it.
  			highlightCurrent();
        if (currentPersonIndex === edges.length-1) {
          $('.map-forwards').hide();
        } else {
          $('.map-forwards').show();
        }
        if (currentPersonIndex === 0) {
          $('.map-back').hide();
        } else {
          $('.map-back').show();
        }
	    }
  	};

  	geoInterface.init = function() {

  		// Initialize the map, point it at the #map element and center it on Chicago
        leaflet = window.L.map('map', {
            maxBounds: [[41.4985986599114, -88.498240224063451],[42.1070175291862,-87.070984247165939]],
            zoomControl: false
        });

        window.L.tileLayer('http://{s}.{base}.maps.cit.api.here.com/maptile/2.1/maptile/{mapID}/normal.day.transit/{z}/{x}/{y}/256/png8?app_id={app_id}&app_code={app_code}', {
            subdomains: '1234',
            mapID: 'newest',
            app_id: 'FxdAZ7O0Wh568CHyJWKV',
            app_code: 'FuQ7aPiHQcR8BSnXBCCmuQ',
            base: 'base',
            minZoom: 0,
            maxZoom: 20
        }).addTo(leaflet);

        $.ajax({
          	dataType: 'json',
          	url: 'data/census2010.json',
          	success: function(data) {
            	geojson = window.L.geoJson(data, {
                	onEachFeature: onEachFeature,
                	style: function () {
                  		return {weight:1,fillOpacity:0,strokeWidth:0.2, color:colors[1]};
                	}
            	}).addTo(leaflet);

		        // Load initial node
		        edges = window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id, type:'Dyad', res_cat_p_t0: 'Chicago'});
		        $('.map-counter').html('<span class="current-id">1</span>/'+edges.length);
		        $('.map-node-status').html('Tap on the map to indicate the general area where <strong>'+edges[0].nname_t0+'</strong> lives.');

            	// Highlight initial value, if set
            	highlightCurrent();
              $('.map-back').hide();
              if (currentPersonIndex === edges.length-1) {
                $('.map-forwards').hide();
              } else {
                $('.map-forwards').show();
              }
          	}
        });

        // Events
        window.addEventListener('changeStageStart', stageChangeHandler, false);
        $('.map-back').on('click', geoInterface.previousPerson);
        $('.map-forwards').on('click', geoInterface.nextPerson);
        $('.homeless').on('click', setHomeless);
        $('.jail').on('click', setJail);

  	};

  	geoInterface.destroy = function() {
    	// Used to unbind events
        leaflet.remove();
        window.removeEventListener('changeStageStart', stageChangeHandler, false);
    	$('.map-back').off('click', geoInterface.previousPerson);
        $('.map-forwards').off('click', geoInterface.nextPerson);
        $('.homeless').on('click', setHomeless);
        $('.jail').on('click', setJail);
  	};

  	return geoInterface;
};
;/* global $, window, module, note, alert */
/* exported Menu */
module.exports = function Menu(options) {
    'use strict';
    var menu = {};
    var menuEl;

    menu.options = {
        name: 'Default',
        icon: 'fa-icon',
        items: [
            {
                label: 'Label',
                icon: 'fa-bars',
                action: function() {
                    alert('Yo');
                }
            }
        ]
    };

    menu.getMenu = function() {
        return menuEl;
    };

    menu.closeMenu = function() {

        var targetMenuObj = $('.'+menuEl.name+'-menu');
        $('.paginate').removeClass('slide');
        $('.content').removeClass('pushed');
        targetMenuObj.removeClass('open');
        $('.menu-btn').show();

        setTimeout(function() {
            $('body').removeClass(menuEl.name);
        }, 500);

    };

    menu.openMenu = function() {
        $('body').addClass(menuEl.name);
        var targetMenuObj = $('.'+menuEl.name+'-menu');
        setTimeout(function() {
            $('.paginate').addClass('slide');
            $('.content').addClass('pushed');
            targetMenuObj.addClass('open');
            $('.menu-btn').hide();
        }, 10);

    };

    menu.destroy = function() {
        $(menuEl.button).remove();
        $(menuEl.menu).remove();
    };

    menu.addItem = function(label,icon,callback) {
        var listIcon = 'fa-file-text';
        if (icon) {
            listIcon = icon;
        }
        var menuItem = $('<li><span class="fa '+listIcon+' menu-icon"></span> '+label+'</li>');
        menuEl.menu.find('ul').append(menuItem);
        menuItem.on('click', function() {
            $('.paginate').removeAttr('disabled');
            menu.closeMenu();
            setTimeout(function() {
                callback();
            }, 200);
        });

    };

    menu.init = function(options) {
        note.info('Menu initialising.');
        window.tools.extend(menu.options,options);

        var newMenu = {};
        newMenu.name = options.name;
        newMenu.button = $('<span class="fa fa-2x '+options.icon+' menu-btn shown '+options.name+'"></span>');
        $('.menu-container').append(newMenu.button);

        var menuClass = options.name+'-menu';
        newMenu.menu = $('<div class="menu '+menuClass+'"><div class="menu-content"><h2>'+options.name+'</h2><ul></ul></div></div>');
        newMenu.closeBtn = $('<span class="icon icon-close"><i class="fa fa-times fa-2x"></i></span>');
        $(newMenu.menu).append(newMenu.closeBtn);
        $('.menu-container').append(newMenu.menu);

        newMenu.button.on('click', function() {
            menu.openMenu();
        });

        newMenu.closeBtn.on( 'click', function() {
            menu.closeMenu();
        });

        menuEl = newMenu;

        $.each(menu.options.items, function(index, value) {
            menu.addItem(value.label, value.icon, value.action);
        });

    };

    menu.init(options);

    return menu;

};
;/* global $, window */
/* exported MultiBin */
module.exports = function MultiBin() {
	'use strict';
	//global vars
	var log;
	var taskComprehended = false;
	var animating = false;
	var open = false;
	var multiBin = {}, followup;
	multiBin.options = {
		targetEl: $('.container'),
		edgeType: 'Dyad',
		variable: {
			label:'multibin_variable',
			values: [
				'Variable 1',
			]
		},
		filter: undefined,
		heading: 'Default Heading',
		subheading: 'Default Subheading.'
	};

	var stageChangeHandler = function() {
		multiBin.destroy();
	};

	var followupHandler = function(e) {
		e.preventDefault();
		// Handle the followup data

		// First, retrieve the relevant values

		var nodeid = followup;

		// Next, get the edge we will be storing on
		var criteria = {
			to:nodeid
		};

		window.tools.extend(criteria, multiBin.options.criteria);
		var edge = window.network.getEdges(criteria)[0];

		// Create an empty object for storing the new properties in
		var followupProperties = {};

		// Assign a new property according to the variable name(s)
		$.each(multiBin.options.followup.questions, function(index) {
			var followupVal = $('#'+multiBin.options.followup.questions[index].variable).val();
			followupProperties[multiBin.options.followup.questions[index].variable] = followupVal;
		});

		// Update the edge
		window.tools.extend(edge, followupProperties);
		window.network.updateEdge(edge.id, edge);

		// Clean up
		$.each(multiBin.options.followup.questions, function(index) {
			$('#'+multiBin.options.followup.questions[index].variable).val('');
		});

		$('.followup').hide();
		$('.black-overlay').hide();
	};

	var followupCancelHandler = function() {

		// Clean up
		$('#'+multiBin.options.followup.variable).val('');
		$('.followup').hide();
		$('.black-overlay').hide();
	};

	var backgroundClickHandler = function(e) {
		e.stopPropagation();
		if(open === true) {
			if ($('.node-bin-active').length > 0) {
					animating = true;
					setTimeout(function() {
						$('.node-bin-container').children().css({opacity:1});
						$('.node-question-container').fadeIn();
					}, 300);

					var current = $('.node-bin-active');
					$(current).removeClass('node-bin-active');
					$(current).addClass('node-bin-static');
					$(current).children('h1, p').show();
					$('.draggable').draggable({ cursor: 'pointer', revert: 'invalid', disabled: false, start: function(){
						if (taskComprehended === false) {
							var eventProperties = {
								stage: window.netCanvas.Modules.session.currentStage(),
								timestamp: new Date()
							};
							log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
							window.dispatchEvent(log);
							taskComprehended = true;
						}
					}});

					setTimeout(function() {
						open = false;
						animating = false;
					}, 500);

			}
		} else {
		}


	};

	var nodeBinClickHandler = function() {
		if (open === false) {

				if(!$(this).hasClass('node-bin-active')) {
					animating = true;
					open = true;
					$('.node-bin-container').children().not(this).css({opacity:0});
					$('.node-question-container').hide();
					var position = $(this).offset();
					var nodeBinDetails = $(this);
					nodeBinDetails.children('.active-node-list').children('.node-bucket-item').removeClass('shown');
					setTimeout(function() {
						nodeBinDetails.offset(position);
						nodeBinDetails.addClass('node-bin-active');

						nodeBinDetails.removeClass('node-bin-static');
						nodeBinDetails.children('h1, p').hide();

						// $('.content').append(nodeBinDetails);

						nodeBinDetails.addClass('node-bin-active');
						setTimeout(function(){
							var timer = 0;
							$.each(nodeBinDetails.children('.active-node-list').children(), function(index,value) {
								timer = timer + (index*10);
								setTimeout(function(){
									$(value).on('click', nodeClickHandler);
									$(value).addClass('shown');
								},timer);
							});
						},300);
						open = true;
					}, 500);

					setTimeout(function() {
						animating = false;
					}, 500);

				}
		} else {
		}

	};

	var nodeClickHandler = function(e) {
		e.preventDefault();
		e.stopPropagation();
		e.stopImmediatePropagation();

		var el = $(this);
		var id = $(this).parent().parent().data('index');

		// has the node been clicked while in the bucket or while in a bin?
		if ($(this).parent().hasClass('active-node-list')) {
			// it has been clicked while in a bin.
			var edgeID = window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id,to:el.data('node-id'), type:multiBin.options.edgeType})[0].id;
			var properties = {};
			// make the values null when a node has been taken out of a bin
			properties[multiBin.options.variable.label] = '';

			// dont forget followups
			if(typeof multiBin.options.followup !== 'undefined') {
				$.each(multiBin.options.followup.questions, function(index, value) {
					properties[value.variable] = undefined;
				});
			}
			window.network.updateEdge(edgeID,properties);

			$(this).css({'top':0, 'left' :0});
			$(this).appendTo('.node-bucket');
			$(this).css('display', '');
			var noun = 'people';
			if ($('.c'+id).children('.active-node-list').children().length === 1) {
				noun = 'person';
			}
			if ($('.c'+id).children('.active-node-list').children().length === 0) {
				$('.c'+id).children('p').html('(Empty)');
			} else {
				$('.c'+id).children('p').html($('.c'+id).children('.active-node-list').children().length+' '+noun+'.');
			}


		}

	};

	multiBin.destroy = function() {
		// Event Listeners
		window.tools.notify('Destroying multiBin.',0);
		window.removeEventListener('changeStageStart', stageChangeHandler, false);
		$('.node-bin-static').off('click', nodeBinClickHandler);
		$('.node-bucket-item').off('click', nodeClickHandler);
		$('.content').off('click', backgroundClickHandler);
		$('.followup-submit').off('click', followupHandler);
		$('.followup-cancel').off('click', followupCancelHandler);
		$('.followup').remove();

	};

	multiBin.init = function(options) {
		window.tools.extend(multiBin.options, options);

		multiBin.options.targetEl.append('<div class="node-question-container"></div>');

		// Add header and subheader
		$('.node-question-container').append('<h1>'+multiBin.options.heading+'</h1>');

		// Add node bucket
		$('.node-question-container').append('<div class="node-bucket"></div>');

		// Create the followup dialog, if it exists
		if(typeof multiBin.options.followup !== 'undefined') {
			$('body').append('<div class="followup overlay"><form class="followup-form"></form></div>');

			if(typeof multiBin.options.followup.linked !== 'undefined' && multiBin.options.followup.linked === true) {
				var first = true;

				$.each(multiBin.options.followup.questions, function(index, value) {
					$('.followup').children('form').append('<h2>'+value.prompt+'</h2><div class="row form-group"><input type="number" class="form-control '+value.variable+'" id="'+value.variable+'" name="followup" required></div>');

					if (first) {
						$('#'+value.variable).change(function() {
							if ($('#'+multiBin.options.followup.questions[(index+1)].variable).val() > $('#'+value.variable).val()) {
								$('#'+multiBin.options.followup.questions[(index+1)].variable).val($('#'+value.variable).val());
							}
							$('#'+multiBin.options.followup.questions[(index+1)].variable).attr('max', $('#'+value.variable).val());

						});
					}


					first = !first;
				});
			} else {
				$.each(multiBin.options.followup.questions, function(index, value) {
					$('.followup').children('form').append('<h2>'+value.prompt+'</h2><div class="row form-group"><input type="text" class="form-control '+value.variable+'" id="'+value.variable+'" name="followup" required></div>');
				});
			}

			$('.followup').children('form').append('<div class="row form-group"><button type="submit" class="btn btn-primary btn-block followup-submit">Continue</button></div>');

			// Add cancel button if required
			if (typeof multiBin.options.followup.cancel !== 'undefined') {
				$('.overlay').children().last('.form-group').append('<div class="row form-group"><button class="btn btn-warning btn-block followup-cancel">'+multiBin.options.followup.cancel+'</button></div>');
			}

		}

		// bin container
        multiBin.options.targetEl.append('<div class="node-bin-container"></div>');


		var containerWidth = $('.node-bin-container').outerWidth();
		var containerHeight = $('.node-bin-container').outerHeight();
		var number = multiBin.options.variable.values.length;
		var rowThresh = number > 4 ? Math.floor(number*0.66) : 4;
		var itemSize = 0;
		var rows = Math.ceil(number/rowThresh);

		if (containerWidth >= containerHeight) {
			itemSize = number >= rowThresh ? containerWidth/rowThresh : containerWidth/number;

			while(itemSize > (containerHeight/rows)) {
				itemSize = itemSize*0.99;
			}

		} else {
			itemSize = number >= rowThresh ? containerHeight/rowThresh : containerHeight/number;

			while(itemSize > containerWidth) {
				itemSize = itemSize*0.99;
			}
		}

		// get all edges
		var edges = window.network.getEdges(multiBin.options.criteria, multiBin.options.filter);
		// var newLine = false;
		// One of these for each bin. One bin for each variable value.
		$.each(multiBin.options.variable.values, function(index, value){

			// if (index+1>number && newLine === false) {
			// 	multiBin.options.targetEl.append('<br>');
			// 	newLine = true;
			// }
			var newBin = $('<div class="node-bin node-bin-static c'+index+'" data-index="'+index+'"><h1>'+value+'</h1><p class="lead">(Empty)</p><div class="active-node-list"></div></div>');
			newBin.data('index', index);
			$('.node-bin-container').append(newBin);
			$('.c'+index).droppable({ accept: '.draggable',
			drop: function(event, ui) {
				var dropped = ui.draggable;
				var droppedOn = $(this);
                $(dropped).css({'top':0, 'left' :0});
				// Check if the node has been dropped into a bin that triggers the followup
				if(typeof multiBin.options.followup !== 'undefined' && multiBin.options.followup.trigger.indexOf(multiBin.options.variable.values[index]) >=0 ) {
					$('.followup').show();
					$('.black-overlay').show();
					$('#'+multiBin.options.followup.questions[0].variable).focus();
					followup = $(dropped).data('node-id');
				} else if (typeof multiBin.options.followup !== 'undefined') {
					// Here we need to remove any previously set value for the followup variable, if it exists.
					var nodeid = $(dropped).data('node-id');

					// Next, get the edge we will be storing on
					var criteria = {
						to:nodeid
					};

					window.tools.extend(criteria, multiBin.options.criteria);
					var edge = window.network.getEdges(criteria)[0];

					// Create an empty object for storing the new properties in
					var followupProperties = {};

					// Assign a new property according to the variable name(s)
					$.each(multiBin.options.followup.questions, function(index) {
						followupProperties[multiBin.options.followup.questions[index].variable] = undefined;
					});

					// Update the edge
					window.tools.extend(edge, followupProperties);
					window.network.updateEdge(edge.id, edge);

					// Clean up
					$.each(multiBin.options.followup.questions, function(index) {
						$('#'+multiBin.options.followup.questions[index].variable).val('');
					});

				}

				$(dropped).appendTo(droppedOn.children('.active-node-list'));
				var properties = {};
				properties[multiBin.options.variable.label] = multiBin.options.variable.values[index];
				// Add the attribute
				var edgeID = window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id,to:$(dropped).data('node-id'), type:multiBin.options.edgeType})[0].id;
				window.network.updateEdge(edgeID,properties);

				var noun = 'people';
				if ($('.c'+index+' .active-node-list').children().length === 1) {
					noun = 'person';
				}
				$('.c'+index+' p').html($('.c'+index+' .active-node-list').children().length+' '+noun+'.');

				var el = $('.c'+index);
				// var origBg = el.css('background-color');
				setTimeout(function() {
					el.addClass('dropped');
				},0);

				setTimeout(function(){
					el.removeClass('dropped');
					el.removeClass('yellow');
				}, 1000);
			},
			over: function() {
				$(this).addClass('yellow');

			},
			out: function() {
				$(this).removeClass('yellow');
			}
		});

	});

	// $('.node-bin').css({width:itemSize*0.60-20,height:itemSize*0.60-20});
	$('.node-bin').css({width:itemSize,height:itemSize});
	// $('.node-bin').css({width:itemSize,height:itemSize});

	// $('.node-bin h1').css({marginTop: itemSize/3});

	$.each($('.node-bin'), function(index, value) {
		var oldPos = $(value).offset();
		$(value).data('oldPos', oldPos);
		$(value).css(oldPos);

	});

	$('.node-bin').css({position:'absolute'});

	// Add edges to bucket or to bins if they already have variable value.
	$.each(edges, function(index,value) {

		// We need the dyad edge so we know the nname for other types of edges
		var dyadEdge = window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id, type:'Dyad', to:value.to})[0];
		if (value[multiBin.options.variable.label] !== undefined && value[multiBin.options.variable.label] !== '') {
			index = multiBin.options.variable.values.indexOf(value[multiBin.options.variable.label]);
			$('.c'+index).children('.active-node-list').append('<div class="node-bucket-item draggable" data-node-id="'+value.to+'">'+dyadEdge.nname_t0+'</div>');
			var noun = 'people';
			if ($('.c'+index).children('.active-node-list').children().length === 1) {
				noun = 'person';
			}
			if ($('.c'+index).children('.active-node-list').children().length === 0) {
				$('.c'+index).children('p').html('(Empty)');
			} else {
				$('.c'+index).children('p').html($('.c'+index).children('.active-node-list').children().length+' '+noun+'.');
			}
		} else {
			$('.node-bucket').append('<div class="node-bucket-item draggable" data-node-id="'+value.to+'">'+dyadEdge.nname_t0+'</div>');
		}

	});
	$('.draggable').draggable({ cursor: 'pointer', revert: 'invalid', disabled: false , start: function(){
		if (taskComprehended === false) {
			var eventProperties = {
				stage: window.netCanvas.Modules.session.currentStage(),
				timestamp: new Date()
			};
			log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
			window.dispatchEvent(log);
			taskComprehended = true;
		}
	}});

	// Event Listeners
	window.addEventListener('changeStageStart', stageChangeHandler, false);
	$('.node-bin-static').on('click', nodeBinClickHandler);
	$('.content').on('click', backgroundClickHandler);
	$('.followup-form').on('submit', followupHandler);
	$('.followup-cancel').on('click', followupCancelHandler);

};
return multiBin;
};
;/* global $, window, Odometer, document, note  */
/* exported Namegenerator */
module.exports = function NameGenerator() {
    'use strict';
    //global vars
    var nameGenerator = {};
    var options = {
    	targetEl: $('.container'),
    	network: window.network,
    	form: window.forms.newNodeForm,
    	heading: 'Within the last 6 months or so, who have you felt particularly close to, or discussed important personal matters with?',
    	subheading: '',
    	panels: [],
    	dataOrigin: {
    		type: 'node', // edge or node.
    		variables: []
    	},
    	dataTarget: {
    		type: 'node',
    		variables: [
    			{label: 'ng', value: 'close'},
    			{label: 'contexts', value: []}
    		]
    	}
    };

    var nodeBoxOpen = false;
    var editing = false;
    var relationshipPanel;
    var newNodePanel;
    var newNodePanelContent;
    var alterCounter;
    var moduleEvents = [];

    var alterCount = options.network.getNodes({type_t0: 'Alter'}).length;

    var roles = {
        'Friend': ['Best Friend','Friend','Ex-friend','Other type'],
        'Family / Relative': ['Parent / Guardian','Brother / Sister','Grandparent','Other Family','Chosen Family'],
        'Romantic / Sexual Partner': ['Boyfriend / Girlfriend','Ex-Boyfriend / Ex-Girlfriend','Booty Call / Fuck Buddy / Hook Up','One Night Stand','Other type of Partner'],
        'Acquaintance / Associate': ['Coworker / Colleague','Classmate','Roommate','Friend of a Friend','Neighbor','Other'],
        'Other Support / Source of Advice': ['Teacher / Professor','Counselor / Therapist','Community Agency Staff','Religious Leader','Mentor','Coach','Other'],
        'Drug Use': ['Someone you use drugs with','Someone you buy drugs from'],
        'Other': ['Other relationship']
    };

    var namesList = ['Joshua', 'Bernie', 'Michelle', 'Gregory', 'Patrick', 'Barney', 'Jonathon','Myles','Alethia','Tammera','Veola','Meredith','Renee','Grisel','Celestina','Fausto','Eliana','Raymundo','Lyle','Carry','Kittie','Melonie','Elke','Mattie','Kieth','Lourie','Marcie','Trinity','Librada','Lloyd','Pearlie','Velvet','Stephan','Hildegard','Winfred','Tempie','Maybelle','Melynda','Tiera','Lisbeth','Kiera','Gaye','Edra','Karissa','Manda','Ethelene','Michelle','Pamella','Jospeh','Tonette','Maren','Aundrea','Madelene','Epifania','Olive'];

    var cardClickHandler = function() {
        // Handles what happens when a card is clicked

        // Get the ID of the node corresponding to this card, stored in the data-index property.
        var index = $(this).data('index');

        var node = options.network.getNode(index);

        // add fields from dataTarget
        var properties = {};
        properties.id = {
            type:'hidden',
            title: 'id'
        };
        $.each(options.dataTarget.variables, function(targetIndex, targetValue) {
            properties[targetValue.label] = {
                type:'hidden',
                title: targetValue.label
            };
        });
        window.forms.nameGenForm.addTemporaryFields(properties);

        window.forms.nameGenForm.addData(node);
        window.forms.nameGenForm.show();


    };

    nameGenerator.generateTestAlters = function(number) {

        if (!number) {
            note.error('You must specify the number of test alters you want to create. Cancelling!');
            return false;
        }

        var eachTime = 1000;

        for (var i = 0; i < number; i++) {
            var timer = eachTime*i;
            setTimeout(nameGenerator.generateAlter, timer);
        }

    };

    nameGenerator.updateSidePanel = function() {
        // Empty it
        $('.current-node-list').children().remove();

        // ignore ego and any nodes that are visible in the main node list
        var nodes = options.network.getNodes({}, function (results) {
            var filteredResults = [];
            $.each(results, function(index,value) {
                if (value.type !== 'Ego' && $('[data-index='+value.id+']').length === 0) {
                    filteredResults.push(value);
                }
            });

            return filteredResults;
        });

        $.each(nodes, function(index,value) {
            var el = $('<div class="node-list-item">'+value.label+'</div>');
            $('.current-node-list').append(el);
        });

    };

    nameGenerator.generateAlter = function() {
        // We must simulate every interaction to ensure that any errors are caught.
        $('.new-node-button').click();
        setTimeout(function() {
            $('#new-node-submit-btn').click();
        }, 500);

        $('#first_name').val(namesList[Math.floor(window.tools.randomBetween(0,namesList.length))]);
        $('#last_name').val(namesList[Math.floor(window.tools.randomBetween(0,namesList.length))]);

        $('#label').val($('#first_name').val());
    };

    nameGenerator.openNodeBox = function() {
        $('.newNodeBox').height($('.newNodeBox').height());
        $('.newNodeBox').addClass('open');
        $('.black-overlay').css({'display':'block'});
        setTimeout(function() {
            $('.black-overlay').addClass('show');
        }, 50);
        setTimeout(function() {
            $('#ngForm input:text').first().focus();
        }, 1000);

        nodeBoxOpen = true;
    };

    nameGenerator.closeNodeBox = function() {
        $('input#age_p_t0').prop( 'disabled', false);
        $('.black-overlay').removeClass('show');
        $('.newNodeBox').removeClass('open');
        setTimeout(function() { // for some reason this doenst work without an empty setTimeout
            $('.black-overlay').css({'display':'none'});
        }, 300);
        nodeBoxOpen = false;
        $('#ngForm').trigger('reset');
        editing = false;
        $('.relationship-button').html('Set Relationship Roles');
        $(relationshipPanel).find('.relationship').removeClass('selected');
    };

    nameGenerator.destroy = function() {
        note.debug('Destroying nameGenerator.');

        // Event listeners
        window.tools.Events.unbind(moduleEvents);

    };

    nameGenerator.bindEvents = function() {
        // Event listeners
        // Events
		var event = [{
			event: 'changeStageStart',
			handler: nameGenerator.destroy,
			targetEl:  window
		},
		{
			event: 'nodeAdded',
			handler: nameGenerator.nodeAdded,
			targetEl:  window
		},
        {
            event: 'nodeUpdate',
            handler: nameGenerator.nodeEdited,
            targetEl:  window
        },
        {
            event: 'click',
            handler: cardClickHandler,
            targetEl:  '.card'
        },
        {
            event: 'click',
            handler: nameGenerator.showNewNodeForm,
            targetEl:  '.new-node-button'
        }];
		window.tools.Events.register(moduleEvents, event);


    };

    nameGenerator.nodeAdded = function(e) {
        nameGenerator.addCard(e.originalEvent.detail, function() {
            nameGenerator.updateCounter();
            nameGenerator.makeDraggable();
        });
    };

    nameGenerator.nodeEdited = function(e) {
        nameGenerator.editCard(e.originalEvent.detail, function() {
            nameGenerator.makeDraggable();
        });
    };

    nameGenerator.init = function(userOptions) {

        window.tools.extend(options, userOptions);
        // create elements
        $(options.targetEl).append('<div class="new-node-button text-center"><span class="fa fa-2x fa-plus"></span></div>');
        var alterCountBox = $('<div class="alter-count-box"></div>');
        options.targetEl.append(alterCountBox);

        var nodeContainer = $('<div class="question-container"></div><div class="node-container-bottom-bg"></div>');
        options.targetEl.append(nodeContainer);

        var title = $('<h1 class="text-center"></h1>').html(options.heading);
        $('.question-container').append(title);
        var subtitle = $('<p class="lead text-center"></p>').html(options.subheading);
        $('.question-container').append(subtitle);

        // create namelist container
        var nameList = $('<div class="node-container nameList"></div>');
        options.targetEl.append(nameList);

		// bin
		options.targetEl.append('<div class="delete-bin-footer"><span class="delete-bin fa fa-4x fa-trash-o"></span></div>');
		$('.delete-bin').droppable({
			accept: '.card',
			tolerance: 'touch',
			hoverClass: 'delete',
			over: function( event, ui ) {
                console.log('over');
				$(this).addClass('delete');
				$(ui.draggable).addClass('delete');
			},
			out: function( event, ui ) {
				$(this).removeClass('delete');
				$(ui.draggable).removeClass('delete');
			},
			drop: function( event, ui ) {
                console.log(ui.draggable);
				nameGenerator.removeNode($(ui.draggable).data('index'));
			}
		});


        // Set node count box
        var el = document.querySelector('.alter-count-box');

        alterCounter = new Odometer({
          el: el,
          value: alterCount,
          format: 'dd',
          theme: 'default'
        });

        nameGenerator.addExistingData();
        nameGenerator.handlePanels();
        nameGenerator.bindEvents();
    };

    nameGenerator.addExistingData = function () {
        // add existing nodes

        var properties = {};
        // build properties array from dataOrigin
        $.each(options.dataOrigin.variables, function(variableIndex, variableValue){
            properties[variableValue.label] = variableValue.value;
        });

        var nodes = options.network.getNodes(properties, function (results) {
            var filteredResults = [];
            $.each(results, function(index,value) {
                if (value.type !== 'Ego') {
                    filteredResults.push(value);
                }
            });

            return filteredResults;
        });

        $.each(nodes, function(index,value) {
            nameGenerator.addCard(value);
        });

        nameGenerator.updateCounter();
        nameGenerator.makeDraggable();

    };

    nameGenerator.updateCounter = function(number) {
        if (!number) {
            alterCounter.update(options.network.getNodes().length-1);
        } else {
            alterCounter.update(number);
        }
    };

    nameGenerator.makeDraggable = function() {
        $('.card').draggable({
            appendTo: 'body',
            helper: 'clone',
            revert: true,
            revertDuration: 200,
            refreshPositions: true,
            scroll: false,
            start: function(event, ui) {
                console.log(ui);
                $(this).addClass('invisible');
                $(ui.helper).addClass('dragging');
                nameGenerator.showBin();
            },
            stop: function(event, ui) {
                $(this).removeClass('invisible');
                $(ui.helper).removeClass('dragging');
                nameGenerator.hideBin();
            }
        });

    };

    nameGenerator.showNewNodeForm = function() {

        // add fields from dataTarget
        var properties = {};
        $.each(options.dataTarget.variables, function(targetIndex, targetValue) {
            properties[targetValue.label] = {
                type:'hidden',
                title: targetValue.label
            };
        });
        window.forms.nameGenForm.addTemporaryFields(properties);

        // Add data from fields
        properties = {};
        $.each(options.dataTarget.variables, function(targetIndex, targetValue) {
            properties[targetValue.label] = targetValue.value;
        });
        window.forms.nameGenForm.addData(properties);


        window.forms.nameGenForm.show();
    };

    nameGenerator.handlePanels = function() {
        note.debug('nameGenerator.handlePanels()');
        if (options.panels && typeof options.panels === 'object' && options.panels.length > 0) {

            // Side container
            var sideContainer = $('<div class="side-container"></div>');

            // Current side panel shows alters already elicited
            if (options.panels.indexOf('current') !== -1) {

                // add custom node list
                sideContainer.append($('<div class="current-panel"><h4>People you already named:</h4><div class="current-node-list node-lists"></div></div>'));
            }

            if (sideContainer.children().length > 0) {
                // move node list to one side
                sideContainer.insertBefore('.nameList');
                $('.nameList').addClass('alt');
            }

            nameGenerator.updateSidePanel();

            // halve the panel height if we have two
            if ($('.side-container').children().length > 1) {
                $('.node-lists').addClass('double');
            }

        } // end if panels
    };

    nameGenerator.showBin = function() {
        $('.delete-bin-footer').addClass('show');
    };

    nameGenerator.hideBin = function() {
        $('.delete-bin-footer').removeClass('show');
    };

    nameGenerator.addCard = function(properties, callback) {

        var card;

        card = $('<div class="card" data-index="'+properties.id+'"><div class="inner-card shown"><h4>'+properties.label+'</h4></div></div>');
        var list = $('<ul></ul>');
        list.append('<li>'+properties.first_name+' '+properties.last_name+'</li>');
        card.children('.inner-card').append(list);
        $('.nameList').append(card);

        if (callback) {
            callback();
        }

        return true;
    };

    nameGenerator.editCard = function(properties, callback) {

        var card;
        $('.card[data-index='+properties.id+']').children('inner-card').find('h4').html(properties.label);

        var list = $('<ul></ul>');
        list.append('<li>'+properties.first_name+' '+properties.last_name+'</li>');
        card.children('.inner-card').append(list);
        $('.nameList').append(card);

        if (callback) {
            callback();
        }

        return true;
    };

    nameGenerator.removeNode = function(id) {
        if (!id) {
            note.error('No id provided to nameGenerator.deleteNode().');
            return false;
        }

        if (options.network.removeNode(id)) {
            if(nameGenerator.removeCard(id)) {
                note.info('Deleted node with id '+id);
                return true;
            } else {
                note.error('nameGenerator.removeNode() tried to remove node with ID '+id+', but failed.');
                return false;
            }

        } else {
            note.warn('nameGenerator.removeNode() tried to remove node with ID '+id+', but failed.');
            return false;
        }
    };

    nameGenerator.removeCard = function(id) {

        $('div[data-index='+id+']').remove();
        nameGenerator.updateCounter();

        return true;
    };

    return nameGenerator;
};
;/* global $, window, Odometer, document, note, Swiper  */
/* exported Namegenerator */
module.exports = function NameGeneratorMulti() {
    'use strict';
    //global vars
    var nameGeneratorMulti = {};
    var options = {
        targetEl: $('.container'),
    	panels: ['current'],
    	network: window.network,
    	form: window.forms.newNodeForm,
    	data: {
    		origin: 'node', // edge or node.
    		namegenerators: [
    			{
    				prompt: 'Name generator prompt',
    				label: 'name generator label',
    				variables: [
    					{label: 'extra-variable', value: 'true', type: 'select'}
    				]
    			}
    		]
    	}
    };

    var promptSwiper;
    var currentPrompt = 0;
    var alterCounter;
    var moduleEvents = [];

    var namesList = ['Joshua', 'Bernie', 'Michelle', 'Gregory', 'Patrick', 'Barney', 'Jonathon','Myles','Alethia','Tammera','Veola','Meredith','Renee','Grisel','Celestina','Fausto','Eliana','Raymundo','Lyle','Carry','Kittie','Melonie','Elke','Mattie','Kieth','Lourie','Marcie','Trinity','Librada','Lloyd','Pearlie','Velvet','Stephan','Hildegard','Winfred','Tempie','Maybelle','Melynda','Tiera','Lisbeth','Kiera','Gaye','Edra','Karissa','Manda','Ethelene','Michelle','Pamella','Jospeh','Tonette','Maren','Aundrea','Madelene','Epifania','Olive'];

    var cardClickHandler = function() {
        // Handles what happens when a card is clicked

        // Get the ID of the node corresponding to this card, stored in the data-index property.
        var index = $(this).data('index');

        var node = options.network.getNode(index);

        // add fields from data
        var properties = {};
        properties.id = {
            type:'hidden',
            title: 'id'
        };
        $.each(options.data.namegenerators, function(targetIndex, targetValue) {
            properties[targetValue.label] = {
                type:'hidden',
                title: targetValue.label
            };
        });
        window.forms.nameGenForm.addTemporaryFields(properties);

        window.forms.nameGenForm.addData(node);
        window.forms.nameGenForm.show();


    };

    nameGeneratorMulti.generateTestAlters = function(number) {

        if (!number) {
            note.error('You must specify the number of test alters you want to create. Cancelling!');
            return false;
        }

        var eachTime = 1500;

        for (var i = 0; i < number; i++) {
            var timer = eachTime*i;
            setTimeout(nameGeneratorMulti.generateAlter, timer);
        }

    };

    nameGeneratorMulti.generateAlter = function() {
        // We must simulate every interaction to ensure that any errors are caught.
        $('.new-node-button').click();
        setTimeout(function() {
            $('#new-node-submit-btn').click();
        }, 500);

        $('#first_name').val(namesList[Math.floor(window.tools.randomBetween(0,namesList.length))]);
        $('#last_name').val(namesList[Math.floor(window.tools.randomBetween(0,namesList.length))]);

        $('#label').val($('#first_name').val());
    };

    nameGeneratorMulti.destroy = function() {
        note.debug('Destroying nameGeneratorMulti.');

        // Event listeners
        promptSwiper.destroy();
        window.tools.Events.unbind(moduleEvents);

    };

    nameGeneratorMulti.bindEvents = function() {
        // Event listeners
        // Events
		var event = [{
			event: 'changeStageStart',
			handler: nameGeneratorMulti.destroy,
			targetEl:  window
		},
		{
			event: 'nodeAdded',
			handler: nameGeneratorMulti.nodeAdded,
			targetEl:  window
		},
        {
            event: 'nodeUpdate',
            handler: nameGeneratorMulti.nodeEdited,
            targetEl:  window
        },
        {
            event: 'click',
            handler: nameGeneratorMulti.toggleSelectable,
            targetEl: window.document,
            subTarget:  '.node-list-item'
        },
        {
            event: 'click',
            handler: nameGeneratorMulti.showNewNodeForm,
            targetEl:  '.new-node-button'
        }];
		window.tools.Events.register(moduleEvents, event);


    };

    nameGeneratorMulti.nodeAdded = function(e) {
        nameGeneratorMulti.addCard(e.originalEvent.detail, function() {
            nameGeneratorMulti.updateCounter();
            nameGeneratorMulti.makeDraggable();
        });
    };

    nameGeneratorMulti.nodeEdited = function(e) {
        nameGeneratorMulti.editCard(e.originalEvent.detail, function() {
            nameGeneratorMulti.makeDraggable();
        });
    };

    nameGeneratorMulti.init = function(userOptions) {
        note.info('nameGeneratorMulti initialising.');
        window.tools.extend(options, userOptions);

        var alterCount = nameGeneratorMulti.getNodes().length;

        // create elements
        $(options.targetEl).append('<div class="new-node-button text-center"><span class="fa fa-2x fa-plus"></span></div>');
        var alterCountBox = $('<div class="alter-count-box"></div>');
        options.targetEl.append(alterCountBox);

        var nodeContainer = $('<div class="question-container"></div><div class="node-container-bottom-bg"></div>');
        options.targetEl.append(nodeContainer);


        // Prompts
        $('.question-container').append('<div class="swiper-container"><div class="swiper-wrapper"></div><div class="swiper-pagination"></div></div>');
        for (var i = 0; i < options.data.namegenerators.length; i++) {
            $('.swiper-wrapper').append('<div class="swiper-slide"><h2>'+options.data.namegenerators[i].prompt+'</h2></div>');
        }
        promptSwiper = new Swiper ('.swiper-container', {
            pagination: '.swiper-pagination',
            speed: 1000
        });

        // Update current prompt counter
        promptSwiper.on('slideChangeStart', function () {
            currentPrompt = promptSwiper.activeIndex;
            nameGeneratorMulti.handlePanels();
            nameGeneratorMulti.changeData();
        });

        // create namelist container
        var nameList = $('<div class="node-container nameList"></div>');
        options.targetEl.append(nameList);

		// bin
		options.targetEl.append('<div class="delete-bin-footer"><span class="delete-bin fa fa-4x fa-trash-o"></span></div>');
		$('.delete-bin').droppable({
			accept: '.card, .node-list-item',
			tolerance: 'touch',
			hoverClass: 'delete',
			over: function( event, ui ) {
				$(this).addClass('delete');
				$(ui.draggable).addClass('delete');
			},
			out: function( event, ui ) {
				$(this).removeClass('delete');
				$(ui.draggable).removeClass('delete');
			},
			drop: function( event, ui ) {
				nameGeneratorMulti.removeNode($(ui.draggable).data('index'));
			}
		});


        // Set node count box
        var el = document.querySelector('.alter-count-box');

        alterCounter = new Odometer({
          el: el,
          value: alterCount,
          format: 'dd',
          theme: 'default'
        });

        nameGeneratorMulti.handlePanels();
        nameGeneratorMulti.addData();
        nameGeneratorMulti.bindEvents();
    };

    nameGeneratorMulti.changeData = function() {
            $('.inner-card, .node-list-item').removeClass('shown');
            setTimeout(function() {
                $('.card, .node-list-item').remove();
                nameGeneratorMulti.addData();
            }, 1000);
    };

    nameGeneratorMulti.getNodes = function(criteria) {
        console.log('getnodes');
        console.log(criteria);
        var filterCriteria = criteria || {};
        // ignore ego and any nodes that are visible in the main node list
        var nodes = options.network.getNodes(filterCriteria, function (results) {
            var filteredResults = [];
            $.each(results, function(index,value) {
                if (value.type !== 'Ego') {
                    filteredResults.push(value);
                }
            });

            return filteredResults;
        });

        return nodes;
    };

    nameGeneratorMulti.toggleSelectable = function() {
        var clicked = this;
        var properties = {};

        // get the togglePabelVariable for the current name generator
        if (options.data.namegenerators[currentPrompt].togglePanelVariable !== 'undefined') {
            $.each(options.data.namegenerators[currentPrompt].variables, function(variableIndex, variableValue) {
                if (variableValue.label === options.data.namegenerators[currentPrompt].togglePanelVariable) {
                    if ($(clicked).hasClass('selected')) {
                        properties[options.data.namegenerators[currentPrompt].togglePanelVariable] = '';
                    } else {
                        properties[options.data.namegenerators[currentPrompt].togglePanelVariable] = variableValue.value;
                    }
                }
            });

            options.network.updateNode($(clicked).data('index'), properties, function() {
                $(clicked).toggleClass('selected');
            });
        }

    };

    nameGeneratorMulti.updateSidePanel = function() {
        console.log('updatesidepanel');

        // Empty it
        $('.current-node-list').children().remove();

        // ignore ego and any nodes that are visible in the main node list
        var nodes = nameGeneratorMulti.getNodes();

        var filteredResults = [];
        $.each(nodes, function(index,value) {
            if (value.namegenerator !== options.data.namegenerators[currentPrompt].label) {
                filteredResults.push(value);
            }
        });

        $.each(filteredResults, function(index,value) {
            var selected = '';

            if (value[options.data.namegenerators[currentPrompt].togglePanelVariable] === 'true') {
                selected = 'selected';
            }

            var el = $('<div class="node-list-item '+selected+'" data-index="'+value.id+'">'+value.label+'</div>');
            $('.current-node-list').append(el);

            setTimeout(function() {
                $(el).addClass('shown');
                nameGeneratorMulti.makeDraggable();
            },50+(index*50));

        });

    };

    nameGeneratorMulti.addData = function () {
        console.log('add data');
        var properties = {};
        // build properties array from data
        properties.namegenerator = options.data.namegenerators[currentPrompt].label;
        console.log(properties);
        var nodes = nameGeneratorMulti.getNodes(properties);
        console.log(nodes);
        $.each(nodes, function(index,value) {
            setTimeout(function() {
                nameGeneratorMulti.addCard(value);
            }, index * 40);
        });

        nameGeneratorMulti.updateSidePanel();
        nameGeneratorMulti.updateCounter();

    };

    nameGeneratorMulti.updateCounter = function(number) {
        if (!number) {
            alterCounter.update(options.network.getNodes().length-1);
        } else {
            alterCounter.update(number);
        }
    };

    nameGeneratorMulti.makeDraggable = function() {
        $('.card').draggable({
            appendTo: 'body',
            helper: 'clone',
            revert: true,
            revertDuration: 200,
            refreshPositions: true,
            scroll: false,
            start: function(event, ui) {
                $(this).addClass('invisible');
                $(ui.helper).addClass('dragging');
                nameGeneratorMulti.showBin();
            },
            stop: function(event, ui) {
                $(this).removeClass('invisible');
                $(ui.helper).removeClass('dragging');
                nameGeneratorMulti.hideBin();
            }
        });

        $('.node-list-item').draggable({
            // appendTo: 'body',
            helper: 'clone',
            revert: true,
            revertDuration: 200,
            refreshPositions: true,
            scroll: false,
            stack: '.node-list-item',
            start: function(event, ui) {
                nameGeneratorMulti.showBin();
                $(ui.helper).addClass('dragging');
            },
            stop: function(event, ui) {
                $(ui.helper).removeClass('dragging');
                nameGeneratorMulti.hideBin();
            }
        });

    };

    nameGeneratorMulti.showNewNodeForm = function() {

        // add fields from data
        var properties = {};
            properties.namegenerator = {
                type:'hidden',
                title: 'namegenerator'
            };

        // Add additional variables, if present
        if (typeof options.data.namegenerators[currentPrompt].variables !== 'undefined' && options.data.namegenerators[currentPrompt].variables.length > 0) {
            $.each(options.data.namegenerators[currentPrompt].variables, function(variableIndex, variableValue) {

                properties[variableValue.label] = {
                    type: 'hidden',
                    title: variableValue.label
                };
            });
        }

        window.forms.nameGenForm.addTemporaryFields(properties);

        // Add data from fields
        properties = {};
        properties.namegenerator = options.data.namegenerators[currentPrompt].label;

        // Add data to additional variables, if present
        if (typeof options.data.namegenerators[currentPrompt].variables !== 'undefined' && options.data.namegenerators[currentPrompt].variables.length > 0) {

            // Is there a cute way to do the below using map?
            $.each(options.data.namegenerators[currentPrompt].variables, function(variableIndex, variableValue) {
                properties[variableValue.label] = variableValue.value;
            });
        }


        window.forms.nameGenForm.addData(properties);

        window.forms.nameGenForm.show();
    };

    nameGeneratorMulti.handlePanels = function() {
        note.debug('nameGeneratorMulti.handlePanels()');

        if (options.panels.indexOf('current') !== -1) {
            // We are trying to add a panel which shows the current nodes.

            // First, check there are some current nodes:
            // ignore ego and any nodes that are visible in the main node list
            var nodes = nameGeneratorMulti.getNodes();

            var filteredResults = [];
            $.each(nodes, function(index,value) {
                if (value.namegenerator !== options.data.namegenerators[currentPrompt].label) {
                    filteredResults.push(value);
                }
            });

            if (filteredResults.length > 0) {
                if ($('.side-container').length === 0) {
                    // Side container
                    var sideContainer = $('<div class="side-container out"></div>');

                    // Current side panel shows alters already elicited
                    sideContainer.append($('<div class="current-panel"><h4>Other people you have mentioned:</h4><div class="current-node-list node-lists"></div><div class="current-node-list-background"></div></div>'));

                    if (sideContainer.children().length > 0) {
                        // move node list to one side
                        sideContainer.insertBefore('.nameList');
                        setTimeout(function() {
                            $('.nameList').addClass('alt');
                            $('.side-container').removeClass('out');
                        }, 10);


                    }
                }
                // halve the panel height if we have two
                if ($('.side-container').children().length > 1) {
                    $('.node-lists').addClass('double');
                }
            } else {
                $('.side-container').addClass('out');
                setTimeout(function() {
                    $('.nameList').removeClass('alt');
                    $('.side-container').remove();
                }, 500);

            }

        }

    };

    nameGeneratorMulti.showBin = function() {
        $('.delete-bin-footer').addClass('show');
    };

    nameGeneratorMulti.hideBin = function() {
        $('.delete-bin-footer').removeClass('show');
    };

    nameGeneratorMulti.addCard = function(properties, callback) {

        var card;

        card = $('<div class="card" data-index="'+properties.id+'"><div class="inner-card"><h4>'+properties.label+'</h4></div></div>');
        var list = $('<ul></ul>');
        list.append('<li>'+properties.first_name+' '+properties.last_name+'</li>');
        card.children('.inner-card').append(list);
        $('.nameList').append(card);

        $(card).on('click', cardClickHandler);

        nameGeneratorMulti.updateCounter();
        nameGeneratorMulti.makeDraggable();

        setTimeout(function() {
            $('[data-index='+properties.id+']').children('.inner-card').addClass('shown');
        },20);


        if (callback) {
            callback();
        }

        return true;
    };

    nameGeneratorMulti.editCard = function(properties, callback) {

        var card;
        $('.card[data-index='+properties.id+']').children('inner-card').find('h4').html(properties.label);

        var list = $('<ul></ul>');
        list.append('<li>'+properties.first_name+' '+properties.last_name+'</li>');
        card.children('.inner-card').append(list);
        $('.nameList').append(card);

        if (callback) {
            callback();
        }

        return true;
    };

    nameGeneratorMulti.removeNode = function(id) {
        if (!id) {
            note.error('No id provided to nameGeneratorMulti.deleteNode().');
            return false;
        }

        if (options.network.removeNode(id)) {
            if(nameGeneratorMulti.removeCard(id)) {
                note.info('Deleted node with id '+id);
                nameGeneratorMulti.handlePanels();
                return true;
            } else {
                note.error('nameGeneratorMulti.removeNode() tried to remove node with ID '+id+', but failed.');
                return false;
            }

        } else {
            note.warn('nameGeneratorMulti.removeNode() tried to remove node with ID '+id+', but failed.');
            return false;
        }
    };

    nameGeneratorMulti.removeCard = function(id) {

        $('div[data-index='+id+']').remove();
        nameGeneratorMulti.updateCounter();

        return true;
    };

    return nameGeneratorMulti;
};
;/* exported Network, Node, Edge, document */
/* global $, window, note, deepmerge, tools */

/**
* This module should implement 'networky' methods, and a querying syntax for
* selecting nodes or edges by their various properties, and interating over them.
* @constructor
*/

module.exports = function Network() {
    'use strict';
    var nodes = [];
    var edges = [];
    var network = {};
    var namesList = ['Joshua', 'Bernie', 'Michelle', 'Gregory', 'Patrick', 'Barney', 'Jonathon','Myles','Alethia','Tammera','Veola','Meredith','Renee','Grisel','Celestina','Fausto','Eliana','Raymundo','Lyle','Carry','Kittie','Melonie','Elke','Mattie','Kieth','Lourie','Marcie','Trinity','Librada','Lloyd','Pearlie','Velvet','Stephan','Hildegard','Winfred','Tempie','Maybelle','Melynda','Tiera','Lisbeth','Kiera','Gaye','Edra','Karissa','Manda','Ethelene','Michelle','Pamella','Jospeh','Tonette','Maren','Aundrea','Madelene','Epifania','Olive'];

    /**
    * @public
    * @name Network#addNode
    * @function
    * @param {object} properties An object containing the desired node properties.
    * @param {boolean} [ego=false] Whether or not the node being added is an Ego.
    * @param {boolean} [force=false] Override reserved IDs.
    */
    network.addNode = function(properties, ego, force) {

        var reserved_ids;

        if (!force) { force = false; }

        // Check if we are adding an ego
        if (!ego) { ego = false;}

        // if we are adding an ego create an empty reserved_ids array for later, if not use Ego's.
        if (ego) {
            // fetch in use IDs from Ego
            reserved_ids = [];
        } else {
            // We aren't adding an Ego, so make sure an Ego exists
            if (network.egoExists()) {
                reserved_ids = network.getEgo().reserved_ids;
            } else {
                throw new Error('You must add an Ego before attempting to add other nodes.');
            }

        }


        // Check if an ID has been passed, and then check if the ID is already in use. Cancel if it is.
        if (typeof properties.id !== 'undefined' && this.getNode(properties.id) !== false) {
            note.error('Node already exists with id '+properties.id+'. Cancelling!');
            return false;
        }

        // To prevent confusion in longitudinal studies, once an ID has been allocated, it is always reserved.
        // This reserved list is stored with the ego.
        if (!force) {
            if (reserved_ids.indexOf(properties.id) !== -1) {
                note.error('Node id '+properties.id+' is already in use with this ego. Cancelling!');
                return false;
            }
        }

        // Locate the next free node ID
        // should this be wrapped in a conditional to check if properties.id has been provided? probably.
        var newNodeID = 0;
        while (network.getNode(newNodeID) !== false || reserved_ids.indexOf(newNodeID) !== -1) {
            newNodeID++;
        }
        var nodeProperties = {
            id: newNodeID
        };
        window.tools.extend(nodeProperties, properties);

        nodes.push(nodeProperties);
        reserved_ids.push(newNodeID);

        var log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeCreate', 'eventObject':nodeProperties}});
        window.dispatchEvent(log);
        var nodeAddedEvent = new window.CustomEvent('nodeAdded',{'detail':nodeProperties});
        window.dispatchEvent(nodeAddedEvent);
        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);

        return nodeProperties.id;
    };

    network.loadNetwork = function(data, overwrite) {
        if (!data || !data.nodes || !data.edges) {
            note.error('Error loading network. Data format incorrect.');
            return false;
        } else {
            if (!overwrite) {
                overwrite = false;
            }

            if (overwrite) {
                nodes = data.nodes;
                network.dges = data.edges;
            } else {
                nodes = nodes.concat(data.nodes);
                edges = edges.concat(data.edges);
            }

            return true;
        }
    };

    network.resetNetwork = function() {
        nodes = [];
        edges = [];
    };

    network.createEgo = function(properties) {
        if (network.egoExists() === false) {
            var egoProperties = {
                id:0,
                type: 'Ego',
                reserved_ids: [0]
            };
            window.tools.extend(egoProperties, properties);
            network.addNode(egoProperties, true);
        } else {
            throw new Error('Ego already exists.');
        }
    };

    network.getEgo = function() {
        note.debug('network.getEgo() called.');
        if (network.getNodes({type:'Ego'}).length !== 0) {
            return network.getNodes({type:'Ego'})[0];
        } else {
            return false;
        }
    };

    network.egoExists = function() {
        if (network.getEgo() !== false) {
            return true;
        } else {
            return false;
        }
    };

    network.edgeExists = function(edge) {
        note.debug('network.edgeExists() called.');
        note.debug(edge);
        if (typeof edge === 'undefined') {
            note.error('ERROR: No edge passed to network.edgeExists().');
            return false;
        }
        // old way of checking if an edge existed checked for values of to, from, and type. We needed those to not have to be unique.
        // New way: check if all properties are the same.

        var reversed = {}, temp;
        reversed = $.extend(true,{}, edge); // Creates a copy not a reference
        temp = reversed.to; // Switch the order (do the reversing)
        reversed.to = reversed.from;
        reversed.from = temp;

        var straightExists = (network.getEdges(edge).length > 0) ? true : false;
        var reverseExists = (network.getEdges(reversed).length > 0) ? true : false;

        if (straightExists === true || reverseExists === true) { // Test if an edge matches either the proposed edge or the reversed edge.
            note.debug('network.edgeExists() true.');
            return true;
        } else {
            note.debug('network.edgeExists() false.');
            return false;
        }
    };

    network.addEdge = function(properties) {
        note.debug('network.addEdge() called.');
        // todo: make nickname unique, and provide callback so that interface can respond if a non-unique nname is used.

        if (typeof properties.from === 'undefined' || typeof properties.to === 'undefined') {
            note.error('Error while executing network.addEdge(). "To" and "From" must BOTH be defined.');
            return false;
        }
        // Required variables (id and type) generated here. These are overwritten as long as the values have been provided.
        var edgeProperties = {
            type: 'Default'
        };

        window.tools.extend(edgeProperties, properties);

        if(network.edgeExists(edgeProperties) === false) {

            if (edgeProperties.id === 'undefined' || network.getEdge(edgeProperties.id) !== false) {
                note.warn('Either you didn\'t provide an ID, or an edge with this id already exists! I\'m generating a new one for you.');

                var newEdgeID = 0;
                while (network.getEdge(newEdgeID) !== false) {
                    newEdgeID++;
                }

                edgeProperties.id = newEdgeID;
            }

            edges.push(edgeProperties);
            var log = new window.CustomEvent('log', {'detail':{'eventType': 'edgeCreate', 'eventObject':edgeProperties}});
            window.dispatchEvent(log);
            var edgeAddedEvent = new window.CustomEvent('edgeAdded',{'detail':edgeProperties});
            window.dispatchEvent(edgeAddedEvent);
            var unsavedChanges = new window.Event('unsavedChanges');
            window.dispatchEvent(unsavedChanges);

            return edgeProperties.id;
        } else {
            return false;
        }

    };

    network.removeEdges = function(edges) {
        note.debug('network.removeEdges() called.');
        network.removeEdge(edges);
    };

    network.removeEdge = function(edge) {
        var counter = 0;
        note.debug('network.removeEdge() called.');

        if (!edge) {
            note.error('network.removeEdge(): No edge specified!');
            return false;
        }
        var log;
        var edgeRemovedEvent;

        if (typeof edge === 'object' && typeof edge.length !== 'undefined') {
            // we've got an array of object edges
            for (var i = 0; i < edge.length; i++) {
                // localEdges.remove(edge[i]);
                counter = window.tools.removeFromObject(edge[i], edges);
                log = new window.CustomEvent('log', {'detail':{'eventType': 'edgeRemove', 'eventObject':edge[i]}});
                edgeRemovedEvent = new window.CustomEvent('edgeRemoved',{'detail':edge[i]});
                window.dispatchEvent(log);
                window.dispatchEvent(edgeRemovedEvent);
            }
        } else {
            // we've got a single edge, which is an object {}
            counter = window.tools.removeFromObject(edge, edges);

            log = new window.CustomEvent('log', {'detail':{'eventType': 'edgeRemove', 'eventObject':edge}});
            edgeRemovedEvent = new window.CustomEvent('edgeRemoved',{'detail':edge});
            window.dispatchEvent(log);
            window.dispatchEvent(edgeRemovedEvent);
        }

        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);
        if (counter > 0) {
            return true;
        } else {
            return false;
        }
    };

    network.removeNode = function(id, preserveEdges) {
        note.debug('network.removeNode() called.');

        if (!preserveEdges) { preserveEdges = false; }

        // Unless second parameter is present, also delete this nodes edges
        if (!preserveEdges) {
            network.removeEdge(network.getNodeEdges(id));
        } else {
            note.info('NOTICE: preserving node edges after deletion.');
        }

        var nodeRemovedEvent, log;

        for (var i = 0; i<nodes.length; i++) {
            if (nodes[i].id === id) {
                log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeRemove', 'eventObject':nodes[i]}});
                window.dispatchEvent(log);
                nodeRemovedEvent = new window.CustomEvent('nodeRemoved',{'detail':nodes[i]});
                window.dispatchEvent(nodeRemovedEvent);
                window.tools.removeFromObject(nodes[i],nodes);
                return true;
            }
        }
        return false;
    };

    network.updateEdge = function(id, properties, callback) {
        note.debug('network.updateEdge() called.');
        if(network.getEdge(id) === false || properties === undefined) {
            return false;
        }
        var edge = network.getEdge(id);
        var edgeUpdateEvent, log;

        $.extend(edge, properties);
        edgeUpdateEvent = new window.CustomEvent('edgeUpdatedEvent',{'detail':edge});
        window.dispatchEvent(edgeUpdateEvent);
        log = new window.CustomEvent('log', {'detail':{'eventType': 'edgeUpdate', 'eventObject':edge}});
        window.dispatchEvent(log);
        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);
        if(callback) {
            callback();
        }

    };

    network.updateNode = function(id, properties, callback) {
        note.info('network.updateNode() called for node id '+id+'.');
        console.log(typeof id);
        note.debug(properties);

        if(this.getNode(id) === false || properties === undefined) {
            note.error('network.updateNode() couldn\'t find node with id '+id);
            return false;
        }
        var node = this.getNode(id);
        var nodeUpdateEvent, log;

        $.extend(node, properties);
        console.log('node:');
        console.log(node);
        nodeUpdateEvent = new window.CustomEvent('nodeUpdatedEvent',{'detail':node});
        window.dispatchEvent(nodeUpdateEvent);
        log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeUpdate', 'eventObject':node}});
        window.dispatchEvent(log);
        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);
        if(callback) {
            callback();
        }

    };

    network.deepUpdateNode = function(id, properties, callback) {
        if(this.getNode(id) === false || properties === undefined) {
            return false;
        }
        var node = this.getNode(id);
        var nodeUpdateEvent, log;

        node = deepmerge(node, properties);
        nodeUpdateEvent = new window.CustomEvent('nodeUpdatedEvent',{'detail':node});
        window.dispatchEvent(nodeUpdateEvent);
        log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeUpdate', 'eventObject':node}});
        window.dispatchEvent(log);
        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);
        if(callback) {
            callback();
        }
    };

    network.getNode = function(id) {
        // Ensure that ID is always treated as int for === comparisons to work reliably.
        id = parseInt(id);

        if (id === undefined) { return false; }
        for (var i = 0;i<nodes.length; i++) {
            if (nodes[i].id === id) {return nodes[i]; }
        }
        return false;

    };

    network.getEdge = function(id) {
        if (id === undefined) { return false; }
        for (var i = 0;i<edges.length; i++) {
            if (edges[i].id === id) {return edges[i]; }
        }
        return false;
    };

    network.filterObject = function(targetArray,criteria) {
        // Return false if no criteria provided
        if (!criteria) { return false; }
        // Get nodes using .filter(). Function is called for each of nodes.Nodes.
        var result = targetArray.filter(function(el){
            var match = true;

            for (var criteriaKey in criteria) {

                if (el[criteriaKey] !== undefined) {

                    // current criteria exists in object.
                    if (el[criteriaKey] !== criteria[criteriaKey]) {
                        match = false;
                    }
                } else {
                    match = false;
                }
            }

            if (match === true) {
                return el;
            }

        });

        // reverse to and from to check for those matches.
        if (typeof criteria.from !== 'undefined' && typeof criteria.to !== 'undefined') {

            var reversed = {}, temp;
            reversed = $.extend(true,{}, criteria);
            temp = reversed.to;
            reversed.to = reversed.from;
            reversed.from = temp;

            var result2 = targetArray.filter(function(el){
                var match = true;

                for (var criteriaKey in reversed) {

                    if (el[criteriaKey] !== undefined) {


                        // current criteria exists in object.
                        if (el[criteriaKey] !== reversed[criteriaKey]) {
                            match = false;
                        }
                    } else {
                        match = false;
                    }
                }

                if (match === true) {
                    return el;
                }

            });

            result = result.concat(result2);
        }


        return result;
    };

    network.getNodes = function(criteria, filter) {
        var results;
        if (typeof criteria !== 'undefined' && Object.keys(criteria).length !== 0) {
            results = network.filterObject(nodes,criteria);
        } else {
            results = nodes;
        }

        if (filter) {
            results = filter(results);
        }

        return results;
    };

    network.getEdges = function(criteria, filter) {
        var results;
        if (typeof criteria !== 'undefined' && Object.keys(criteria).length !== 0) {
            results = network.filterObject(edges,criteria);
        } else {
            results = edges;
        }

        if (filter) {
            results = filter(results);
        }

        return results;
    };

    network.getNodeInboundEdges = function(nodeID) {
        return network.getEdges({to:nodeID});
    };

    network.getNodeOutboundEdges = function(nodeID) {
        return network.getEdges({from:nodeID});
    };

    network.getNodeEdges = function(nodeID) {
        if (network.getNode(nodeID) === false) {
            return false;
        }
        var inbound = network.getNodeInboundEdges(nodeID);
        var outbound = network.getNodeOutboundEdges(nodeID);
        var concat = inbound.concat(outbound);
        return concat;
    };

    network.setProperties = function(object, properties) {

        if (typeof object === 'undefined') { return false; }

        if (typeof object === 'object' && object.length>0) {
            // Multiple objects!
            for (var i = 0; i < object.length; i++) {
                $.extend(object[i], properties);
            }
        } else {
            // Just one object.
            $.extend(object, properties);
        }

    };

    network.returnAllNodes = function() {
        return nodes;
    };

    network.returnAllEdges = function() {
        return edges;
    };

    network.clearGraph = function() {
        edges = [];
        nodes = [];
    };

    network.createRandomGraph = function(nodeCount,edgeProbability) {
        nodeCount = nodeCount || 10;

        edgeProbability = edgeProbability || 0.4;
        note.info('Creating random graph...');

        for (var i=0;i<nodeCount;i++) {
            var current = i+1;
            window.tools.notify('Adding node '+current+' of '+nodeCount,2);
            // Use random coordinates
            var nodeOptions = {
                name: namesList[Math.floor(window.tools.randomBetween(0,namesList.length))],
                coords: [Math.round(window.tools.randomBetween(100,window.innerWidth-100)),Math.round(window.tools.randomBetween(100,window.innerHeight-100))]
            };
            network.addNode(nodeOptions);
        }

        note.debug('Adding edges.');
        $.each(nodes, function (index) {
            if (window.tools.randomBetween(0, 1) < edgeProbability) {
                var randomFriend = Math.round(window.tools.randomBetween(0,nodes.length-1));
                network.addEdge({from:nodes[index].id,to:nodes[randomFriend].id});

            }
        });
    };

    return network;

};
;/* global $, window */
/* exported OrdinalBin */
module.exports = function OrdinalBin() {
    'use strict';
    //global vars
    var ordinalBin = {};
    var taskComprehended = false;
    var log;
    ordinalBin.options = {
        targetEl: $('.container'),
        edgeType: 'Dyad',
        criteria: {},
        variable: {
            label:'gender_p_t0',
            values: [
                'Female',
                'Male',
                'Transgender',
                'Don\'t Know',
                'Won\'t Answer'
            ]
        },
        heading: 'Default Heading',
        subheading: 'Default Subheading.'
    };
    var followup;

    var stageChangeHandler = function() {
        ordinalBin.destroy();
    };

    var followupHandler = function() {
        var followupVal = $(this).data('value');
        var nodeid = followup;
        var criteria = {
            to:nodeid
        };

        window.tools.extend(criteria, ordinalBin.options.criteria);
        var edge = window.network.getEdges(criteria)[0];

        var followupProperties = {};

        followupProperties[ordinalBin.options.followup.variable] = followupVal;

        window.tools.extend(edge, followupProperties);
        window.network.updateEdge(edge.id, edge);
        $('.followup').hide();
    };

    ordinalBin.destroy = function() {
        // Event Listeners
        window.tools.notify('Destroying ordinalBin.',0);
        window.removeEventListener('changeStageStart', stageChangeHandler, false);
        $(window.document).off('click', '.followup-option', followupHandler);

    };

    ordinalBin.init = function(options) {

        window.tools.extend(ordinalBin.options, options);

        ordinalBin.options.targetEl.append('<div class="node-question-container"></div>');

        // Add header and subheader
        $('.node-question-container').append('<h1>'+ordinalBin.options.heading+'</h1>');
        $('.node-question-container').append('<p class="lead">'+ordinalBin.options.subheading+'</p>');

        // Add node bucket
        $('.node-question-container').append('<div class="node-bucket"></div>');
        if(typeof ordinalBin.options.followup !== 'undefined') {
            $('.node-question-container').append('<div class="followup"><h2>'+ordinalBin.options.followup.prompt+'</h2></div>');
            $.each(ordinalBin.options.followup.values, function(index,value) {
                $('.followup').append('<span class="btn btn-primary btn-block followup-option" data-value="'+value.value+'">'+value.label+'</span>');
            });
        }

        // bin container
        ordinalBin.options.targetEl.append('<div class="ord-bin-container"></div>');

        // Calculate number of bins required
        var binNumber = ordinalBin.options.variable.values.length;

        // One of these for each bin. One bin for each variable value.
        $.each(ordinalBin.options.variable.values, function(index, value){

            var newBin = $('<div class="ord-node-bin size-'+binNumber+' d'+index+'" data-index="'+index+'"><h1>'+value.label+'</h1><div class="ord-active-node-list"></div></div>');
            newBin.data('index', index);
            $('.ord-bin-container').append(newBin);
            $('.d'+index).droppable({ accept: '.draggable',
                drop: function(event, ui) {
                    console.log('dropped');
                    var dropped = ui.draggable;
                    var droppedOn = $(this);

                    if (ordinalBin.options.variable.values[index].value>0) {
                        $('.followup').show();
                        followup = $(dropped).data('node-id');
                    }
                    console.log(droppedOn.children('.ord-active-node-list'));
                    console.log(dropped);
                    dropped.css({position:'inherit'});
                    droppedOn.children('.ord-active-node-list').append(dropped);

                    $(dropped).appendTo(droppedOn.children('.ord-active-node-list'));
                    var properties = {};
                    properties[ordinalBin.options.variable.label] = ordinalBin.options.variable.values[index].value;
                    // Followup question

                    // Add the attribute
                    var edgeID = window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id,to:$(dropped).data('node-id'), type:ordinalBin.options.edgeType})[0].id;
                    window.network.updateEdge(edgeID,properties);

                    $.each($('.ord-node-bin'), function(oindex) {
                        var length = $('.d'+oindex).children('.ord-active-node-list').children().length;
                        if (length > 0) {
                            var noun = 'people';
                            if (length === 1) {
                                noun = 'person';
                            }

                            $('.d'+oindex+' p').html(length+' '+noun+'.');
                        } else {
                            $('.d'+oindex+' p').html('(Empty)');
                        }

                    });

                    var el = $('.d'+index);

                    setTimeout(function(){
                        el.transition({background:el.data('oldBg')}, 200, 'ease');
                        // el.transition({ scale:1}, 200, 'ease');
                    }, 0);

                    $('.draggable').draggable({ cursor: 'pointer', revert: 'invalid',
                        start: function() {
                            console.log($(this).css('top'));
                            if ($(this).css('top') !== 'auto' && $(this).css('top') !== '0px') {
                                console.log('has class');
                                $(this).css({position:'absolute'});
                            } else {
                                console.log('not');
                                $(this).css({position:'relative'});
                            }
                            if (taskComprehended === false) {
                                var eventProperties = {
                                    stage: window.netCanvas.Modules.session.currentStage(),
                                    timestamp: new Date()
                                };
                                log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
                                window.dispatchEvent(log);
                                taskComprehended = true;
                            }

                            // $('.ord-node-bin').css({overflow:'hidden'});
                        },
                        stop: function() {
                            $(this).css({position:'inerit'});
                            // $('.ord-node-bin').css({overflow:'scroll'});
                        }
                    });
                },
                over: function() {
                    $(this).data('oldBg', $(this).css('background-color'));
                    $(this).stop().transition({background:'rgba(255, 193, 0, 1.0)'}, 400, 'ease');

                },
                out: function() {
                    $(this).stop().transition({background:$(this).data('oldBg')}, 500, 'ease');
                }
            });

        });

        // get all edges
        var edges = window.network.getEdges(ordinalBin.options.criteria);

        // Add edges to bucket or to bins if they already have variable value.
        $.each(edges, function(index,value) {
            var dyadEdge;
            if (ordinalBin.options.criteria.type !== 'Dyad') {
                dyadEdge = window.network.getEdges({from: value.from, to:value.to, type:'Dyad'})[0];
            }

            if (value[ordinalBin.options.variable.label] !== undefined && value[ordinalBin.options.variable.label] !== '') {
                index = 'error';
                $.each(ordinalBin.options.variable.values, function(vindex, vvalue) {
                    if (value[ordinalBin.options.variable.label] === vvalue.value) {
                        index = vindex;
                    }
                });

                if (ordinalBin.options.criteria.type !== 'Dyad') {
                    $('.d'+index).children('.ord-active-node-list').append('<div class="node-bucket-item draggable" data-node-id="'+value.to+'">'+dyadEdge.nname_t0+'</div>');
                } else {
                    $('.d'+index).children('.ord-active-node-list').append('<div class="node-bucket-item draggable" data-node-id="'+value.to+'">'+value.nname_t0+'</div>');
                }
            } else {
                if (ordinalBin.options.criteria.type !== 'Dyad') {
                    $('.node-bucket').append('<div class="node-bucket-item draggable" data-node-id="'+value.to+'">'+dyadEdge.nname_t0+'</div>');
                } else {
                    $('.node-bucket').append('<div class="node-bucket-item draggable" data-node-id="'+value.to+'">'+value.nname_t0+'</div>');
                }

            }

        });
        $('.draggable').draggable({ cursor: 'pointer', revert: 'invalid',
            start: function() {
                $(this).css({position:'relative'});

                if (taskComprehended === false) {
                    var eventProperties = {
                        stage: window.netCanvas.Modules.session.currentStage(),
                        timestamp: new Date()
                    };
                    log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
                    window.dispatchEvent(log);
                    taskComprehended = true;
                }

                // $('.ord-node-bin').css({overflow:'hidden'});
            },
            stop: function() {
                $(this).css({position:'inerit'});
                // $('.ord-node-bin').css({overflow:'scroll'});
            }
        });

        // Event Listeners
        window.addEventListener('changeStageStart', stageChangeHandler, false);
        $(window.document).on('click', '.followup-option', followupHandler);
    };

return ordinalBin;

};
;/*
 RequireJS 2.1.18 Copyright (c) 2010-2015, The Dojo Foundation All Rights Reserved.
 Available via the MIT or new BSD license.
 see: http://github.com/jrburke/requirejs for details
*/
var requirejs,require,define;
(function(ba){function G(b){return"[object Function]"===K.call(b)}function H(b){return"[object Array]"===K.call(b)}function v(b,c){if(b){var d;for(d=0;d<b.length&&(!b[d]||!c(b[d],d,b));d+=1);}}function T(b,c){if(b){var d;for(d=b.length-1;-1<d&&(!b[d]||!c(b[d],d,b));d-=1);}}function t(b,c){return fa.call(b,c)}function m(b,c){return t(b,c)&&b[c]}function B(b,c){for(var d in b)if(t(b,d)&&c(b[d],d))break}function U(b,c,d,e){c&&B(c,function(c,g){if(d||!t(b,g))e&&"object"===typeof c&&c&&!H(c)&&!G(c)&&!(c instanceof
RegExp)?(b[g]||(b[g]={}),U(b[g],c,d,e)):b[g]=c});return b}function u(b,c){return function(){return c.apply(b,arguments)}}function ca(b){throw b;}function da(b){if(!b)return b;var c=ba;v(b.split("."),function(b){c=c[b]});return c}function C(b,c,d,e){c=Error(c+"\nhttp://requirejs.org/docs/errors.html#"+b);c.requireType=b;c.requireModules=e;d&&(c.originalError=d);return c}function ga(b){function c(a,k,b){var f,l,c,d,e,g,i,p,k=k&&k.split("/"),h=j.map,n=h&&h["*"];if(a){a=a.split("/");l=a.length-1;j.nodeIdCompat&&
Q.test(a[l])&&(a[l]=a[l].replace(Q,""));"."===a[0].charAt(0)&&k&&(l=k.slice(0,k.length-1),a=l.concat(a));l=a;for(c=0;c<l.length;c++)if(d=l[c],"."===d)l.splice(c,1),c-=1;else if(".."===d&&!(0===c||1===c&&".."===l[2]||".."===l[c-1])&&0<c)l.splice(c-1,2),c-=2;a=a.join("/")}if(b&&h&&(k||n)){l=a.split("/");c=l.length;a:for(;0<c;c-=1){e=l.slice(0,c).join("/");if(k)for(d=k.length;0<d;d-=1)if(b=m(h,k.slice(0,d).join("/")))if(b=m(b,e)){f=b;g=c;break a}!i&&(n&&m(n,e))&&(i=m(n,e),p=c)}!f&&i&&(f=i,g=p);f&&(l.splice(0,
g,f),a=l.join("/"))}return(f=m(j.pkgs,a))?f:a}function d(a){z&&v(document.getElementsByTagName("script"),function(k){if(k.getAttribute("data-requiremodule")===a&&k.getAttribute("data-requirecontext")===i.contextName)return k.parentNode.removeChild(k),!0})}function e(a){var k=m(j.paths,a);if(k&&H(k)&&1<k.length)return k.shift(),i.require.undef(a),i.makeRequire(null,{skipMap:!0})([a]),!0}function n(a){var k,c=a?a.indexOf("!"):-1;-1<c&&(k=a.substring(0,c),a=a.substring(c+1,a.length));return[k,a]}function p(a,
k,b,f){var l,d,e=null,g=k?k.name:null,j=a,p=!0,h="";a||(p=!1,a="_@r"+(K+=1));a=n(a);e=a[0];a=a[1];e&&(e=c(e,g,f),d=m(r,e));a&&(e?h=d&&d.normalize?d.normalize(a,function(a){return c(a,g,f)}):-1===a.indexOf("!")?c(a,g,f):a:(h=c(a,g,f),a=n(h),e=a[0],h=a[1],b=!0,l=i.nameToUrl(h)));b=e&&!d&&!b?"_unnormalized"+(O+=1):"";return{prefix:e,name:h,parentMap:k,unnormalized:!!b,url:l,originalName:j,isDefine:p,id:(e?e+"!"+h:h)+b}}function s(a){var k=a.id,b=m(h,k);b||(b=h[k]=new i.Module(a));return b}function q(a,
k,b){var f=a.id,c=m(h,f);if(t(r,f)&&(!c||c.defineEmitComplete))"defined"===k&&b(r[f]);else if(c=s(a),c.error&&"error"===k)b(c.error);else c.on(k,b)}function w(a,b){var c=a.requireModules,f=!1;if(b)b(a);else if(v(c,function(b){if(b=m(h,b))b.error=a,b.events.error&&(f=!0,b.emit("error",a))}),!f)g.onError(a)}function x(){R.length&&(ha.apply(A,[A.length,0].concat(R)),R=[])}function y(a){delete h[a];delete V[a]}function F(a,b,c){var f=a.map.id;a.error?a.emit("error",a.error):(b[f]=!0,v(a.depMaps,function(f,
d){var e=f.id,g=m(h,e);g&&(!a.depMatched[d]&&!c[e])&&(m(b,e)?(a.defineDep(d,r[e]),a.check()):F(g,b,c))}),c[f]=!0)}function D(){var a,b,c=(a=1E3*j.waitSeconds)&&i.startTime+a<(new Date).getTime(),f=[],l=[],g=!1,h=!0;if(!W){W=!0;B(V,function(a){var i=a.map,j=i.id;if(a.enabled&&(i.isDefine||l.push(a),!a.error))if(!a.inited&&c)e(j)?g=b=!0:(f.push(j),d(j));else if(!a.inited&&(a.fetched&&i.isDefine)&&(g=!0,!i.prefix))return h=!1});if(c&&f.length)return a=C("timeout","Load timeout for modules: "+f,null,
f),a.contextName=i.contextName,w(a);h&&v(l,function(a){F(a,{},{})});if((!c||b)&&g)if((z||ea)&&!X)X=setTimeout(function(){X=0;D()},50);W=!1}}function E(a){t(r,a[0])||s(p(a[0],null,!0)).init(a[1],a[2])}function I(a){var a=a.currentTarget||a.srcElement,b=i.onScriptLoad;a.detachEvent&&!Y?a.detachEvent("onreadystatechange",b):a.removeEventListener("load",b,!1);b=i.onScriptError;(!a.detachEvent||Y)&&a.removeEventListener("error",b,!1);return{node:a,id:a&&a.getAttribute("data-requiremodule")}}function J(){var a;
for(x();A.length;){a=A.shift();if(null===a[0])return w(C("mismatch","Mismatched anonymous define() module: "+a[a.length-1]));E(a)}}var W,Z,i,L,X,j={waitSeconds:7,baseUrl:"./",paths:{},bundles:{},pkgs:{},shim:{},config:{}},h={},V={},$={},A=[],r={},S={},aa={},K=1,O=1;L={require:function(a){return a.require?a.require:a.require=i.makeRequire(a.map)},exports:function(a){a.usingExports=!0;if(a.map.isDefine)return a.exports?r[a.map.id]=a.exports:a.exports=r[a.map.id]={}},module:function(a){return a.module?
a.module:a.module={id:a.map.id,uri:a.map.url,config:function(){return m(j.config,a.map.id)||{}},exports:a.exports||(a.exports={})}}};Z=function(a){this.events=m($,a.id)||{};this.map=a;this.shim=m(j.shim,a.id);this.depExports=[];this.depMaps=[];this.depMatched=[];this.pluginMaps={};this.depCount=0};Z.prototype={init:function(a,b,c,f){f=f||{};if(!this.inited){this.factory=b;if(c)this.on("error",c);else this.events.error&&(c=u(this,function(a){this.emit("error",a)}));this.depMaps=a&&a.slice(0);this.errback=
c;this.inited=!0;this.ignore=f.ignore;f.enabled||this.enabled?this.enable():this.check()}},defineDep:function(a,b){this.depMatched[a]||(this.depMatched[a]=!0,this.depCount-=1,this.depExports[a]=b)},fetch:function(){if(!this.fetched){this.fetched=!0;i.startTime=(new Date).getTime();var a=this.map;if(this.shim)i.makeRequire(this.map,{enableBuildCallback:!0})(this.shim.deps||[],u(this,function(){return a.prefix?this.callPlugin():this.load()}));else return a.prefix?this.callPlugin():this.load()}},load:function(){var a=
this.map.url;S[a]||(S[a]=!0,i.load(this.map.id,a))},check:function(){if(this.enabled&&!this.enabling){var a,b,c=this.map.id;b=this.depExports;var f=this.exports,l=this.factory;if(this.inited)if(this.error)this.emit("error",this.error);else{if(!this.defining){this.defining=!0;if(1>this.depCount&&!this.defined){if(G(l)){if(this.events.error&&this.map.isDefine||g.onError!==ca)try{f=i.execCb(c,l,b,f)}catch(d){a=d}else f=i.execCb(c,l,b,f);this.map.isDefine&&void 0===f&&((b=this.module)?f=b.exports:this.usingExports&&
(f=this.exports));if(a)return a.requireMap=this.map,a.requireModules=this.map.isDefine?[this.map.id]:null,a.requireType=this.map.isDefine?"define":"require",w(this.error=a)}else f=l;this.exports=f;if(this.map.isDefine&&!this.ignore&&(r[c]=f,g.onResourceLoad))g.onResourceLoad(i,this.map,this.depMaps);y(c);this.defined=!0}this.defining=!1;this.defined&&!this.defineEmitted&&(this.defineEmitted=!0,this.emit("defined",this.exports),this.defineEmitComplete=!0)}}else this.fetch()}},callPlugin:function(){var a=
this.map,b=a.id,d=p(a.prefix);this.depMaps.push(d);q(d,"defined",u(this,function(f){var l,d;d=m(aa,this.map.id);var e=this.map.name,P=this.map.parentMap?this.map.parentMap.name:null,n=i.makeRequire(a.parentMap,{enableBuildCallback:!0});if(this.map.unnormalized){if(f.normalize&&(e=f.normalize(e,function(a){return c(a,P,!0)})||""),f=p(a.prefix+"!"+e,this.map.parentMap),q(f,"defined",u(this,function(a){this.init([],function(){return a},null,{enabled:!0,ignore:!0})})),d=m(h,f.id)){this.depMaps.push(f);
if(this.events.error)d.on("error",u(this,function(a){this.emit("error",a)}));d.enable()}}else d?(this.map.url=i.nameToUrl(d),this.load()):(l=u(this,function(a){this.init([],function(){return a},null,{enabled:!0})}),l.error=u(this,function(a){this.inited=!0;this.error=a;a.requireModules=[b];B(h,function(a){0===a.map.id.indexOf(b+"_unnormalized")&&y(a.map.id)});w(a)}),l.fromText=u(this,function(f,c){var d=a.name,e=p(d),P=M;c&&(f=c);P&&(M=!1);s(e);t(j.config,b)&&(j.config[d]=j.config[b]);try{g.exec(f)}catch(h){return w(C("fromtexteval",
"fromText eval for "+b+" failed: "+h,h,[b]))}P&&(M=!0);this.depMaps.push(e);i.completeLoad(d);n([d],l)}),f.load(a.name,n,l,j))}));i.enable(d,this);this.pluginMaps[d.id]=d},enable:function(){V[this.map.id]=this;this.enabling=this.enabled=!0;v(this.depMaps,u(this,function(a,b){var c,f;if("string"===typeof a){a=p(a,this.map.isDefine?this.map:this.map.parentMap,!1,!this.skipMap);this.depMaps[b]=a;if(c=m(L,a.id)){this.depExports[b]=c(this);return}this.depCount+=1;q(a,"defined",u(this,function(a){this.undefed||
(this.defineDep(b,a),this.check())}));this.errback?q(a,"error",u(this,this.errback)):this.events.error&&q(a,"error",u(this,function(a){this.emit("error",a)}))}c=a.id;f=h[c];!t(L,c)&&(f&&!f.enabled)&&i.enable(a,this)}));B(this.pluginMaps,u(this,function(a){var b=m(h,a.id);b&&!b.enabled&&i.enable(a,this)}));this.enabling=!1;this.check()},on:function(a,b){var c=this.events[a];c||(c=this.events[a]=[]);c.push(b)},emit:function(a,b){v(this.events[a],function(a){a(b)});"error"===a&&delete this.events[a]}};
i={config:j,contextName:b,registry:h,defined:r,urlFetched:S,defQueue:A,Module:Z,makeModuleMap:p,nextTick:g.nextTick,onError:w,configure:function(a){a.baseUrl&&"/"!==a.baseUrl.charAt(a.baseUrl.length-1)&&(a.baseUrl+="/");var b=j.shim,c={paths:!0,bundles:!0,config:!0,map:!0};B(a,function(a,b){c[b]?(j[b]||(j[b]={}),U(j[b],a,!0,!0)):j[b]=a});a.bundles&&B(a.bundles,function(a,b){v(a,function(a){a!==b&&(aa[a]=b)})});a.shim&&(B(a.shim,function(a,c){H(a)&&(a={deps:a});if((a.exports||a.init)&&!a.exportsFn)a.exportsFn=
i.makeShimExports(a);b[c]=a}),j.shim=b);a.packages&&v(a.packages,function(a){var b,a="string"===typeof a?{name:a}:a;b=a.name;a.location&&(j.paths[b]=a.location);j.pkgs[b]=a.name+"/"+(a.main||"main").replace(ia,"").replace(Q,"")});B(h,function(a,b){!a.inited&&!a.map.unnormalized&&(a.map=p(b,null,!0))});if(a.deps||a.callback)i.require(a.deps||[],a.callback)},makeShimExports:function(a){return function(){var b;a.init&&(b=a.init.apply(ba,arguments));return b||a.exports&&da(a.exports)}},makeRequire:function(a,
e){function j(c,d,m){var n,q;e.enableBuildCallback&&(d&&G(d))&&(d.__requireJsBuild=!0);if("string"===typeof c){if(G(d))return w(C("requireargs","Invalid require call"),m);if(a&&t(L,c))return L[c](h[a.id]);if(g.get)return g.get(i,c,a,j);n=p(c,a,!1,!0);n=n.id;return!t(r,n)?w(C("notloaded",'Module name "'+n+'" has not been loaded yet for context: '+b+(a?"":". Use require([])"))):r[n]}J();i.nextTick(function(){J();q=s(p(null,a));q.skipMap=e.skipMap;q.init(c,d,m,{enabled:!0});D()});return j}e=e||{};U(j,
{isBrowser:z,toUrl:function(b){var d,e=b.lastIndexOf("."),k=b.split("/")[0];if(-1!==e&&(!("."===k||".."===k)||1<e))d=b.substring(e,b.length),b=b.substring(0,e);return i.nameToUrl(c(b,a&&a.id,!0),d,!0)},defined:function(b){return t(r,p(b,a,!1,!0).id)},specified:function(b){b=p(b,a,!1,!0).id;return t(r,b)||t(h,b)}});a||(j.undef=function(b){x();var c=p(b,a,!0),e=m(h,b);e.undefed=!0;d(b);delete r[b];delete S[c.url];delete $[b];T(A,function(a,c){a[0]===b&&A.splice(c,1)});e&&(e.events.defined&&($[b]=e.events),
y(b))});return j},enable:function(a){m(h,a.id)&&s(a).enable()},completeLoad:function(a){var b,c,d=m(j.shim,a)||{},g=d.exports;for(x();A.length;){c=A.shift();if(null===c[0]){c[0]=a;if(b)break;b=!0}else c[0]===a&&(b=!0);E(c)}c=m(h,a);if(!b&&!t(r,a)&&c&&!c.inited){if(j.enforceDefine&&(!g||!da(g)))return e(a)?void 0:w(C("nodefine","No define call for "+a,null,[a]));E([a,d.deps||[],d.exportsFn])}D()},nameToUrl:function(a,b,c){var d,e,h;(d=m(j.pkgs,a))&&(a=d);if(d=m(aa,a))return i.nameToUrl(d,b,c);if(g.jsExtRegExp.test(a))d=
a+(b||"");else{d=j.paths;a=a.split("/");for(e=a.length;0<e;e-=1)if(h=a.slice(0,e).join("/"),h=m(d,h)){H(h)&&(h=h[0]);a.splice(0,e,h);break}d=a.join("/");d+=b||(/^data\:|\?/.test(d)||c?"":".js");d=("/"===d.charAt(0)||d.match(/^[\w\+\.\-]+:/)?"":j.baseUrl)+d}return j.urlArgs?d+((-1===d.indexOf("?")?"?":"&")+j.urlArgs):d},load:function(a,b){g.load(i,a,b)},execCb:function(a,b,c,d){return b.apply(d,c)},onScriptLoad:function(a){if("load"===a.type||ja.test((a.currentTarget||a.srcElement).readyState))N=null,
a=I(a),i.completeLoad(a.id)},onScriptError:function(a){var b=I(a);if(!e(b.id))return w(C("scripterror","Script error for: "+b.id,a,[b.id]))}};i.require=i.makeRequire();return i}var g,x,y,D,I,E,N,J,s,O,ka=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/mg,la=/[^.]\s*require\s*\(\s*["']([^'"\s]+)["']\s*\)/g,Q=/\.js$/,ia=/^\.\//;x=Object.prototype;var K=x.toString,fa=x.hasOwnProperty,ha=Array.prototype.splice,z=!!("undefined"!==typeof window&&"undefined"!==typeof navigator&&window.document),ea=!z&&"undefined"!==
typeof importScripts,ja=z&&"PLAYSTATION 3"===navigator.platform?/^complete$/:/^(complete|loaded)$/,Y="undefined"!==typeof opera&&"[object Opera]"===opera.toString(),F={},q={},R=[],M=!1;if("undefined"===typeof define){if("undefined"!==typeof requirejs){if(G(requirejs))return;q=requirejs;requirejs=void 0}"undefined"!==typeof require&&!G(require)&&(q=require,require=void 0);g=requirejs=function(b,c,d,e){var n,p="_";!H(b)&&"string"!==typeof b&&(n=b,H(c)?(b=c,c=d,d=e):b=[]);n&&n.context&&(p=n.context);
(e=m(F,p))||(e=F[p]=g.s.newContext(p));n&&e.configure(n);return e.require(b,c,d)};g.config=function(b){return g(b)};g.nextTick="undefined"!==typeof setTimeout?function(b){setTimeout(b,4)}:function(b){b()};require||(require=g);g.version="2.1.18";g.jsExtRegExp=/^\/|:|\?|\.js$/;g.isBrowser=z;x=g.s={contexts:F,newContext:ga};g({});v(["toUrl","undef","defined","specified"],function(b){g[b]=function(){var c=F._;return c.require[b].apply(c,arguments)}});if(z&&(y=x.head=document.getElementsByTagName("head")[0],
D=document.getElementsByTagName("base")[0]))y=x.head=D.parentNode;g.onError=ca;g.createNode=function(b){var c=b.xhtml?document.createElementNS("http://www.w3.org/1999/xhtml","html:script"):document.createElement("script");c.type=b.scriptType||"text/javascript";c.charset="utf-8";c.async=!0;return c};g.load=function(b,c,d){var e=b&&b.config||{};if(z)return e=g.createNode(e,c,d),e.setAttribute("data-requirecontext",b.contextName),e.setAttribute("data-requiremodule",c),e.attachEvent&&!(e.attachEvent.toString&&
0>e.attachEvent.toString().indexOf("[native code"))&&!Y?(M=!0,e.attachEvent("onreadystatechange",b.onScriptLoad)):(e.addEventListener("load",b.onScriptLoad,!1),e.addEventListener("error",b.onScriptError,!1)),e.src=d,J=e,D?y.insertBefore(e,D):y.appendChild(e),J=null,e;if(ea)try{importScripts(d),b.completeLoad(c)}catch(m){b.onError(C("importscripts","importScripts failed for "+c+" at "+d,m,[c]))}};z&&!q.skipDataMain&&T(document.getElementsByTagName("script"),function(b){y||(y=b.parentNode);if(I=b.getAttribute("data-main"))return s=
I,q.baseUrl||(E=s.split("/"),s=E.pop(),O=E.length?E.join("/")+"/":"./",q.baseUrl=O),s=s.replace(Q,""),g.jsExtRegExp.test(s)&&(s=I),q.deps=q.deps?q.deps.concat(s):[s],!0});define=function(b,c,d){var e,g;"string"!==typeof b&&(d=c,c=b,b=null);H(c)||(d=c,c=null);!c&&G(d)&&(c=[],d.length&&(d.toString().replace(ka,"").replace(la,function(b,d){c.push(d)}),c=(1===d.length?["require"]:["require","exports","module"]).concat(c)));if(M){if(!(e=J))N&&"interactive"===N.readyState||T(document.getElementsByTagName("script"),
function(b){if("interactive"===b.readyState)return N=b}),e=N;e&&(b||(b=e.getAttribute("data-requiremodule")),g=F[e.getAttribute("data-requirecontext")])}(g?g.defQueue:R).push([b,c,d])};define.amd={jQuery:!0};g.exec=function(b){return eval(b)};g(q)}})(this);
;/* global $, window */
/* exported RoleRevisit */
var RoleRevisit = function RoleRevisit() {
    'use strict';
    //global vars
    var roleRevisit = {};
    roleRevisit.options = {
        nodeType:'Alter',
        edgeType:'Dyad',
        targetEl: $('.container'),
        variables: [],
        heading: 'This is a default heading',
        subheading: 'And this is a default subheading'
    };

    var nodeBoxOpen = false;
    var editing = false;

    var roles = {
        'Friend': ['Best Friend','Friend','Ex-friend','Other type'],
        'Family / Relative': ['Parent / Guardian','Brother / Sister','Grandparent','Other Family','Chosen Family'],
        'Romantic / Sexual Partner': ['Boyfriend / Girlfriend','Ex-Boyfriend / Ex-Girlfriend','Booty Call / Fuck Buddy / Hook Up','One Night Stand','Other type of Partner'],
        'Acquaintance / Associate': ['Coworker / Colleague','Classmate','Roommate','Friend of a Friend','Neighbor','Other'],
        'Other Support / Source of Advice': ['Teacher / Professor','Counselor / Therapist','Community Agency Staff','Religious Leader','Mentor','Coach','Other'],
        'Drug Use': ['Someone you use drugs with','Someone you buy drugs from'],
        'Other': ['Other relationship']
    };

    var roleClickHandler = function() {

        if ($(this).data('selected') === true) {
            $(this).data('selected', false);
            $(this).removeClass('selected');

        } else {
            $(this).data('selected', true);
            $(this).addClass('selected');
        }

    };

    var stageChangeHandler = function() {
        roleRevisit.destroy();
    };

    var cardClickHandler = function(e) {
        console.log('card click');
        console.log(e);

        var index = $(this).data('index');
        console.log(index);
        // Set the value of editing to the node id of the current person
        editing = index;

        // Update role count
        var roleCount = window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id, to: editing, type:'Role'}).length;
        $('div[data-index="'+index+'"]').children().children('.role-count').html(roleCount+' roles selected.');

        // Mark the existing roles as selected
        var roleEdges = window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id, to: editing, type:'Role'});
        $.each(roleEdges, function(index, value) {
             $('.rel-'+value.reltype_main_t0).find('div[data-sub-relationship="'+value.reltype_sub_t0+'"]').addClass('selected').data('selected', true);
        });

        // Once the box is opened, delete all the Role edges. Simpler than adding removal logic.
        window.network.removeEdges(window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id, to: editing, type:'Role'}));
        roleRevisit.openNodeBox();

    };

    var submitFormHandler = function() {
        var el = $('div[data-index='+editing+']');
        el.stop().transition({background:'#1ECD97'}, 400, 'ease');
        $.each($('.relationship.selected'), function() {
             var edgeProperties = {
                type: 'Role',
                from:window.network.getNodes({type_t0:'Ego'})[0].id,
                to: editing,
                reltype_main_t0: $(this).parent('.relationship-type').data('main-relationship'),
                reltype_sub_t0: $(this).data('sub-relationship')
              };
            window.network.addEdge(edgeProperties);
        });

        // Deselect all relationships
        $('.relationship').removeClass('selected');
        var roleCount = window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id, to: editing, type:'Role'}).length;
        $('div[data-index="'+editing+'"]').children().children('.role-count').html(roleCount+' roles selected.');
        roleRevisit.closeNodeBox();
    };

    roleRevisit.openNodeBox = function() {
        $('.content').addClass('blurry');
        $('.relationship-types-container').addClass('open');
        nodeBoxOpen = true;
    };

    roleRevisit.closeNodeBox = function() {
        $('.content').removeClass('blurry');
        // $('.newNodeBox').transition({scale:0.1,opacity:0},500);
        $('.relationship-types-container').removeClass('open');
        setTimeout(function() {

        });
        nodeBoxOpen = false;
    };

	roleRevisit.addToList = function(properties) {
		// var index = $(this).data('index');
		var card;

		card = $('<div class="card" data-index="'+properties.to+'"><h4>'+properties.nname_t0+'</h4></div>');
		var list = $('<ul></ul>');

        list.append('<li class="'+properties.fname_t0+'"><strong>First Name</strong>: '+properties.fname_t0+'</li>');
        list.append('<li class="'+properties.lname_t0+'"><strong>Last Name</strong>: '+properties.lname_t0+'</li>');

        var roles = window.network.getEdges({from:window.network.getNodes({type_t0:'Ego'})[0].id, to: properties.to, type:'Role'});
        var roleString = '';
        $.each(roles, function(index, value) {
            roleString += ' '+value.reltype_sub_t0+',';
        });

        // cut off the last comma
        roleString = roleString.substring(0, roleString.length - 1);

        list.append('<li><strong>Roles</strong>: '+roleString+'</li>');

		card.append(list);

		$('.nameList').append(card);

	};

    roleRevisit.destroy = function() {
        window.tools.notify('Destroying roleRevisit.',0);
        // Event listeners
        $(window.document).off('click', '.card', cardClickHandler);
        window.removeEventListener('changeStageStart', stageChangeHandler, false);
        $('.relationship-types-container').remove();
        $(window.document).off('click', '.relationship', roleClickHandler);
        $(window.document).off('click', '.relationship-close-button', roleRevisit.toggleRelationshipBox);
    };

    roleRevisit.init = function(options) {
        window.tools.extend(roleRevisit.options, options);
        // create elements
        var title = $('<h1 class="text-center"></h1>').html(roleRevisit.options.heading);
        roleRevisit.options.targetEl.append(title);
        var subtitle = $('<p class="lead text-center"></p>').html(roleRevisit.options.subheading);
        roleRevisit.options.targetEl.append(subtitle);


        // relationship types
        var roleBox = $('<div class="relationship-types-container"><button class="btn btn-primary relationship-close-button">Close</button></div>');
        $('body').append(roleBox);
        var counter = 0;
        $.each(roles, function(index) {
            $('.relationship-types-container').append('<div class="relationship-type rel-'+counter+' c'+counter+'" data-main-relationship="'+counter+'"><h1>'+index+'</h1></div>');
            $.each(roles[index], function(relIndex, relValue) {
                $('.rel-'+counter).append('<div class="relationship" data-sub-relationship="'+relValue+'">'+relValue+'</div>');
            });
            counter++;
        });

        var nodeContainer = $('<div class="node-container"></div>');
        roleRevisit.options.targetEl.append(nodeContainer);

        // create namelist container
        var nameList = $('<div class="table nameList"></div>');
        $('.node-container').append(nameList);

        // Event listeners
        window.addEventListener('changeStageStart', stageChangeHandler, false);
        $(window.document).on('click', '.card', cardClickHandler);
        $(window.document).on('click', '.relationship', roleClickHandler);
        $(window.document).on('click', '.relationship-close-button', submitFormHandler);

        // Set node count box
    };

    return roleRevisit;
};

module.exports = new RoleRevisit();
;/* global document, window, $, protocol, nodeRequire, note */
/* exported Session, eventLog */
var Session = function Session() {
    'use strict';
    //window vars
    var session = {};
    var currentStage = 0;
    var content = $('#content');
    session.id = 0;
    session.sessionData = {};
    var lastSaveTime, saveTimer;

    function saveFile(path) {
        if (window.isNodeWebkit) {
            var data = JSON.stringify(session.sessionData, undefined, 2);
            var fs = nodeRequire('fs');
            fs.writeFile(path, data);
        } else {
            note.warn('saveFile() is not yet implemented on this platform!');
        }
    }

    function clickDownloadInput() {
        $('#save').prop('nwsaveas', session.returnSessionID()+'_'+Math.floor(Date.now() / 1000)+'.json');
        var event = window.document.createEvent('MouseEvents');
        event.initMouseEvent('click');
        window.document.getElementById('save').dispatchEvent(event);
    }

    // custom events
    session.options = {
        fnBeforeStageChange : function(oldStage, newStage) {
            var eventProperties = {
                stage: currentStage,
                timestamp: new Date()
            };
            var log = new window.CustomEvent('log', {'detail':{'eventType': 'stageCompleted', 'eventObject':eventProperties}});
            window.dispatchEvent(log);

            // $(document).trigger('changeStageStart', {'detail':{oldStage: oldStage, newStage: newStage}});
            var changeStageStartEvent = new window.CustomEvent('changeStageStart', {'detail':{oldStage: oldStage, newStage: newStage}});
            window.dispatchEvent(changeStageStartEvent);

        },
        fnAfterStageChange : function(oldStage, newStage) {
            session.sessionData.sessionParameters.stage = newStage;
            var changeStageEndEvent = new window.CustomEvent('changeStageEnd', {'detail':{oldStage: oldStage, newStage: newStage}});
            window.dispatchEvent(changeStageEndEvent);
            if ((currentStage+1) === session.stages.length) { // last stage
                $('.paginate').removeAttr('disabled');
                $('.arrow-next').attr('disabled', 'disabled');
                if (currentStage === 0) { // first and last stage
                    $('.arrow-prev').attr('disabled', 'disabled');
                }
            } else if (currentStage === 0) { // first stage
                $('.paginate').removeAttr('disabled');
                $('.arrow-prev').attr('disabled', 'disabled');
            } else {    // neither
                $('.paginate').removeAttr('disabled');
            }
        }
    };

    session.loadProtocol = function() {

        // Require the session protocol file.
        // var studyPath = path.normalize('../protocols/'+window.studyProtocol+'/protocol.js');
        $.getScript( 'protocols/'+window.netCanvas.studyProtocol+'/protocol.js', function() {

            // protocol.js files declare a protocol variable, which is what we use here.
            // It is implicitly loaded as part of the getScript callback
            var study = protocol;

            session.parameters = session.registerData('sessionParameters');
            session.updateSessionData({sessionParameters:study.sessionParameters});
            // copy the stages
            session.stages = study.stages;

            // insert the stylesheet
            $('head').append('<link rel="stylesheet" href="protocols/'+window.netCanvas.studyProtocol+'/css/style.css" type="text/css" />');

            // copy the skip functions
            if (typeof study.skipFunctions !== 'undefined') {
                session.skipFunctions = study.skipFunctions;
            }

            // set the study name (used for database name)
            if (study.sessionParameters.name) {
                session.name = study.sessionParameters.name;
            } else {
                note.error('Study protocol must have key "name" under sessionParameters.');
            }

            // Check for an in-progress session
            window.dataStore.init(function(sessionid) {
                session.id = sessionid;
                window.dataStore.load(function(data) {

                    session.updateSessionData(data, function() {
                        // Only load the network into the model if there is a network to load
                        if(session.sessionData.nodes && session.sessionData.edges) {
                            window.network.loadNetwork({nodes:session.sessionData.nodes,edges:session.sessionData.edges});
                        }

                        if (typeof session.sessionData.sessionParameters.stage !== 'undefined') {
                            session.goToStage(session.sessionData.sessionParameters.stage);
                        } else {
                            session.goToStage(0);
                        }
                    });

                    // create the sessionGlobals
                    if (typeof study.globals !=='undefined') {
                        session.globals = study.globals;
                        // iterate through and execute;
                        $.each(session.globals, function(index, value) {
                            value();
                        });
                    }

                }, session.id);
            });

            // Initialise the menu system other modules depend on it being there.
            var stagesMenuOptions = {
                name: 'Stages',
                icon: 'fa-bars',
                items: []
            };

            $.each(session.stages, function(index,value) {
                var icon = null;
                if (value.icon) {
                    icon = value.icon;
                }
                var itemObject = {
                    label: value.label,
                    icon: icon,
                    action: function() {setTimeout(function() {session.goToStage(index);}, 500); }
                };

                stagesMenuOptions.items.push(itemObject);

            });

            window.stagesMenu = new window.netCanvas.Modules.Menu(stagesMenuOptions);

        }).fail(function( jqxhr, textStatus, error ) {
            var err = textStatus + ', ' + error;
            note.error('Error fetching protocol!');
            note.trace(err);
        });

    };

    function sessionNextHandler() {
        session.nextStage();
    }

    function sessionPreviousHandler() {
        session.prevStage();
    }

    session.init = function(callback) {
        note.info('Session initialising.');

        // Navigation arrows.
        $('.arrow-next').on('click', sessionNextHandler);

        $('.arrow-prev').on('click', sessionPreviousHandler);

        //bind to the custom state change event to handle spinner interactions
        window.addEventListener('changeStageStart', function () {
            $('.loader').transition({opacity:1});
        }, false);

        window.addEventListener('changeStageEnd', function () {
            $('.loader').transition({opacity:0});
        }, false);

        window.document.getElementById('save').addEventListener('change', function () {
            saveFile(this.value);
        });

        // Build a new network
        window.network = new window.netCanvas.Modules.Network();

        window.addEventListener('unsavedChanges', function () {
            session.saveManager();
        }, false);

        var sessionMenuOptions = {
            name: 'Session',
            icon: 'fa-cogs',
            items: []
        };

        window.sessionMenu = new window.netCanvas.Modules.Menu(sessionMenuOptions);
        window.sessionMenu.addItem('Reset this Session', 'fa-undo', function() {
            window.BootstrapDialog.show({
                type: window.BootstrapDialog.TYPE_DANGER,
                // size: BootstrapDialog.SIZE_LARGE,
                title: '',
                message: '<h3>Are you sure you want to reset the session?</h3> <p><strong>IMPORTANT:</strong> This will delete all data from this session. Data from other sessions will not be deleted (use purge database if you wish to delete this data too).',
                buttons: [{
                    label: 'Continue',
                    cssClass: 'btn-modal-success',
                    action: function(){
                        window.dataStore.deleteDocument(session.reset);
                    }
                }, {
                    label: 'Cancel',
                    cssClass: 'btn-modal-danger',
                    action: function(dialogItself){
                        dialogItself.close();
                    }
                }]
            });
        });

        window.sessionMenu.addItem('Download Data', 'fa-download', function() { clickDownloadInput(); });

        window.sessionMenu.addItem('Purge Database', 'fa-trash', function() {
            window.BootstrapDialog.show({
                type: window.BootstrapDialog.TYPE_DANGER,
                // size: BootstrapDialog.SIZE_LARGE,
                title: '',
                message: '<h3>Are you sure you want to purge the database?</h3><p><strong>IMPORTANT:</strong> This will delete all data.',
                buttons: [{
                    label: 'Continue',
                    cssClass: 'btn-modal-success',
                    action: function(){
                        window.dataStore.reset(session.reset);
                    }
                }, {
                    label: ' Cancel',
                    cssClass: 'btn-modal-danger',
                    action: function(dialogItself){
                        dialogItself.close();
                    }
                }]
            });
        });

        window.sessionMenu.addItem('Quit Network Canvas', 'fa-sign-out', function() { window.close(); });

        if(callback) {
            callback();
        }

    };

    session.getPrimaryNetwork = function() {
        return window.network;
    };

    session.downloadData = function() {
        var filename = session.returnSessionID()+'.json';
        var text = JSON.stringify(session.sessionData, undefined, 2); // indentation level = 2;
        var pom = document.createElement('a');
        pom.setAttribute('href', 'data:text/plain;charset=utf-8,' + encodeURIComponent(text));
        pom.setAttribute('download', filename);
        pom.click();
    };

    session.reset = function() {
        note.info('Resetting session.');
        session.id = 0;
        session.currentStage = 0;

        if (window.isNodeWebkit) {
            var _window = window.gui.Window.get();
            _window.reloadDev();
        } else {
            window.location.reload();
        }

    };

    session.saveManager = function() {
        clearTimeout(saveTimer);
        saveTimer = setTimeout(session.saveData, 3000);
    };

    session.updateSessionData = function(data, callback) {
        note.debug('Updating user data.');
        note.debug('Using the following to update:');
        note.debug(data);


        // Here, we used to simply use our extend method on session.sessionData with the new data.
        // This failed for arrays.
        // Switched to $.extend and added 'deep' as first function parameter for this reason.
        $.extend(true, session.sessionData, data);

        var newDataLoaded = new window.Event('newDataLoaded');
        window.dispatchEvent(newDataLoaded);
        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);

        if (callback) {
            callback();
        }
    };

    session.returnSessionID = function() {
        return session.id;
    };

    session.saveData = function() {
        session.sessionData.nodes = window.network.getNodes();
        session.sessionData.edges = window.network.getEdges();
        if(!window.dataStore.initialised()) {
            var unsavedChanges = new window.Event('unsavedChanges');
            window.dispatchEvent(unsavedChanges);
        } else {
            window.dataStore.save(session.sessionData, session.returnSessionID());
        }

        lastSaveTime = new Date();
    };

    session.goToStage = function(stage) {
        if (typeof stage === 'undefined' || typeof session.stages[stage] === 'undefined') {
            return false;
        }

        // Skip logic

        // is there a skip function for this stage?
        if (session.stages[stage].skip) {

            //evaluate skip function
            var outcome = session.stages[stage].skip();

            // if true, skip the stage
            if (outcome === true) {
                if (stage > currentStage) {
                    session.goToStage(stage+1);
                } else {
                    session.goToStage(stage-1);

                }

                return false;
            }
        }

        note.info('Session is moving to stage '+stage);

        // Crate stage visible event
        var eventProperties = {
            stage: stage,
            timestamp: new Date()
        };
        var log = new window.CustomEvent('log', {'detail':{'eventType': 'stageVisible', 'eventObject':eventProperties}});
        window.dispatchEvent(log);

        // Fire before stage change event
        session.options.fnBeforeStageChange(currentStage,stage);

        // Transition the content
        var newStage = stage;
        var stagePath ='./protocols/'+window.netCanvas.studyProtocol+'/stages/'+session.stages[stage].page;
        stagePath += '?_=' + (new Date()).getTime();
        content.transition({opacity: '0'},400,'easeInSine').promise().done( function(){
            content.load( stagePath, function() {
                content.transition({ opacity: '1'},400,'easeInSine');
            });
        });

        var oldStage = currentStage;
        currentStage = newStage;
        session.options.fnAfterStageChange(oldStage, currentStage);
        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);
    };

    session.nextStage = function() {
        session.goToStage(currentStage+1);
    };

    session.prevStage = function() {
        session.goToStage(currentStage-1);
    };

    session.registerData = function(dataKey, isArray) {
        note.info('A script requested a data store be registered with the key "'+dataKey+'".');
        if (session.sessionData[dataKey] === undefined) { // Create it if it doesn't exist.
            note.debug('Key named "'+dataKey+'" was not already registered. Creating.');
            if (isArray) {
                session.sessionData[dataKey] = [];
            } else {
                session.sessionData[dataKey] = {};
            }
        } else {
            note.debug('A data store with this key already existed. Returning a reference.');
        }
        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);
        return session.sessionData[dataKey];
    };

    session.addData = function(dataKey, newData, append) {
        /*
        This function should let any module add data to the session model. The session model
        (window data variable) is essentially a key/value store.
        */

        // Check if we are appending or overwriting
        if (!append) { append = false; }

        if (append === true) { // this is an array
            session.sessionData[dataKey].push(newData);
        } else {
            window.tools.extend(session.sessionData[dataKey], newData);
        }

        // Notify
        note.debug('Adding data to key "'+dataKey+'".');
        note.debug(newData);

        // Emit an event to trigger data store synchronisation.
        var unsavedChanges = new window.Event('unsavedChanges');
        window.dispatchEvent(unsavedChanges);

    };

    session.currentStage = function() {
        return currentStage;
    };

    session.returnData = function(dataKey) {
        if (!dataKey) {
            return session.sessionData;
        } else if (typeof session.sessionData[dataKey] !== 'undefined') {
            return session.sessionData[dataKey];
        } else {
            return session.sessionData;
        }
    };

    return session;
};

module.exports = new Session();
;/* global Konva, window, $, note, ConvexHullGrahamScan, Image */
/* exported Sociogram */
/*jshint bitwise: false*/

module.exports = function Sociogram() {
	'use strict';
	// Global variables
	var stage, circleLayer, edgeLayer, nodeLayer, wedgeLayer, hullLayer, uiLayer, sociogram = {};
	var moduleEvents = [];
	var selectedNodes = [];
	var selectedNode = null;
	var log;
	var taskComprehended = false;
	var newNodeCircleTween;
	var nodesWithoutPositions = 0;
	var newNodeCircleVisible = false;
	var hullsShown = false;
	var longPressTimer, tapTimer;
	var touchNotTap = false;
	var hullShapes = {};

	// Colours
	var colors = {
		blue: '#0174DF',
		tomato: '#FF6347',
		teal: '#008080',
		hullpurple: '#9a208e',
		freesia: '#ffd600',
		hullgreen: '#6ac14c',
		cayenne: '#c40000',
		placidblue: '#83b5dd',
		violettulip: '#9B90C8',
		hemlock: '#9eccb3',
		paloma: '#aab1b0',
		sand: '#ceb48d',
		dazzlingblue: '#006bb6',
		edge: '#dd393a',
		selected: '#ffbf00',
	};

	var hullColors = ['#01a6c7','#1ECD97', '#B16EFF','#FA920D','#e85657','Gold','Pink','Saddlebrown','Teal','Silver'];

	// Default sociogram.settings
	sociogram.settings = {
		network: window.netCanvas.Modules.session.getPrimaryNetwork(),
		targetEl: 'kineticCanvas',
		// consecutive single tap - edge mode
		// drag - layout mode
		// double tap - select mode
		// long press - community mode
		modes:['Position'], //edge - create edges, position - lay out, select - node attributes
	    panels: ['mode', 'details'], // Mode - switch between modes, Details - long press shows node details
		options: {
			defaultNodeSize: 30,
			defaultNodeColor: 'white',
			defaultNodeStrokeWidth: 4,
			defaultLabelColor: 'black',
			defaultEdgeColor: colors.edge,
			concentricCircleColor: '#ffffff',
			concentricCircleNumber: 4,
			concentricCircleSkew: false,
			showMe: true
		},
		nodeTypes: [
			{'name':'Person','color':colors.blue},
			{'name':'OnlinePerson','color':colors.hemlock},
			{'name':'Organisation','color':colors.cayenne},
			{'name':'Professional','color':colors.violettulip}
		],
	    dataDestination: {
	        // indexed by mode. one for each active mode
	        'Edge': {
	            // type: 'edge', // edge or node. where do we store the attriute?
	            // variables: [
	            //     {name:'type', value:'Friend'}, // node or edge type. Should this be promoted out of the variables array? Might need to respect existing exdges or nodes. When to we overwrite vs update?
	            //     {name:'namegenerator', value: 'closest'}
	            //     // {'weight': function() { some callback eval code }}
	            // ]
	        },
	        'Select': {
	            // type: 'node', //"hypernode" - create node for attribute type and link with edge?
	            // mode: 'flip', // flip - flip binary value of flip_variable, create - delete or create node or edge
	            // flip_variable: 'drugUser', // O
	            // variables: [
	            //     {name: 'drugType', value: 'boozybix'}
	            // ]
	        },
	        'Position': {
	            // type: 'node',
	            // variable: 'coords'
	        },
	        'Community' : {
	            // type: 'node', // node, edge, ego
				// name: 'Groups',
				// variable: 'special_hulls'
	        }
	    },
	    criteria: { // criteria for being shown on this screen
	        type: 'node',
	        includeEgo: false,
	        query: {
	        }
	    },
		heading: 'A default heading',
		subheading: 'A default subheading'
	};

	sociogram.settings.dataOrigin = {
		// indexed by mode. one for each active mode
        'Edge': sociogram.settings.dataDestination.Edge,
        'Select': sociogram.settings.dataDestination.Select,
        'Position': sociogram.settings.dataDestination.Position,
        'Community' : sociogram.settings.dataDestination.Community
	};

	// Private functions

	// Adjusts the size of text so that it will always fit inside a given shape.
	function padText(text, container, amount){
		while ((text.width() * 1.1)<container.width()-(amount*2)) {
			text.fontSize(text.fontSize() * 1.1);
			text.y((container.height() - text.height())/2);
		}
		text.setX( container.getX() - text.getWidth()/2 );
		text.setY( (container.getY() - text.getHeight()/1.8) );
	}

	function toPointFromObject(array) {
		var newArray = [];
		for (var i = 0; i<array.length; i++) {
			newArray.push(array[i].x);
			newArray.push(array[i].y);
		}

		return newArray;
	}

	function addNodeHandler(e) {
		sociogram.addNode(e.detail);
	}

	function addEdgeHandler(e) {
		sociogram.addEdge(e.detail);
	}

	function hullListClickHandler(e) {
		var clicked = $(e.target).closest('li');
		var selectedHull = clicked.data('hull');
		console.log(selectedNode);
		if (selectedNode.attrs.contexts.indexOf(selectedHull) !== -1 ) {
			clicked.removeClass('active');
			sociogram.removePointFromHull(selectedNode, selectedHull);
		} else {
			clicked.addClass('active');
			sociogram.addPointToHull(selectedNode, selectedHull);
		}
	}

	function groupButtonClickHandler() {
		sociogram.addHull();
	}

	sociogram.init = function (userSettings) {

		note.info('Sociogram initialising.');
		console.log(userSettings);

		$.extend(true, sociogram.settings,userSettings);
		console.log(sociogram.settings);
		// Add the title and heading
		$('<div class="sociogram-title"><h4>'+sociogram.settings.heading+'</h4><p>'+sociogram.settings.subheading+'</p></div>').insertBefore('#'+sociogram.settings.targetEl );

		// Initialise the konva stage
		sociogram.initKinetic();

		// Draw ui compoennts
		sociogram.drawUIComponents(function() {

			// Show hulls checkbox
			if (sociogram.settings.modes.indexOf('Community') !== -1) {
				$('#'+sociogram.settings.targetEl).append('<input class="show-contexts-checkbox" type="checkbox" name="context-checkbox-show" id="context-checkbox-show"> <label for="context-checkbox-show">Contexts shown</label>');
			}

			// Panels
			if (sociogram.settings.panels.indexOf('details') !== -1) {
				$('<div class="details-panel"><div class="context-header"><h4>Details</h4></div><ul class="list-group context-list"></ul><div class="context-footer"><div class="pull-left new-group-button"><span class="fa fa-plus-circle"></span> New context</div></div></div>').appendTo('#'+sociogram.settings.targetEl);
			}

			if (sociogram.settings.panels.indexOf('mode') !== -1) {
				console.warn('The "mode" panel is not yet implemented.');
			}

			/**
			* Are there existing nodes? Display them.
			* Get all nodes or that match the criteria
			* First, are we dealing with a node or an edge query?
			* - If a node query, simply query the nodes and use the node properties to create sociogram.nodes
			* - If an edge query, do three things:
			* 		- Run the edge query
			* 		- If the nodePropertiesEdge key exists, use that to get the sociogram.node properties
			* 		- If it doesn't, use the edge properties instead.
			*/

			if (sociogram.settings.criteria.type === 'edge') {

				// Get edges according to criteria query
				var criteriaEdges = sociogram.settings.network.getEdges(sociogram.settings.criteria.query);

				// Iterate over them
				for (var i = 0; i < criteriaEdges.length; i++) {

					var dyadEdge;

					// If the 'nodePropertiesEdge' key is set, use that to get the sociogram.node properties.
					if (typeof sociogram.settings.criteria.nodePropertiesEdge !== 'undefined') {
						dyadEdge = sociogram.settings.network.getEdges({from:criteriaEdges[i].from, to:criteriaEdges[i].to, type:sociogram.settings.criteria.nodePropertiesEdge})[0];
					} else {
					// If 'nodePropertiesEdge' key is not set, simply copy the edge values to the sociogram.nodes
						dyadEdge = criteriaEdges[i];
					}
					// Create the sociogram.node
					sociogram.addNode(dyadEdge);

				}

			} else if (sociogram.settings.criteria.type === 'node') {

				var criteriaNodes;

				// get nodes according to criteria query
				// filter out ego if required
				if (sociogram.settings.criteria.includeEgo !== true) {
					criteriaNodes = sociogram.settings.network.getNodes(sociogram.settings.criteria.query, function (results) {
						var filteredResults = [];
						$.each(results, function(index,value) {
							if (value.type !== 'Ego') {
								filteredResults.push(value);
							}
						});

						return filteredResults;
					});
				} else {
					criteriaNodes = sociogram.settings.network.getNodes(sociogram.settings.criteria.query);
				}

				for (var j = 0; j < criteriaNodes.length; j++) {
					sociogram.addNode(criteriaNodes[j]);
				}
			}

			// Add the evevent listeners
			window.addEventListener('nodeAdded', addNodeHandler, false);
			window.addEventListener('edgeAdded', addEdgeHandler, false);
			window.addEventListener('nodeRemoved', sociogram.removeNode, false);
			window.addEventListener('edgeRemoved', sociogram.removeEdge, false);
			window.addEventListener('changeStageStart', sociogram.destroy, false);
			$(window.document).on('change', '#context-checkbox-show', sociogram.toggleHulls);
			$(window.document).on('click', '.new-group-button', groupButtonClickHandler);

			// Update initial states of all nodes and edges;
			sociogram.updateInitialNodeState();

		});
	};

	sociogram.toggleHulls = function(e) {
		note.info('Sociogram: toggleHulls()');

		if ((e && e.target.checked) || hullsShown === false) {
			$('label[for="context-checkbox-show"]').html('Contexts shown');
			note.debug('showing hulls');
			new Konva.Tween({
				node: hullLayer,
				duration: 0.5,
				opacity: 1
			}).play();
			hullsShown = true;
		} else {
			$('label[for="context-checkbox-show"]').html('Contexts hidden');

			new Konva.Tween({
				node: hullLayer,
				duration: 0.5,
				opacity: 0
			}).play();

			hullsShown = false;
		}
		$('label[for="context-checkbox-show"]').addClass('show');
		setTimeout(function() {
			$('label[for="context-checkbox-show"]').removeClass('show');
		}, 2000);
		hullLayer.draw();
	};

	sociogram.updateInitialNodeState = function() {
		/**
		* Uses settings.dataOrigin to set the initial state of all nodes and edges.
		*/

		// Edge Mode
		if (sociogram.settings.modes.indexOf('Edge') !== -1) {

			// get the source of the edges according to dataOrigin
			if (sociogram.settings.dataOrigin.Edge.type === 'edge') {
				// Get any edges involving the currently visible nodes (needless complexity?) that meet the criteria
				var properties = {};
				$.each(sociogram.settings.dataOrigin.Edge.variables, function(index, value) {
					properties[value.name] = value.value;
				});
				var edges = sociogram.settings.network.getEdges(properties);
				$.each(edges, function(index, edge) {
					sociogram.addEdge(edge);
				});

			} else if (sociogram.settings.dataOrigin.Edge.type === 'node') {
				throw new Error('Not yet implemented.');
			} else {
			}

		}

		// Select Mode
		if (sociogram.settings.modes.indexOf('Select') !== -1) {

			if (sociogram.settings.dataOrigin.Select.mode === 'flip') {
				var selectNodes = sociogram.settings.network.getNodes();
				$.each(selectNodes, function(index, node) {
					var currentValue = node[sociogram.settings.dataOrigin.Select.flip_variable];
					if (currentValue === 1) {
						// this node is selected
						var currentNode = sociogram.getNodeByID(node.id);
						currentNode.children[1].stroke(colors.selected);
					}
				});

				nodeLayer.draw();

			} else if (sociogram.settings.dataOrigin.Select.mode === 'create') {
			} else {
				// error state
			}

		}

		// Layout Mode
		if (sociogram.settings.modes.indexOf('Position') !== -1) {
			// Get the dataOrigin for position
			if (sociogram.settings.dataOrigin.Position.type === 'node') {
				// position data is coming from the node
				var layoutNodes = sociogram.getKineticNodes();
				$.each(layoutNodes, function(index,node) {
					node.setPosition(node.attrs[sociogram.settings.dataOrigin.Position.variable]);
				});

			} else if (sociogram.settings.dataOrigin.Position.type === 'edge') {
				// position data is coming from the edge

			} else {
				// error!
			}

		}

		// Community mode

		if (sociogram.settings.modes.indexOf('Community') !== -1) {
			var communityNodes;

			if (sociogram.settings.dataOrigin.Community.type === 'node') {
				// community data is coming from the node
				communityNodes = sociogram.getKineticNodes();
				$.each(communityNodes, function(index,node) {
					$.each(node.attrs[sociogram.settings.dataOrigin.Community.variable], function (hullIndex, hullValue) {
						sociogram.addPointToHull(node, hullValue);
					});
				});

			} else if (sociogram.settings.dataOrigin.Community.type === 'ego') {
				// community data is coming from ego
				if (typeof window.network.getEgo()[sociogram.settings.dataOrigin.Community.egoVariable] === 'undefined') {
					console.warn('Ego didn\'t have the community variable you specified, so it was created as a blank array.');
					var properties = {};
					properties[sociogram.settings.dataOrigin.Community.egoVariable] = [];
					window.network.updateNode(window.network.getEgo().id, properties);
				}

				var egoHulls = window.network.getEgo()[sociogram.settings.dataOrigin.Community.egoVariable];
				$.each(egoHulls, function(hullIndex, hullValue) {
					sociogram.addHull(hullValue);
				});

				communityNodes = sociogram.getKineticNodes();
				$.each(communityNodes, function(index,node) {
					$.each(node.attrs[sociogram.settings.dataOrigin.Community.variable], function (hullIndex, hullValue) {
						// Difference from node mode is we check if the node hull has been defined by ego too
						// if (egoHulls.indexOf(hullValue) !== -1) {
							sociogram.addPointToHull(node, hullValue);
						// }

					});
				});

			} else if (sociogram.settings.dataOrigin.Community.type === 'edge') {
				// community data is coming from an edge

			} else {
				// error!
			}
		}

	};

	sociogram.getSelectedNodes = function() {
		return selectedNodes;
	};

	sociogram.destroy = function() {
		window.removeEventListener('nodeAdded', addNodeHandler, false);
		window.removeEventListener('edgeAdded', addEdgeHandler, false);
		window.removeEventListener('nodeRemoved', sociogram.removeNode, false);
		window.removeEventListener('edgeRemoved', sociogram.removeEdge, false);
		window.removeEventListener('changeStageStart', sociogram.destroy, false);
		$(window.document).off('keypress', sociogram.keyPressHandler);
		$(window.document).off('change', '#context-checkbox-show', sociogram.toggleHulls);

	};

	sociogram.addHull = function(label) {
		note.info('Sociogram.addHull ['+label+']');
		// ignore groups that already exist
		label = label ? label : 'New Context '+$('li[data-hull]').length;
		if (typeof hullShapes[label] === 'undefined') {
			var thisHull = {};
			thisHull.label = label;
	        thisHull.hull = new ConvexHullGrahamScan();

			var color = hullColors[$('.list-group-item').length];

	        var hullShape = new Konva.Line({
	          points: [window.outerWidth/2, window.outerHeight/2],
	          fill: color,
	          opacity:0.5,
	          stroke: color,
	          lineJoin: 'round',
	          lineCap: 'round',
			  transformsEnabled: 'position',
			  hitGraphEnabled: false,
	          tension : 0.1,
	          strokeWidth: 80,
	          closed : true
	        });
			hullShapes[label] = hullShape;
			$('.context-list').append('<li class="list-group-item hull" data-hull="'+thisHull.label+'"><div class="context-color" style="background:'+color+'"></div> <span class="context-label">'+thisHull.label+'</span> <span class="pull-right fa fa-pencil"></span></li>');
			// $('.context-list').scrollTo('li[data-hull="'+thisHull.label+'"]', 500);
	        hullLayer.add(hullShapes[label]);
			hullLayer.opacity(0);
	        hullLayer.draw();

			// If the data origin is ego, also add the new hull to ego
			if (sociogram.settings.dataOrigin.Community.type === 'ego') {
				// If ego doesn't have the variable set, create it

				var properties;
				if (typeof window.network.getEgo()[sociogram.settings.dataOrigin.Community.egoVariable] === 'undefined') {
					properties = {};
					properties[sociogram.settings.dataOrigin.Community.egoVariable] = [];
					window.network.updateNode(window.network.getEgo().id, properties);
				}

				// get existing data
				var egoContexts = window.network.getEgo()[sociogram.settings.dataOrigin.Community.egoVariable];
				if (egoContexts.indexOf(thisHull.label) === -1) {
					// Update ego
					egoContexts.push(thisHull.label);
					window.netCanvas.Modules.session.saveData();
				}

			}

		}

    };

	sociogram.hullExists = function(hullLabel) {
		var found = false;
		if ($('li[data-hull="'+hullLabel+'"]').length > 0) {
			found = true;
		}
		return found;
	};

    sociogram.addPointToHull = function(point, hullLabel) {
		note.info('sociogram.addPointToHull()');
		var properties;
		// if a hull with hullLabel doesnt exist, create one
		if (!sociogram.hullExists(hullLabel)) {
			note.warn('sociogram.addPointToHull(): the hull label didn\'t exist, so a new hull was created.');
			sociogram.addHull(hullLabel);
		}

		// store properties according to data destination
		if (sociogram.settings.dataDestination.Community.type === 'node') {
			note.debug('sociogram.addPointToHull(): Storing in node mode');
			// If the point doesn't have the destination attribute, create it
			if (point.attrs[sociogram.settings.dataDestination.Community.variable] === 'undefined') {
				properties = {};
				properties[sociogram.settings.dataDestination.Community.variable] = [];
				window.network.updateNode(point.attrs.id, properties);
			}

			// Only store if the node doesn't already have the hull present
			if (point.attrs[sociogram.settings.dataDestination.Community.variable].indexOf(hullLabel) === -1) {
				// Find the node we need to store the hull value in, and update it.

				// Create a dummy object so we can use the variable name set in sociogram.settings.dataDestination
				properties = {};
				properties[sociogram.settings.dataDestination.Community.variable] = point.attrs[sociogram.settings.dataOrigin.Community.variable].concat([hullLabel]);
				point.attrs[sociogram.settings.dataOrigin.Community.variable] = point.attrs[sociogram.settings.dataOrigin.Community.variable].concat([hullLabel]);

				// Update the node with the object
				sociogram.settings.network.updateNode(point.attrs.id, properties, function() {
					note.debug('Network node updated', 1);
				});
			}

		} else if (sociogram.settings.dataDestination.Community.type === 'ego') {
			note.info('sociogram.addPointToHull(): Storing in ego mode');
			// If the point doesn't have the destination attribute, create it
			if (point.attrs[sociogram.settings.dataDestination.Community.variable] === 'undefined') {
				note.warn('Node did not have the data destinateion community attribute. A blank array was created.');
				properties = {};
				properties[sociogram.settings.dataDestination.Community.variable] = [];
				window.network.updateNode(point.attrs.id, properties);
			}
			// Only store if the node doesn't already have the hull present
			if (point.attrs[sociogram.settings.dataDestination.Community.variable].indexOf(hullLabel) === -1) {
				// Find the node we need to store the hull value in, and update it.

				// Create a dummy object so we can use the variable name set in sociogram.settings.dataDestination
				properties = {};
				properties[sociogram.settings.dataDestination.Community.variable] = point.attrs[sociogram.settings.dataOrigin.Community.variable].concat([hullLabel]);
				point.attrs[sociogram.settings.dataOrigin.Community.variable] = point.attrs[sociogram.settings.dataOrigin.Community.variable].concat([hullLabel]);

				// Update the node with the object
				sociogram.settings.network.updateNode(point.attrs.id, properties, function() {
					note.debug('Network node updated', 1);
				});
			}
		} else if (sociogram.settings.dataDestination.Position.type === 'edge') {
			// not yet implemented
		}

        // redraw all hulls begins here
        var pointHulls = point.attrs[sociogram.settings.dataOrigin.Community.variable];

		// For each hull of the current point
        for (var i = 0; i < pointHulls.length; i++) {

			// Create an empty hull
            var newHull = new ConvexHullGrahamScan();

			// For each node
            for (var j = 0; j < nodeLayer.children.length; j++) {
				var thisChildHulls = nodeLayer.children[j].attrs[sociogram.settings.dataOrigin.Community.variable];

				// Test if the current points current hull is in the current node's hull list

				if (thisChildHulls.indexOf(pointHulls[i]) !== -1) {
					// It is, so get the position of this node.
                    var coords = nodeLayer.children[j].getPosition();

					// Add it to the new hull
                    newHull.addPoint(coords.x, coords.y);
                }
            }

			// At the end of this loop we should have a newHull with points for all nodes

			// We need this check because on load all hull shapes might not be defined yet.
			if (typeof hullShapes[pointHulls[i]] !== 'undefined') {
				var tween = new Konva.Tween({
					node: hullShapes[pointHulls[i]],
					points: toPointFromObject(newHull.getHull()),
					duration: 0.5,
					onFinish: function(){
						tween.destroy();
					}
				}).play();

			}

			hullLayer.batchDraw();
            nodeLayer.draw();

        }

    };

	sociogram.redrawHulls = function() {
		for (var i = 0; i < hullShapes.length; i++) {
			var newHull = new ConvexHullGrahamScan();

			for (var j = 0; j < nodeLayer.children.length; j++) {
				var thisChildHulls = nodeLayer.children[j].attrs[sociogram.settings.dataOrigin.Community.variable];
				if (thisChildHulls.indexOf(hullShapes[i]) !== -1) {
					var coords = nodeLayer.children[j].getPosition();
					newHull.addPoint(coords.x, coords.y);
				}
			}

			hullShapes[i].setPoints(toPointFromObject(newHull.getHull()));
			hullLayer.batchDraw();

		}

	};

	sociogram.getHullShapes = function() {
		return hullShapes;
	};

	sociogram.removePointFromHull = function(point, hullLabel) {
		note.info('sociogram.removePointFromHull()');
		var properties;

		// store properties according to data destination
		if (sociogram.settings.dataDestination.Community.type === 'node') {

			// If the point doesn't have the attribute, fail
			if (point.attrs[sociogram.settings.dataDestination.Community.variable] === 'undefined') {
				note.error('sociogram.removePointFromHull(): Error! The point wasn\'t attached to a hull named '+hullLabel);
				return false;
			}

			// If the hull isnt in the node, fail
			if (point.attrs[sociogram.settings.dataDestination.Community.variable].indexOf(hullLabel) === -1) {
				note.error('sociogram.removePointFromHull(): Error! The point wasn\'t attached to a hull named '+hullLabel);
				return false;
			} else {
				// Find the node we need to store the hull value in, and update it.

				// Create a dummy object so we can use the variable name set in sociogram.settings.dataDestination
				properties = {};
				var nodePointHulls = point.attrs[sociogram.settings.dataOrigin.Community.variable];
				nodePointHulls.remove(hullLabel);
				properties[sociogram.settings.dataDestination.Community.variable] = nodePointHulls;
				point.attrs[sociogram.settings.dataOrigin.Community.variable] = nodePointHulls;

				// Update the node with the object
				sociogram.settings.network.updateNode(point.attrs.id, properties, function() {
					note.info('Network node updated', 1);
					note.debug(properties);
				});
			}

		} else if (sociogram.settings.dataDestination.Community.type === 'ego') {

			// If the point doesn't have the attribute, fail
			if (point.attrs[sociogram.settings.dataDestination.Community.variable] === 'undefined') {
				note.error('sociogram.removePointFromHull(): Error! The point wasn\'t attached to a hull named '+hullLabel);
				return false;
			}

			// If the hull isnt in the node, fail
			if (point.attrs[sociogram.settings.dataDestination.Community.variable].indexOf(hullLabel) === -1) {
				note.error('sociogram.removePointFromHull(): Error! The point wasn\'t attached to a hull named '+hullLabel);
				return false;
			} else {
				// Find the node we need to store the hull value in, and update it.

				// Create a dummy object so we can use the variable name set in sociogram.settings.dataDestination
				properties = {};
				var egoPointHulls = point.attrs[sociogram.settings.dataOrigin.Community.variable];
				egoPointHulls.remove(hullLabel);
				properties[sociogram.settings.dataDestination.Community.variable] = egoPointHulls;
				point.attrs[sociogram.settings.dataOrigin.Community.variable] = egoPointHulls;

				// Update the node with the object
				sociogram.settings.network.updateNode(point.attrs.id, properties, function() {
					note.info('Network node updated', 1);
					note.debug(properties);
				});
			}
		} else if (sociogram.settings.dataDestination.Position.type === 'edge') {
			// not yet implemented
		}


		// redraw only the hull that the node has been removed from
		// Create an empty hull
        var newHull = new ConvexHullGrahamScan();

		// For each node
        for (var j = 0; j < nodeLayer.children.length; j++) {
			var thisChildHulls = nodeLayer.children[j].attrs[sociogram.settings.dataOrigin.Community.variable];

			// Test if the current points current hull is in the current node's hull list
			if (thisChildHulls.indexOf(hullLabel) !== -1) {
				// It is, so get the position of this node.
                var coords = nodeLayer.children[j].getPosition();

				// Add it to the new hull
                newHull.addPoint(coords.x, coords.y);
            }
        }

		// At the end of this loop we should have a newHull with points for all nodes

		// We need this check because on load all hull shapes might not be defined yet.
		if (typeof hullShapes[hullLabel] !== 'undefined') {
			var tween = new Konva.Tween({
				node: hullShapes[hullLabel],
				points: toPointFromObject(newHull.getHull()),
				duration: 0.5,
				onFinish: function(){
					tween.destroy();
				}
			}).play();
		}

		hullLayer.batchDraw();
        nodeLayer.draw();


	};

	sociogram.addNode = function(options) {

		note.info('Sociogram is creating a node.');
		note.debug(options);
		// Placeholder for getting the number of nodes we have.
		var nodeShape;

		var nodeID = 0;
		while (sociogram.settings.network.getNode(nodeID) !== false) {
			nodeID++;
		}

		var dragStatus = false;
		if (sociogram.settings.modes.indexOf('Position') !== -1 || sociogram.settings.modes.indexOf('Edge') !== -1) {
			dragStatus = true;
		}

		// Try to guess at a label if one isn't provided.
		// Is there a better way of doing this?
		if (typeof options.label === 'undefined' && typeof options.nname_t0 !== 'undefined') { // for RADAR use nickname
			options.label = options.nname_t0;
		} else if (typeof options.label === 'undefined' && typeof options.name !== 'undefined'){
			options.label = options.name;
		}

		var nodeOptions = {
			id: nodeID,
			coords: [],
			positioned: false,
			label: 'Undefined',
			type: 'Person',
			transformsEnabled: 'position',
			size: sociogram.settings.options.defaultNodeSize,
			color: sociogram.settings.options.defaultNodeColor,
			strokeWidth: sociogram.settings.options.defaultNodeStrokeWidth,
			stroke: sociogram.settings.options.defaultNodeColor,
			draggable: dragStatus,
			dragDistance: 20
		};

		nodeOptions[sociogram.settings.dataOrigin.Community.variable] = [];
		window.tools.extend(nodeOptions, options);

		nodeOptions.id = parseInt(nodeOptions.id, 10);
		nodeOptions.x = nodeOptions.coords[0] ? nodeOptions.coords[0] : false;
		nodeOptions.y = nodeOptions.coords[1] ? nodeOptions.coords[1] : false;

		var nodeGroup = new Konva.Group(nodeOptions);

		var selectCircle = new Konva.Circle({
			radius: nodeOptions.size+(nodeOptions.strokeWidth*2.3),
			fill:sociogram.settings.options.defaultEdgeColor,
			transformsEnabled: 'position',
			opacity:0
		});

		nodeShape = new Konva.Circle({
			radius: nodeOptions.size,
			fill:nodeOptions.color,
			transformsEnabled: 'position',
			strokeWidth: nodeOptions.strokeWidth,
			stroke: nodeOptions.stroke
		});

		var nodeLabel = new Konva.Text({
			text: nodeOptions.label,
			// fontSize: 20,
			fontFamily: 'Lato',
			transformsEnabled: 'position',
			fill: sociogram.settings.options.defaultLabelColor,
			align: 'center',
			// offsetX: (nodeOptions.size*-1)-10, //left right
			// offsetY:(nodeOptions.size*1)-10, //up down
			fontStyle:500
		});

		note.debug('Putting node '+nodeOptions.label+' at coordinates x:'+nodeOptions.coords[0]+', y:'+nodeOptions.coords[1]);

		padText(nodeLabel,nodeShape,10);

		nodeGroup.add(selectCircle);
		nodeGroup.add(nodeShape);
		nodeGroup.add(nodeLabel);

		nodeLayer.add(nodeGroup);

		setTimeout(function() {
			nodeLayer.draw();
		}, 0);

		if (!options.coords || nodeOptions.coords.length === 0) {
			nodesWithoutPositions++;
			if (!newNodeCircleVisible) {
				newNodeCircleTween.play();
				newNodeCircleVisible = true;
			}
			nodeGroup.position({
				x: 0,
				y:$(window).height()/2
			});
			new Konva.Tween({
				node: nodeGroup,
				x: 145,
				y: $(window).height()/2,
				duration:0.7,
				easing: Konva.Easings.EaseOut
			}).play();
			// sociogram.settings.network.setProperties(sociogram.settings.network.getNode(nodeOptions.id),{coords:[$(window).width()-150, $(window).height()-150]});
		} else {

		}

		// Node event handlers
		nodeGroup.on('dragstart', function() {

			window.wedge.anim.stop();
			window.clearTimeout(longPressTimer);
			if (taskComprehended === false) {
				var eventProperties = {
					stage: window.netCanvas.Modules.session.currentStage(),
					timestamp: new Date()
				};
				log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
				window.dispatchEvent(log);
				taskComprehended = true;
			}

			note.debug('dragstart');

			// Add the current position to the node attributes, so we know where it came from when we stop dragging.
			this.attrs.oldx = this.attrs.x;
			this.attrs.oldy = this.attrs.y;
			if (this.attrs.positioned === false ) {
				this.attrs.positioned = true;
				nodesWithoutPositions--;
				if (nodesWithoutPositions < 1) {
					newNodeCircleTween.reverse();
					newNodeCircleVisible = false;
				}
			}

			this.moveToTop();
			nodeLayer.draw();

			var dragNode = nodeOptions.id;

			// Update the position of any connected edges and hulls
			var pointHulls = this.attrs[sociogram.settings.dataOrigin.Community.variable];
			for (var i = 0; i < pointHulls.length; i++) {
				var newHull = new ConvexHullGrahamScan();

				for (var j = 0; j < nodeLayer.children.length; j++) {
					var thisChildHulls = nodeLayer.children[j].attrs[sociogram.settings.dataOrigin.Community.variable];
					if (thisChildHulls.indexOf(pointHulls[i]) !== -1) {
						var coords = nodeLayer.children[j].getPosition();
						newHull.addPoint(coords.x, coords.y);
					}
				}

				hullShapes[pointHulls[i]].setPoints(toPointFromObject(newHull.getHull()));
				hullLayer.batchDraw();

			}

			$.each(edgeLayer.children, function(index, value) {

				// value.setPoints([dragNode.getX(), dragNode.getY() ]);
				if (value.attrs.from === dragNode || value.attrs.to === dragNode) {
					var points = [sociogram.getNodeByID(value.attrs.from).getX(), sociogram.getNodeByID(value.attrs.from).getY(), sociogram.getNodeByID(value.attrs.to).getX(), sociogram.getNodeByID(value.attrs.to).getY()];
					value.attrs.points = points;

				}
			});

		});

		nodeGroup.on('dragmove', function() {

			// Cancel wedge actions
			window.wedge.anim.stop();
			var tween = new Konva.Tween({
				 node: window.wedge,
				 opacity: 0,
				 duration: 0,
				 onFinish: function(){
					 tween.destroy();
				 }
			}).play();
			window.clearTimeout(longPressTimer);

			if (taskComprehended === false) {
				var eventProperties = {
					stage: window.netCanvas.Modules.session.currentStage(),
					timestamp: new Date()
				};
				log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
				window.dispatchEvent(log);
				taskComprehended = true;
			}

			note.debug('Dragmove');

			var dragNode = nodeOptions.id;
			// Update the position of any connected edges and hulls
			var pointHulls = this.attrs[sociogram.settings.dataOrigin.Community.variable];
			for (var i = 0; i < pointHulls.length; i++) {
				var newHull = new ConvexHullGrahamScan();

				for (var j = 0; j < nodeLayer.children.length; j++) {
					var thisChildHulls = nodeLayer.children[j].attrs[sociogram.settings.dataOrigin.Community.variable];
					if (thisChildHulls.indexOf(pointHulls[i]) !== -1) {
						var coords = nodeLayer.children[j].getPosition();
						newHull.addPoint(coords.x, coords.y);
					}
				}

				hullShapes[pointHulls[i]].setPoints(toPointFromObject(newHull.getHull()));
				hullLayer.batchDraw();

			}

			$.each(edgeLayer.children, function(index, value) {

				// value.setPoints([dragNode.getX(), dragNode.getY() ]);
				if (value.attrs.from === dragNode || value.attrs.to === dragNode) {
					var points = [sociogram.getNodeByID(value.attrs.from).getX(), sociogram.getNodeByID(value.attrs.from).getY(), sociogram.getNodeByID(value.attrs.to).getX(), sociogram.getNodeByID(value.attrs.to).getY()];
					value.attrs.points = points;

				}
			});
			edgeLayer.batchDraw();
		});

		nodeGroup.on('touchstart mousedown', function() {

			var currentNode = this;

			window.wedge.setAbsolutePosition(this.getAbsolutePosition());

			window.wedge.anim = new Konva.Animation(function(frame) {
				var duration = 350;
				if (frame.time >= duration) { // point of selection
					window.wedge.setAngle(360);
					currentNode.fire('longPress');
				} else {
					window.wedge.opacity(frame.time*(1/duration));
					window.wedge.setStrokeWidth(1+(frame.time*(20/duration)));
					window.wedge.setAngle(frame.time*(360/duration));
				}

			}, wedgeLayer);

			longPressTimer = setTimeout(function() {
				touchNotTap = true;
				window.wedge.anim.start();
			}, 150);

		});

		nodeGroup.on('longPress', function() {
			console.log('longpress');
			sociogram.showDetailsPanel();
			selectedNode = this;
			console.log(selectedNode);
			var currentNode = this;
			$('.hull').removeClass('active'); // deselect all groups

			// Update side panel
			$('.context-header h4').html('Details for '+currentNode.attrs.label);
			$.each(currentNode.attrs[sociogram.settings.dataOrigin.Community.variable], function(index, value) {
				$('[data-hull="'+value+'"]').addClass('active');
			});
			window.wedge.anim.stop();
			window.clearTimeout(longPressTimer);
		});

		nodeGroup.on('touchend mouseup', function() {

			window.wedge.anim.stop();
			var tween = new Konva.Tween({
				 node: window.wedge,
				 opacity: 0,
				 duration: 0.3,
				 onFinish: function(){
					 tween.destroy();
				 }
	 	 	}).play();
			window.clearTimeout(longPressTimer);
		});

		nodeGroup.on('dbltap dblclick', function() {

			selectedNodes = [];
			$.each(sociogram.getKineticNodes(), function(index, value) {
				value.children[0].opacity(0);
			});
			window.clearTimeout(tapTimer);

			if (taskComprehended === false) {
				var eventProperties = {
					stage: window.netCanvas.Modules.session.currentStage(),
					timestamp: new Date()
				};
				log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
				window.dispatchEvent(log);
				taskComprehended = true;
			}
			log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeClick', 'eventObject':this.attrs.id}});
			window.dispatchEvent(log);

			var currentNode = this;

			// if select mode enabled
			if (sociogram.settings.modes.indexOf('Select') !== -1) {

				// Select mode target (node or edge)
				if (sociogram.settings.dataDestination.Select.type === 'node') {
					// target is node

					// flip variable or create node?
					if (sociogram.settings.dataDestination.Select.mode === 'flip') {
						// flip variable

						// Get current variable value
						var properties = {};
						var currentValue = sociogram.settings.network.getNode(currentNode.attrs.id)[sociogram.settings.dataDestination.Select.flip_variable];

						// flip
						if (currentValue === 0 || typeof currentValue === 'undefined') {
							// add static variables, if present
							$.each(sociogram.settings.dataDestination.Select.variables, function(index, value) {
								properties[value.name] = value.value;
							});
							properties[sociogram.settings.dataDestination.Select.flip_variable] = 1;
							currentNode.children[1].stroke(colors.selected);
						} else {
							// remove static variables, if present
							var node = window.network.getNode(currentNode.attrs.id);
							$.each(sociogram.settings.dataDestination.Select.variables, function(index, value) {
								node[value.name] = null;
							});
							node[sociogram.settings.dataDestination.Select.flip_variable] = 0;
							currentNode.children[1].stroke(sociogram.settings.options.defaultNodeColor);
						}

						sociogram.settings.network.updateNode(currentNode.attrs.id, properties);

					} else if (sociogram.settings.dataDestination.Select.mode === 'create') {
						// create node
						note.warn('Select mode create is not implemented yet.');

					} else {
						// error state
						note.error('sociogram: Error! Didnt understand sociogram.settings.dataDestination.Select.mode');
					}
				} else if (sociogram.settings.dataDestination.Select.type === 'edge') {
					// target is edge
					note.warn('Select mode edge destination not yet implemented.');

					// flip variable or create edge?
					if (sociogram.settings.dataDestination.Select.mode === 'flip') {
						// flip variable

					} else if (sociogram.settings.dataDestination.Select.mode === 'create') {
						// create edge

						// // Test if there is an existing edge.
						// if (sociogram.settings.network.getEdges({type: sociogram.settings.edgeType,from:sociogram.settings.network.getEgo().id, to: this.attrs.to}).length > 0) {
						// 	// if there is, remove it
						// 	this.children[0].stroke('white');
						// 	sociogram.settings.network.removeEdge(sociogram.settings.network.getEdges({type: sociogram.settings.edgeType,from:sociogram.settings.network.getEgo().id, to: this.attrs.to})[0]);
						// } else {
						// 	// else add it
						// 	edge = {
						// 		from:sociogram.settings.network.getEgo().id,
						// 		to: this.attrs.to,
						// 		type: sociogram.settings.edgeType,
						// 	};
						//
						// 	if (typeof sociogram.settings.variables !== 'undefined') {
						// 		$.each(sociogram.settings.variables, function(index, value) {
						// 			edge[value.label] = value.value;
						// 		});
						// 	}
						//
						// 	this.children[0].stroke(colors.selected);
						// 	sociogram.settings.network.addEdge(edge);
						// }


					}
				}
			}
			this.moveToTop();
			nodeLayer.draw();
		});

		nodeGroup.on('tap click', function() {
			/**
			* Tap (or click when using a mouse) events on a node trigger one of two actions:
			*
			* (1) If a hull is currently selected, tapping a node will add it to the selected hull. Any other events
			* (for example edge creation) will be ignored.
			*
			* (2) If edge creation mode is enabled and there are no selected hulls, tapping a node will mark it as being selected for potential linking.
			* If the node is the first to be selected, nothing more will happen. If it is the second, an edge will be
			* created according to the edge destination settings.
			*/

			var currentNode = this; // Store the context

			if (!touchNotTap) { /** check we aren't in the middle of a touch */

				window.wedge.anim.stop(); // Cancel any existing touch hold animations

				if (tapTimer !== null) { window.clearTimeout(tapTimer); } // clear any previous tapTimer

				/** Conduct all tap actions inside a short timeout to give space for a double tap event to cancel it. */
				tapTimer = setTimeout(function(){
					window.clearTimeout(longPressTimer);
					if (taskComprehended === false) {
						var eventProperties = {
							stage: window.netCanvas.Modules.session.currentStage(),
							timestamp: new Date()
						};
						log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
						window.dispatchEvent(log);
						taskComprehended = true;
					}
					log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeClick', 'eventObject':currentNode.attrs.id}});
					window.dispatchEvent(log);

					/** Test if edge creation mode is enabled */
					if (sociogram.settings.modes.indexOf('Edge') !== -1) {

						// Ignore two clicks on the same node
						if (selectedNodes[0] === currentNode) {
							selectedNodes[0].children[0].opacity(0);
							selectedNodes = [];
							nodeLayer.draw();
							return false;
						}

						// Push the clicked node into the selected nodes array;
						selectedNodes.push(currentNode);

						// Check the length of the selected nodes array.
						if(selectedNodes.length === 2) {
							//If it containes two nodes, create an edge

							//Reset the styling
							selectedNodes[1].children[0].opacity(0);
							selectedNodes[0].children[0].opacity(0);

							// Create an edge object
							if (sociogram.settings.dataDestination.Edge.type === 'edge')   {// We are storing the edge on an edge

								var edgeProperties = {};
								if (sociogram.settings.criteria.type === 'node') {
									edgeProperties = {
										from: selectedNodes[0].attrs.id,
										to: selectedNodes[1].attrs.id,
									};
								}

								// Add the custom variables
								$.each(sociogram.settings.dataDestination.Edge.variables, function(index, value) {
									edgeProperties[value.name] = value.value;
								});

								// Try adding the edge. If it returns fals, it already exists, so remove it.
								if (sociogram.settings.network.addEdge(edgeProperties) === false) {
									note.debug('Sociogram removing edge.',2);
									sociogram.settings.network.removeEdge(sociogram.settings.network.getEdges(edgeProperties));
								} else {
									note.debug('Sociogram added edge.',2);
								}

								// Empty the selected nodes array and draw the layer.
								selectedNodes = [];
							} else if (sociogram.settings.dataDestination.Edge.type === 'node')   {// We are storing the edge as a node attribute
								window.tools.notify('Storing edges as a node attribute is not yet implemented.', 1);
							} else {
								window.tools.notify('Error with edge destination.', 1);
							}
						} else { // First node selected. Simply turn the node stroke to the selected style so we can see that it has been selected.
							currentNode.children[0].opacity(1);
						}
					}
					currentNode.moveToTop();
					nodeLayer.draw();
				}, 200);
			} else {
				touchNotTap = false;
			}

		});

		nodeGroup.on('dragend', function() {

			var dragNode = nodeOptions.id;
			// Update the position of any connected edges and hulls
			var pointHulls = this.attrs[sociogram.settings.dataOrigin.Community.variable];
			for (var i = 0; i < pointHulls.length; i++) {
				var newHull = new ConvexHullGrahamScan();

				for (var j = 0; j < nodeLayer.children.length; j++) {
					var thisChildHulls = nodeLayer.children[j].attrs[sociogram.settings.dataOrigin.Community.variable];
					if (thisChildHulls.indexOf(pointHulls[i]) !== -1) {
						var coords = nodeLayer.children[j].getPosition();
						newHull.addPoint(coords.x, coords.y);
					}
				}

				hullShapes[pointHulls[i]].setPoints(toPointFromObject(newHull.getHull()));
				hullLayer.draw();

			}

			$.each(edgeLayer.children, function(index, value) {

				// value.setPoints([dragNode.getX(), dragNode.getY() ]);
				if (value.attrs.from === dragNode || value.attrs.to === dragNode) {
					var points = [sociogram.getNodeByID(value.attrs.from).getX(), sociogram.getNodeByID(value.attrs.from).getY(), sociogram.getNodeByID(value.attrs.to).getX(), sociogram.getNodeByID(value.attrs.to).getY()];
					value.attrs.points = points;

				}
			});
			edgeLayer.draw();

			note.debug('Drag ended at x: '+this.attrs.x+' y: '+this.attrs.y);

			// set the context
			var from = {};
			var to = {};

			// Fetch old position from properties populated by dragstart event.
			from.x = this.attrs.oldx;
			from.y = this.attrs.oldy;

			to.x = this.attrs.x;
			to.y = this.attrs.y;

			this.attrs.coords = [this.attrs.x,this.attrs.y];

			// Add them to an event object for the logger.
			var eventObject = {
				from: from,
				to: to,
			};

			// Log the movement and save the graph state.
			log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeMove', 'eventObject':eventObject}});
			window.dispatchEvent(log);

			// store properties according to data destination
			if (sociogram.settings.dataDestination.Position.type === 'node') {
				// Find the node we need to store the coordinates on, and update it.

				// Create a dummy object so we can use the variable name set in sociogram.settings.dataDestination
				var properties = {};
				properties[sociogram.settings.dataDestination.Position.variable] = this.attrs.coords;

				// Update the node with the object
				sociogram.settings.network.updateNode(this.attrs.id, properties, function() {
					window.tools.notify('Network node updated', 1);
				});

			} else if (sociogram.settings.dataDestination.Position.type === 'edge') {
				// not yet implemented
			}

			// remove the attributes, just incase.
			delete this.attrs.oldx;
			delete this.attrs.oldy;

		});

		return nodeGroup;
	};

	// Edge manipulation functions

	sociogram.addEdge = function(properties) {

		// This doesn't *usually* get called directly. Rather, it responds to an event fired by the network module.

		if(typeof properties.detail !== 'undefined' && typeof properties.detail.from !== 'undefined' && properties.detail.from !== sociogram.settings.network.getEgo().id) {
			// We have been called by an event
			properties = properties.detail;
		} else if (typeof properties.from !== 'undefined' && typeof properties.to !== 'undefined' && properties.from !== sociogram.settings.network.getEgo().id) {
			// We have been called by another sociogram method
			properties = properties;
		} else {
			return false;
		}

		// ignore edges that don't match our criteria
		if (properties.type !== window.tools.getValueFromName(sociogram.settings.dataOrigin.Edge.variables, 'type')) {
			return false;
		}

		// the below won't work because we are storing the coords in an edge now...
		note.debug('Sociogram is adding an edge.');
		var toObject = sociogram.getNodeByID(properties.to);
	 	var fromObject = sociogram.getNodeByID(properties.from);
		var points = [fromObject.attrs.coords[0], fromObject.attrs.coords[1], toObject.attrs.coords[0], toObject.attrs.coords[1]];

		var edge = new Konva.Line({
			// dashArray: [10, 10, 00, 10],
			strokeWidth: 4,
			transformsEnabled: 'position',
			hitGraphEnabled: false,
			opacity:1,
			stroke: sociogram.settings.options.defaultEdgeColor,
			// opacity: 0.8,
			points: points
		});

		edge.setAttrs({
			from: properties.from,
			to: properties.to
		});

		edgeLayer.add(edge);

		setTimeout(function() {
			edgeLayer.draw();
		},0);
		nodeLayer.draw();
		note.debug('Created Edge between '+fromObject.attrs.label+' and '+toObject.attrs.label);

		return true;

	};

	sociogram.removeEdge = function(properties) {

		note.debug('sociogram.removeEdge() called.');
		if (!properties) {
			note.error('No properties passed to sociogram.removeEdge()!');
		}

		// Test if we are being called by an event, or directly
		if (typeof properties.detail !== 'undefined' && typeof properties.detail.from !== 'undefined' && properties.detail.from !== sociogram.settings.network.getEgo().id) {
			properties = properties.detail;
		}

		var toObject = properties.to;
	 	var fromObject = properties.from;

		// This function is failing because two nodes are matching below
		var found = false;
		$.each(sociogram.getKineticEdges(), function(index, value) {
			if (value !== undefined) {
				if (value.attrs.from === fromObject && value.attrs.to === toObject || value.attrs.from === toObject && value.attrs.to === fromObject ) {
					found = true;
					edgeLayer.children[index].remove();
					edgeLayer.draw();
				}
			}

		});

		if (!found) {
			note.error('sociogram.removeEdge() failed! Couldn\'t find the specified edge.');
		} else {
			return true;
		}

	};

	sociogram.removeNode = function() {
	};

	// Misc functions

	sociogram.clearGraph = function() {
		edgeLayer.removeChildren();
		edgeLayer.clear();
		nodeLayer.removeChildren();
		nodeLayer.clear();

	};

	sociogram.getStage = function() {
		return stage;
	};

	// Main initialisation functions

	sociogram.initKinetic = function () {
		// Initialise KineticJS stage
		stage = new Konva.Stage({
			container: sociogram.settings.targetEl,
			width: window.innerWidth,
			height: window.innerHeight
		});

		circleLayer = new Konva.Layer();
		hullLayer = new Konva.FastLayer();
		wedgeLayer = new Konva.FastLayer();
		nodeLayer = new Konva.Layer();
		edgeLayer = new Konva.FastLayer();

		/**
		* This hack allows us to detect clicks that happen outside of nodes, hulls, or edges.
		* We create a transparent rectangle on a special background layer which sits between the UI layer and the interaction layers.
		* We then listen to click events on this shape.
 		*/
		var backgroundLayer = new Konva.Layer();
		var backgroundRect = new Konva.Rect({
	        x: 0,
	        y: 0,
	        width: stage.width(),
	        height: stage.height(),
	        fill: 'transparent',
	      });
		backgroundLayer.add(backgroundRect);
		backgroundRect.on('tap click', function() {
			sociogram.hideDetailsPanel();
			selectedNode = null;
			$('.hull').removeClass('active'); // deselect all groups

			//deselect Nodes
			selectedNodes = [];
			$.each(sociogram.getKineticNodes(), function(nodesIndex, nodesValue) {
				nodesValue.children[0].opacity(0);
			});

			nodeLayer.draw();

		});

		stage.add(circleLayer);
		stage.add(backgroundLayer);
		stage.add(hullLayer);
		stage.add(edgeLayer);
		stage.add(wedgeLayer);
		stage.add(nodeLayer);

		note.debug('Konva stage initialised.');

	};

	sociogram.showDetailsPanel = function() {
		$('.details-panel').addClass('show');
	};

	sociogram.hideDetailsPanel = function() {
		$('.details-panel').removeClass('show');
	};

	sociogram.generateHull = function(points) {

        var newHull = new ConvexHullGrahamScan();

        for (var i = 0; i < points.length; i++) {
            var coords = points[i].getPosition();
            newHull.addPoint(coords.x, coords.y);
        }

		return toPointFromObject(newHull.getHull());


	};

	sociogram.drawUIComponents = function (callback) {

		// Load the image
		var imageObj = new Image();
		imageObj.src = 'img/drag-text.png';
		imageObj.onload = function() {

			// New node button
			$('#'+sociogram.settings.targetEl).append('<div class="new-node-button text-center"><span class="fa fa-2x fa-plus"></span></div>');
			var events = [{
				event: 'click',
				handler: window.forms.nameGenForm.show,
				targetEl:  '.new-node-button'
			}, {
				event: 'click',
				handler: hullListClickHandler,
				targetEl:  window.document,
				subTarget:  '.list-group-item',
			}
		];
			window.tools.Events.register(moduleEvents, events);

			// Draw all UI components
			var previousSkew = 0;
			var circleFills, circleLines;
			var currentColor = sociogram.settings.options.concentricCircleColor;
			var totalHeight = window.innerHeight-(sociogram.settings.options.defaultNodeSize); // Our sociogram area is the window height minus twice the node radius (for spacing)
			var currentOpacity = 0.1;

			//draw concentric circles
			for(var i = 0; i < sociogram.settings.options.concentricCircleNumber; i++) {
				var ratio = (1-(i/sociogram.settings.options.concentricCircleNumber));
				var skew = i > 0 ? (ratio * 5) * (totalHeight/70) : 0;
				var currentRadius = totalHeight/2 * ratio;
				currentRadius = sociogram.settings.options.concentricCircleSkew? currentRadius + skew + previousSkew : currentRadius;
				previousSkew = skew;
				circleLines = new Konva.Circle({
					x: window.innerWidth / 2,
					y: window.innerHeight / 2,
					radius: currentRadius,
					hitGraphEnabled: false,
					stroke: 'white',
					strokeWidth: 1.5,
					opacity: 0
				});

				circleFills = new Konva.Circle({
					x: window.innerWidth / 2,
					y: (window.innerHeight / 2),
					radius: currentRadius,
					fill: currentColor,
					hitGraphEnabled: false,
					opacity: currentOpacity,
					strokeWidth: 0,
				});

				// currentColor = tinycolor.darken(currentColor, amount = 15).toHexString();
				currentOpacity = currentOpacity+((0.3-currentOpacity)/sociogram.settings.options.concentricCircleNumber);
				circleLayer.add(circleFills);
				circleLayer.add(circleLines);

			}

			// Node container
			var newNodeCircle = new Konva.Circle({
				radius: 60,
				transformsEnabled: 'none',
				hitGraphEnabled: false,
				stroke: 'white',
				strokeWidth: 7
			});

			// var newNodeText = new Konva.Text({
			// 	text: 'Need Positioning',
			// 	align: 'center',
			// 	offset: {x:55,y:100},
			// 	fontSize: 15,
			// 	fontFamily: 'Helvetica',
			// 	fill: 'white'
			//  });



			var newNodeText = new Konva.Image({
			 x: -20,
			 y: -180,
			 image: imageObj,
			 width: 200,
			 height: 105
			});

			// add the shape to the layer

			var newNodeCircleGroup = new Konva.Group({
			 x: 145,
			 opacity:0,
			 y: window.innerHeight / 2,
			});

			newNodeCircleGroup.add(newNodeText);
			newNodeCircleGroup.add(newNodeCircle);
			circleLayer.add(newNodeCircleGroup);

			newNodeCircleTween = new Konva.Tween({
			 node: newNodeCircleGroup,
			 opacity: 1,
			 duration: 1
			});


			// Draw 'me'
			if (sociogram.settings.options.showMe === true) {

				var meCircle = new Konva.Circle({
					radius: 50,
					x: window.innerWidth / 2,
					y: window.innerHeight / 2,
					hitGraphEnabled: false,
					fill: '#D0D2DC',
				});

				var meText = new Konva.Text({
					x: window.innerWidth / 2,
					y: window.innerHeight / 2,
					text: 'me',
					align: 'center',
					offset: {x:28,y:22},
					fontSize: 40,
					fontFamily: 'Helvetica',
					fill: 'black'
				 });
				circleLayer.add(meCircle);
				circleLayer.add(meText);
			}

			// draw wedgex

			Konva.selectWedge = function(config) {
				this._initselectWedge(config);
			};

			Konva.selectWedge.prototype = {
				_initselectWedge: function(config) {
					Konva.Circle.call(this, config);
				},
				_sceneFunc: function(context) {
					context.beginPath();
					context.arc(0, 0, this.getRadius(), 0, Konva.getAngle(this.getAngle()), this.getClockwise());
					context.fillStrokeShape(this);
				}
			};

			Konva.Util.extend(Konva.selectWedge, Konva.Wedge);

			window.wedge = new Konva.selectWedge({
				radius: sociogram.settings.options.defaultNodeSize+5,
				angle: 0,
				fill: 'transparent',
				stroke: colors.selected,
				rotation:-90,
				opacity:0,
				strokeWidth: 10,
			});

			wedgeLayer.add(window.wedge);
			window.wedge.moveToBottom();

			circleLayer.draw();

			note.debug('User interface initialised.');

			if (callback) {
				callback();
			}
		};
	};

	// Get & set functions

	sociogram.getKineticNodes = function() {
		return nodeLayer.children;
	};

	sociogram.getKineticEdges = function() {
		return edgeLayer.children;
	};

	sociogram.getSimpleNodes = function() {
		// We need to create a simple representation of the nodes for storing.
		var simpleNodes = {};
		var nodes = sociogram.getKineticNodes();
		$.each(nodes, function (index, value) {
			simpleNodes[value.attrs.id] = {};
			simpleNodes[value.attrs.id].x = value.attrs.x;
			simpleNodes[value.attrs.id].y = value.attrs.y;
			simpleNodes[value.attrs.id].name = value.attrs.name;
			simpleNodes[value.attrs.id].type = value.attrs.type;
			simpleNodes[value.attrs.id].size = value.attrs.size;
			simpleNodes[value.attrs.id].color = value.attrs.color;
		});
		return simpleNodes;
	};

	sociogram.getSimpleEdges = function() {
		var simpleEdges = {},
		edgeCounter = 0;

		$.each(edgeLayer.children, function(index, value) {
			simpleEdges[edgeCounter] = {};
			simpleEdges[edgeCounter].from = value.attrs.from.attrs.id;
			simpleEdges[edgeCounter].to = value.attrs.to.attrs.id;
			edgeCounter++;
		});

		return simpleEdges;
	};

	sociogram.getSimpleEdge = function(id) {
		var simpleEdges = sociogram.getSimpleEdges();
		if (!id) { return false; }

		var simpleEdge = simpleEdges[id];
		return simpleEdge;
	};

	sociogram.getEdgeLayer = function() {
		return edgeLayer;
	};

	sociogram.getNodeLayer = function() {
		return nodeLayer;
	};

	sociogram.getUILayer = function() {
		return uiLayer;
	};

	sociogram.getHullLayer = function() {
			return hullLayer;
	};

	sociogram.getNodeByID = function(id) {
		var node = {},
		nodes = sociogram.getKineticNodes();

		$.each(nodes, function(index, value) {
			if (value.attrs.id === id) {
				node = value;
			}
		});

		return node;
	};

	sociogram.getNodeColorByType = function(type) {
		var returnVal = null;
		$.each(sociogram.settings.nodeTypes, function(index, value) {
			if (value.name === type) {returnVal = value.color;}
		});

		if (returnVal) {
			return returnVal;
		} else {
			return false;
		}
	};

	return sociogram;

};
;/* global Konva, window, $, note, Swiper */
/* exported Sociogram */
/*jshint bitwise: false*/

module.exports = function SociogramMissing() {
	'use strict';
	// Global variables
	var stage = {}, circleLayer = {}, edgeLayer = {}, nodeLayer = {}, uiLayer = {}, sociogramMissing = {};
	var moduleEvents = [], selectedNodes = [];
	var selectedNode = null;
	var newNodeCircleTween, promptSwiper, log, tapTimer;
	var nodesWithoutPositions = 0, currentPrompt = 0;
	var taskComprehended  = false;

	// Colours
	var colors = {
		blue: '#0174DF',
		tomato: '#FF6347',
		teal: '#008080',
		hullpurple: '#9a208e',
		freesia: '#ffd600',
		hullgreen: '#6ac14c',
		cayenne: '#c40000',
		placidblue: '#83b5dd',
		violettulip: '#9B90C8',
		hemlock: '#9eccb3',
		paloma: '#aab1b0',
		sand: '#ceb48d',
		dazzlingblue: '#006bb6',
		edge: '#dd393a',
		selected: '#ffbf00',
	};

	// Default settings
	var settings = {
		options: {
			defaultNodeSize: 30,
			defaultNodeColor: 'white',
			defaultNodeStrokeWidth: 4,
			defaultLabelColor: 'black',
			defaultEdgeColor: colors.edge,
			concentricCircleColor: '#ffffff',
			concentricCircleNumber: 4,
			concentricCircleSkew: false,
			showMe: true
		}
	};

	// Private functions

	// Adjusts the size of text so that it will always fit inside a given shape.
	function padText(text, container, amount){
		while ((text.width() * 1.1)<container.width()-(amount*2)) {
			text.fontSize(text.fontSize() * 1.1);
			text.y((container.height() - text.height())/2);
		}
		text.setX( container.getX() - text.getWidth()/2 );
		text.setY( (container.getY() - text.getHeight()/1.8) );
	}

	function addNodeHandler(e) {
		sociogramMissing.addNode(e.detail);
	}

	function hullListClickHandler(e) {
		var clicked = $(e.target).closest('li');
		var selectedHull = clicked.data('hull');
		if (selectedNode.attrs.contexts.indexOf(selectedHull) !== -1 ) {
			clicked.removeClass('active');
			sociogramMissing.removePointFromHull(selectedNode, selectedHull);
		} else {
			clicked.addClass('active');
			sociogramMissing.addPointToHull(selectedNode, selectedHull);
		}
	}

	function groupButtonClickHandler() {
		sociogramMissing.addHull();
	}

	sociogramMissing.changeData = function() {
		sociogramMissing.resetNodeState();
		sociogramMissing.updateNodeState();
	};

	sociogramMissing.init = function (userSettings) {

		note.info('SociogramMissing initialising.');

		$.extend(true, settings,userSettings);
		// Add the title and heading
		$('<div class="sociogram-title"></div>').insertBefore('#'+settings.targetEl );

		$('.sociogram-title').append('<div class="swiper-container"><div class="swiper-wrapper"></div><div class="swiper-pagination"></div></div>');
        for (var i = 0; i < settings.prompts.length; i++) {
            $('.swiper-wrapper').append('<div class="swiper-slide"><h4>'+settings.prompts[i].prompt+'</h4></div>');
        }

        promptSwiper = new Swiper ('.swiper-container', {
            pagination: '.swiper-pagination',
			paginationClickable: true,
            speed: 1000
        });

        // Update current prompt counter
        promptSwiper.on('slideChangeEnd', function () {
            currentPrompt = promptSwiper.activeIndex;
            sociogramMissing.changeData();
        });

		// Initialise the konva stage
		sociogramMissing.initKinetic();

		// Draw ui compoennts
		sociogramMissing.drawUIComponents(function() {

			sociogramMissing.addNodeData();

			// Add the evevent listeners
			window.addEventListener('nodeAdded', addNodeHandler, false);
			window.addEventListener('edgeAdded', sociogramMissing.updateNodeState, false);
			window.addEventListener('nodeRemoved', sociogramMissing.removeNode, false);
			window.addEventListener('edgeRemoved', sociogramMissing.removeEdge, false);
			window.addEventListener('changeStageStart', sociogramMissing.destroy, false);
			$(window.document).on('change', '#context-checkbox-show', sociogramMissing.toggleHulls);
			$(window.document).on('click', '.new-group-button', groupButtonClickHandler);

			// Update initial states of all nodes and edges;
			sociogramMissing.updateNodeState();

		});
	};

	sociogramMissing.addNodeData = function() {

		var criteriaNodes = settings.network.getNodes({}, function (results) {
			var filteredResults = [];
			$.each(results, function(index,value) {
				if (value.type !== 'Ego') {
					filteredResults.push(value);
				}
			});

			return filteredResults;
		});

		for (var j = 0; j < criteriaNodes.length; j++) {
			sociogramMissing.addNode(criteriaNodes[j]);
		}

		// Layout Mode
		var layoutNodes = sociogramMissing.getKineticNodes();
		$.each(layoutNodes, function(index,node) {
			node.setPosition(node.attrs.coords);
		});

	};

	sociogramMissing.resetNodeState = function() {

		// Reset select
		var kineticNodes = sociogramMissing.getKineticNodes();
		$.each(kineticNodes, function(nodeIndex, nodeValue) {
			nodeValue.children[1].stroke(settings.options.defaultNodeColor);
		});

		nodeLayer.batchDraw();

		// Reset edges
		edgeLayer.removeChildren();
		edgeLayer.batchDraw();

	};

	sociogramMissing.updateNodeState = function() {
		/**
		* Updates visible attributes based on current prompt task
		*/

		var selectNodes = settings.network.getNodes();
		$.each(selectNodes, function(index, node) {
			var currentValue = node[settings.prompts[currentPrompt].variable];
			if (currentValue) {
				// this node is selected
				var currentNode = sociogramMissing.getNodeByID(node.id);
				currentNode.children[1].stroke(colors.selected);
			}
		});

		nodeLayer.draw();


	};

	sociogramMissing.getSelectedNodes = function() {
		return selectedNodes;
	};

	sociogramMissing.destroy = function() {
		window.removeEventListener('nodeAdded', addNodeHandler, false);
		window.removeEventListener('edgeAdded', sociogramMissing.updateNodeState, false);
		window.removeEventListener('nodeRemoved', sociogramMissing.removeNode, false);
		window.removeEventListener('edgeRemoved', sociogramMissing.removeEdge, false);
		window.removeEventListener('changeStageStart', sociogramMissing.destroy, false);
		$(window.document).off('keypress', sociogramMissing.keyPressHandler);
		$(window.document).off('change', '#context-checkbox-show', sociogramMissing.toggleHulls);

	};

	sociogramMissing.addNode = function(options) {

		note.info('Sociogram is creating a node.');
		note.debug(options);
		// Placeholder for getting the number of nodes we have.
		var nodeShape;

		var nodeID = 0;
		while (settings.network.getNode(nodeID) !== false) {
			nodeID++;
		}

		var dragStatus = false;

		// Try to guess at a label if one isn't provided.
		// Is there a better way of doing this?
		if (typeof options.label === 'undefined' && typeof options.nname_t0 !== 'undefined') { // for RADAR use nickname
			options.label = options.nname_t0;
		} else if (typeof options.label === 'undefined' && typeof options.name !== 'undefined'){
			options.label = options.name;
		}

		var nodeOptions = {
			id: nodeID,
			coords: [],
			positioned: false,
			label: 'Undefined',
			type: 'Person',
			transformsEnabled: 'position',
			size: settings.options.defaultNodeSize,
			color: settings.options.defaultNodeColor,
			strokeWidth: settings.options.defaultNodeStrokeWidth,
			stroke: settings.options.defaultNodeColor,
			draggable: dragStatus,
			dragDistance: 20
		};

		nodeOptions.contexts = [];
		window.tools.extend(nodeOptions, options);

		nodeOptions.id = parseInt(nodeOptions.id, 10);
		nodeOptions.x = nodeOptions.coords[0] ? nodeOptions.coords[0] : false;
		nodeOptions.y = nodeOptions.coords[1] ? nodeOptions.coords[1] : false;

		var nodeGroup = new Konva.Group(nodeOptions);

		var selectCircle = new Konva.Circle({
			radius: nodeOptions.size+(nodeOptions.strokeWidth*2.3),
			fill:settings.options.defaultEdgeColor,
			transformsEnabled: 'position',
			opacity:0
		});

		nodeShape = new Konva.Circle({
			radius: nodeOptions.size,
			fill:nodeOptions.color,
			transformsEnabled: 'position',
			strokeWidth: nodeOptions.strokeWidth,
			stroke: nodeOptions.stroke
		});

		var nodeLabel = new Konva.Text({
			text: nodeOptions.label,
			// fontSize: 20,
			fontFamily: 'Lato',
			transformsEnabled: 'position',
			fill: settings.options.defaultLabelColor,
			align: 'center',
			// offsetX: (nodeOptions.size*-1)-10, //left right
			// offsetY:(nodeOptions.size*1)-10, //up down
			fontStyle:500
		});

		note.debug('Putting node '+nodeOptions.label+' at coordinates x:'+nodeOptions.coords[0]+', y:'+nodeOptions.coords[1]);

		padText(nodeLabel,nodeShape,10);

		nodeGroup.add(selectCircle);
		nodeGroup.add(nodeShape);
		nodeGroup.add(nodeLabel);

		nodeLayer.add(nodeGroup);

		setTimeout(function() {
			nodeLayer.draw();
		}, 0);

		if (!options.coords || nodeOptions.coords.length === 0) {
			nodesWithoutPositions++;

			nodeGroup.position({
				x: 0,
				y:$(window).height()/2
			});
			new Konva.Tween({
				node: nodeGroup,
				x: 145,
				y: $(window).height()/2,
				duration:0.7,
				easing: Konva.Easings.EaseOut
			}).play();
			// settings.network.setProperties(settings.network.getNode(nodeOptions.id),{coords:[$(window).width()-150, $(window).height()-150]});
		} else {

		}

		nodeGroup.on('dbltap dblclick', function() {

			selectedNodes = [];
			// var kineticNodes = sociogramMissing.getKineticNodes();
			// $.each(kineticNodes, function(index, value) {
			// 	value.children[0].opacity(0);
			// });
			window.clearTimeout(tapTimer);

			if (taskComprehended === false) {
				var eventProperties = {
					stage: window.netCanvas.Modules.session.currentStage(),
					timestamp: new Date()
				};
				log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
				window.dispatchEvent(log);
				taskComprehended = true;
			}
			log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeClick', 'eventObject':this.attrs.id}});
			window.dispatchEvent(log);

			var currentNode = this;
			// flip variable

			// Get current variable value
			var properties = {};
			var currentValue = settings.network.getNode(currentNode.attrs.id)[settings.prompts[currentPrompt].variable];
			// flip
			if (!currentValue || typeof currentValue === 'undefined') {
				properties[settings.prompts[currentPrompt].variable] = 'true';
				currentNode.children[1].stroke(colors.selected);
			} else {
				// remove static variables, if present
				var node = window.network.getNode(currentNode.attrs.id);
				node[settings.prompts[currentPrompt].variable] = 0;
				currentNode.children[1].stroke(settings.options.defaultNodeColor);
			}

			settings.network.updateNode(currentNode.attrs.id, properties);

			this.moveToTop();
			nodeLayer.draw();
		});

		return nodeGroup;
	};

	// Edge manipulation functions

	sociogramMissing.addEdge = function(properties) {

		// This doesn't *usually* get called directly. Rather, it responds to an event fired by the network module.

		if(typeof properties.detail !== 'undefined' && typeof properties.detail.from !== 'undefined' && properties.detail.from !== settings.network.getEgo().id) {
			// We have been called by an event
			properties = properties.detail;
		} else if (typeof properties.from !== 'undefined' && typeof properties.to !== 'undefined' && properties.from !== settings.network.getEgo().id) {
			// We have been called by another sociogram method
			properties = properties;
		} else {
			return false;
		}

		// the below won't work because we are storing the coords in an edge now...
		note.debug('Sociogram is adding an edge.');
		var toObject = sociogramMissing.getNodeByID(properties.to);
	 	var fromObject = sociogramMissing.getNodeByID(properties.from);
		var points = [fromObject.attrs.coords[0], fromObject.attrs.coords[1], toObject.attrs.coords[0], toObject.attrs.coords[1]];

		var edge = new Konva.Line({
			// dashArray: [10, 10, 00, 10],
			strokeWidth: 4,
			transformsEnabled: 'position',
			hitGraphEnabled: false,
			opacity:1,
			stroke: settings.options.defaultEdgeColor,
			// opacity: 0.8,
			points: points
		});

		edge.setAttrs({
			from: properties.from,
			to: properties.to
		});

		edgeLayer.add(edge);

		setTimeout(function() {
			edgeLayer.draw();
		},0);
		nodeLayer.draw();
		note.debug('Created Edge between '+fromObject.attrs.label+' and '+toObject.attrs.label);

		return true;

	};

	sociogramMissing.removeEdge = function(properties) {

		note.debug('sociogramMissing.removeEdge() called.');
		if (!properties) {
			note.error('No properties passed to sociogramMissing.removeEdge()!');
		}

		// Test if we are being called by an event, or directly
		if (typeof properties.detail !== 'undefined' && typeof properties.detail.from !== 'undefined' && properties.detail.from !== settings.network.getEgo().id) {
			properties = properties.detail;
		}

		var toObject = properties.to;
	 	var fromObject = properties.from;

		// This function is failing because two nodes are matching below
		var found = false;
		$.each(sociogramMissing.getKineticEdges(), function(index, value) {
			if (value !== undefined) {
				if (value.attrs.from === fromObject && value.attrs.to === toObject || value.attrs.from === toObject && value.attrs.to === fromObject ) {
					found = true;
					edgeLayer.children[index].remove();
					edgeLayer.draw();
				}
			}

		});

		if (!found) {
			note.error('sociogramMissing.removeEdge() failed! Couldn\'t find the specified edge.');
		} else {
			return true;
		}

	};

	sociogramMissing.removeNode = function() {
	};

	// Misc functions

	sociogramMissing.clearGraph = function() {
		edgeLayer.removeChildren();
		edgeLayer.clear();
		nodeLayer.removeChildren();
		nodeLayer.clear();

	};

	sociogramMissing.getStage = function() {
		return stage;
	};

	// Main initialisation functions

	sociogramMissing.initKinetic = function () {
		// Initialise KineticJS stage
		stage = new Konva.Stage({
			container: settings.targetEl,
			width: window.innerWidth,
			height: window.innerHeight
		});

		circleLayer = new Konva.Layer();
		nodeLayer = new Konva.Layer();
		edgeLayer = new Konva.FastLayer();

		/**
		* This hack allows us to detect clicks that happen outside of nodes, hulls, or edges.
		* We create a transparent rectangle on a special background layer which sits between the UI layer and the interaction layers.
		* We then listen to click events on this shape.
 		*/
		stage.add(circleLayer);
		stage.add(edgeLayer);
		stage.add(nodeLayer);

		note.debug('Konva stage initialised.');

	};

	sociogramMissing.drawUIComponents = function (callback) {

		// New node button
		$('#'+settings.targetEl).append('<div class="new-node-button text-center"><span class="fa fa-2x fa-plus"></span></div>');
		var events = [{
				event: 'click',
				handler: sociogramMissing.showNewNodeForm,
				targetEl:  '.new-node-button'
			}, {
				event: 'click',
				handler: hullListClickHandler,
				targetEl:  window.document,
				subTarget:  '.list-group-item',
			},
			{
				event: 'submit',
				handler: function() {
					setTimeout(function() {
						sociogramMissing.updateNodeState();
					},100);
				},
				targetEl: window.document,
				subtarget: window.forms.nameGenForm.getID()
			}
		];
		window.tools.Events.register(moduleEvents, events);

		// Draw all UI components
		var previousSkew = 0;
		var circleFills, circleLines;
		var currentColor = settings.options.concentricCircleColor;
		var totalHeight = window.innerHeight-(settings.options.defaultNodeSize); // Our sociogram area is the window height minus twice the node radius (for spacing)
		var currentOpacity = 0.1;

		//draw concentric circles
		for(var i = 0; i < settings.options.concentricCircleNumber; i++) {
			var ratio = (1-(i/settings.options.concentricCircleNumber));
			var skew = i > 0 ? (ratio * 5) * (totalHeight/70) : 0;
			var currentRadius = totalHeight/2 * ratio;
			currentRadius = settings.options.concentricCircleSkew? currentRadius + skew + previousSkew : currentRadius;
			previousSkew = skew;
			circleLines = new Konva.Circle({
				x: window.innerWidth / 2,
				y: window.innerHeight / 2,
				radius: currentRadius,
				hitGraphEnabled: false,
				stroke: 'white',
				strokeWidth: 1.5,
				opacity: 0
			});

			circleFills = new Konva.Circle({
				x: window.innerWidth / 2,
				y: (window.innerHeight / 2),
				radius: currentRadius,
				fill: currentColor,
				hitGraphEnabled: false,
				opacity: currentOpacity,
				strokeWidth: 0,
			});

			// currentColor = tinycolor.darken(currentColor, amount = 15).toHexString();
			currentOpacity = currentOpacity+((0.3-currentOpacity)/settings.options.concentricCircleNumber);
			circleLayer.add(circleFills);
			circleLayer.add(circleLines);

		}

		// Node container
		var newNodeCircle = new Konva.Circle({
			radius: 60,
			transformsEnabled: 'none',
			hitGraphEnabled: false,
			stroke: 'white',
			strokeWidth: 7
		});

		// add the shape to the layer

		var newNodeCircleGroup = new Konva.Group({
		 x: 145,
		 opacity:0,
		 y: window.innerHeight / 2,
		});

		newNodeCircleGroup.add(newNodeCircle);
		circleLayer.add(newNodeCircleGroup);

		newNodeCircleTween = new Konva.Tween({
		 node: newNodeCircleGroup,
		 opacity: 1,
		 duration: 1
		});

		// Draw 'me'
		if (settings.options.showMe === true) {

			var meCircle = new Konva.Circle({
				radius: 50,
				x: window.innerWidth / 2,
				y: window.innerHeight / 2,
				hitGraphEnabled: false,
				fill: '#D0D2DC',
			});

			var meText = new Konva.Text({
				x: window.innerWidth / 2,
				y: window.innerHeight / 2,
				text: 'me',
				align: 'center',
				offset: {x:28,y:22},
				fontSize: 40,
				fontFamily: 'Helvetica',
				fill: 'black'
			 });
			circleLayer.add(meCircle);
			circleLayer.add(meText);
		}

		circleLayer.draw();

		note.debug('User interface initialised.');

		if (callback) {
			callback();
		}
	};

	// Get & set functions

	sociogramMissing.getKineticNodes = function() {
		return nodeLayer.children;
	};

	sociogramMissing.getKineticEdges = function() {
		return edgeLayer.children;
	};

	sociogramMissing.getSimpleNodes = function() {
		// We need to create a simple representation of the nodes for storing.
		var simpleNodes = {};
		var nodes = sociogramMissing.getKineticNodes();
		$.each(nodes, function (index, value) {
			simpleNodes[value.attrs.id] = {};
			simpleNodes[value.attrs.id].x = value.attrs.x;
			simpleNodes[value.attrs.id].y = value.attrs.y;
			simpleNodes[value.attrs.id].name = value.attrs.name;
			simpleNodes[value.attrs.id].type = value.attrs.type;
			simpleNodes[value.attrs.id].size = value.attrs.size;
			simpleNodes[value.attrs.id].color = value.attrs.color;
		});
		return simpleNodes;
	};

	sociogramMissing.getSimpleEdges = function() {
		var simpleEdges = {},
		edgeCounter = 0;

		$.each(edgeLayer.children, function(index, value) {
			simpleEdges[edgeCounter] = {};
			simpleEdges[edgeCounter].from = value.attrs.from.attrs.id;
			simpleEdges[edgeCounter].to = value.attrs.to.attrs.id;
			edgeCounter++;
		});

		return simpleEdges;
	};

	sociogramMissing.getSimpleEdge = function(id) {
		var simpleEdges = sociogramMissing.getSimpleEdges();
		if (!id) { return false; }

		var simpleEdge = simpleEdges[id];
		return simpleEdge;
	};

	sociogramMissing.getEdgeLayer = function() {
		return edgeLayer;
	};

	sociogramMissing.getNodeLayer = function() {
		return nodeLayer;
	};

	sociogramMissing.getUILayer = function() {
		return uiLayer;
	};

	sociogramMissing.getNodeByID = function(id) {
		var node = {},
		nodes = sociogramMissing.getKineticNodes();

		$.each(nodes, function(index, value) {
			if (value.attrs.id === id) {
				node = value;
			}
		});

		return node;
	};

	sociogramMissing.getNodeColorByType = function(type) {
		var returnVal = null;
		$.each(settings.nodeTypes, function(index, value) {
			if (value.name === type) {returnVal = value.color;}
		});

		if (returnVal) {
			return returnVal;
		} else {
			return false;
		}
	};

	return sociogramMissing;

};
;/* global Konva, window, $, note, ConvexHullGrahamScan, Image, Swiper */
/* exported Sociogram */
/*jshint bitwise: false*/

module.exports = function SociogramMulti() {
	'use strict';
	// Global variables
	var stage = {}, circleLayer = {}, edgeLayer = {}, nodeLayer = {}, wedgeLayer = {}, hullLayer = {}, hullShapes = {}, uiLayer = {}, sociogramMulti = {};
	var moduleEvents = [], selectedNodes = [];
	var selectedNode = null;
	var newNodeCircleTween, promptSwiper, log, longPressTimer, tapTimer;
	var nodesWithoutPositions = 0, currentPrompt = 0;
	var newNodeCircleVisible = false, hullsShown = false, taskComprehended = false, touchNotTap = false;

	// Colours
	var colors = {
		blue: '#0174DF',
		tomato: '#FF6347',
		teal: '#008080',
		hullpurple: '#9a208e',
		freesia: '#ffd600',
		hullgreen: '#6ac14c',
		cayenne: '#c40000',
		placidblue: '#83b5dd',
		violettulip: '#9B90C8',
		hemlock: '#9eccb3',
		paloma: '#aab1b0',
		sand: '#ceb48d',
		dazzlingblue: '#006bb6',
		edge: '#dd393a',
		selected: '#ffbf00',
	};

	var hullColors = ['#01a6c7','#1ECD97', '#B16EFF','#FA920D','#e85657','Gold','Pink','Saddlebrown','Teal','Silver'];

	// Default settings
	var settings = {
		network: window.netCanvas.Modules.session.getPrimaryNetwork(),
		targetEl: 'kineticCanvas',
		// consecutive single tap - edge mode
		// drag - layout mode
		// double tap - select mode
		// long press - community mode
		modes:['Position'], //edge - create edges, position - lay out, select - node attributes
	    panels: ['details'], // Mode - switch between modes, Details - long press shows node details
		options: {
			defaultNodeSize: 29,
			defaultNodeColor: 'white',
			defaultNodeStrokeWidth: 7,
			defaultLabelColor: 'black',
			defaultEdgeColor: colors.edge,
			concentricCircleColor: '#ffffff',
			concentricCircleNumber: 4,
			concentricCircleSkew: false,
			showMe: true
		},
		dataOrigin: {
			'Position': {
				type: 'node',
				variable: 'coords'
			},
			'Community' : {
				type: 'ego',
				name: 'Groups',
				egoVariable: 'contexts',
				variable: 'contexts'
			}
		},
		prompts: [],
	    criteria: { // criteria for being shown on this screen
	        includeEgo: false,
	        query: {
	        }
	    }
	};

	// Private functions

	// Adjusts the size of text so that it will always fit inside a given shape.
	function padText(text, container, amount){
		while ((text.width() * 1.1)<container.width()-(amount*2)) {
			text.fontSize(text.fontSize() * 1.1);
			text.y((container.height() - text.height())/2);
		}
		text.setX( container.getX() - text.getWidth()/2 );
		text.setY( (container.getY() - text.getHeight()/1.8) );
	}

	function toPointFromObject(array) {
		var newArray = [];
		for (var i = 0; i<array.length; i++) {
			newArray.push(array[i].x);
			newArray.push(array[i].y);
		}

		return newArray;
	}

	function addNodeHandler(e) {
		sociogramMulti.addNode(e.detail);
	}

	function hullListClickHandler(e) {
		console.log('hullListClickHandler');
		console.log(e);
		var _this = this;
		console.log(_this);
		var clicked = $(e.target).closest('li');
		console.log(clicked);
		var selectedHull = clicked.data('hull');
		console.log(selectedHull);
		if (selectedNode.attrs.contexts.indexOf(selectedHull) !== -1 ) {
			clicked.removeClass('active');
			sociogramMulti.removePointFromHull(selectedNode, selectedHull);
		} else {
			clicked.addClass('active');
			sociogramMulti.addPointToHull(selectedNode, selectedHull);
		}
	}

	function groupButtonClickHandler() {
		sociogramMulti.addHull();
	}

	sociogramMulti.changeData = function() {
		sociogramMulti.resetNodeState();
		sociogramMulti.updateNodeState();
	};

	sociogramMulti.init = function (userSettings) {

		note.info('SociogramMulti initialising.');

		$.extend(true, settings,userSettings);
		// Add the title and heading
		$('<div class="sociogram-title"></div>').insertBefore('#'+settings.targetEl );

		$('.sociogram-title').append('<div class="swiper-container"><div class="swiper-wrapper"></div><div class="swiper-pagination"></div></div>');
        for (var i = 0; i < settings.prompts.length; i++) {
            $('.swiper-wrapper').append('<div class="swiper-slide"><h4>'+settings.prompts[i].prompt+'</h4></div>');
        }

        promptSwiper = new Swiper ('.swiper-container', {
            pagination: '.swiper-pagination',
			paginationClickable: true,
            speed: 1000
        });

        // Update current prompt counter
        promptSwiper.on('slideChangeEnd', function () {
            currentPrompt = promptSwiper.activeIndex;
            sociogramMulti.changeData();
        });

		// Initialise the konva stage
		sociogramMulti.initKinetic();

		// Draw ui compoennts
		sociogramMulti.drawUIComponents(function() {

			// Show hulls checkbox
			if (settings.modes.indexOf('Community') !== -1) {
				$('#'+settings.targetEl).append('<input class="show-contexts-checkbox" type="checkbox" name="context-checkbox-show" id="context-checkbox-show"> <label for="context-checkbox-show">Contexts shown</label>');
			}

			// Panels
			if (settings.panels.indexOf('details') !== -1) {
				$('<div class="details-panel"><div class="context-header"><h4>Details</h4></div><ul class="list-group context-list"></ul><div class="context-footer"><div class="pull-left new-group-button"><span class="fa fa-plus-circle"></span> New context</div></div></div>').appendTo('#'+settings.targetEl);
			}

			sociogramMulti.addNodeData();

			// Add the evevent listeners
			window.addEventListener('nodeAdded', addNodeHandler, false);
			window.addEventListener('edgeAdded', sociogramMulti.updateNodeState, false);
			window.addEventListener('nodeRemoved', sociogramMulti.removeNode, false);
			window.addEventListener('edgeRemoved', sociogramMulti.removeEdge, false);
			window.addEventListener('changeStageStart', sociogramMulti.destroy, false);
			$(window.document).on('change', '#context-checkbox-show', sociogramMulti.toggleHulls);
			$(window.document).on('click', '.new-group-button', groupButtonClickHandler);

			// Update initial states of all nodes and edges;
			sociogramMulti.updateNodeState();

		});
	};

	sociogramMulti.addNodeData = function() {

		var criteriaNodes;

		// get nodes according to criteria query
		// filter out ego if required
		if (settings.criteria.includeEgo !== true) {
			criteriaNodes = settings.network.getNodes(settings.criteria.query, function (results) {
				var filteredResults = [];
				$.each(results, function(index,value) {
					if (value.type !== 'Ego') {
						filteredResults.push(value);
					}
				});

				return filteredResults;
			});
		} else {
			criteriaNodes = settings.network.getNodes(settings.criteria.query);
		}

		for (var j = 0; j < criteriaNodes.length; j++) {
			sociogramMulti.addNode(criteriaNodes[j]);
		}

		// Layout Mode
		var layoutNodes = sociogramMulti.getKineticNodes();
		$.each(layoutNodes, function(index,node) {
			node.setPosition(node.attrs.coords);
		});


		// Community
		var communityNodes;

		// community data is coming from ego
		if (typeof window.network.getEgo().contexts === 'undefined') {
			console.warn('Ego didn\'t have the community variable you specified, so it was created as a blank array.');
			var communityProperties = {};
			communityProperties.contexts= [];
			window.network.updateNode(window.network.getEgo().id, communityProperties);
		}

		var egoHulls = window.network.getEgo().contexts;
		$.each(egoHulls, function(hullIndex, hullValue) {
			sociogramMulti.addHull(hullValue);
		});

		communityNodes = sociogramMulti.getKineticNodes();
		$.each(communityNodes, function(index,node) {
			$.each(node.attrs.contexts, function (hullIndex, hullValue) {
				// Difference from node mode is we check if the node hull has been defined by ego too
				// if (egoHulls.indexOf(hullValue) !== -1) {
					sociogramMulti.addPointToHull(node, hullValue);
				// }

			});
		});

	};

	sociogramMulti.toggleHulls = function(e) {
		note.info('Sociogram: toggleHulls()');

		if ((e && e.target.checked) || hullsShown === false) {
			$('label[for="context-checkbox-show"]').html('Contexts shown');
			new Konva.Tween({
				node: hullLayer,
				duration: 0.5,
				opacity: 1
			}).play();
			hullsShown = true;
		} else {
			$('label[for="context-checkbox-show"]').html('Contexts hidden');

			new Konva.Tween({
				node: hullLayer,
				duration: 0.5,
				opacity: 0
			}).play();

			hullsShown = false;
		}
		$('label[for="context-checkbox-show"]').addClass('show');
		setTimeout(function() {
			$('label[for="context-checkbox-show"]').removeClass('show');
		}, 2000);
		hullLayer.draw();
	};

	sociogramMulti.resetNodeState = function() {

		// Reset select
		var kineticNodes = sociogramMulti.getKineticNodes();
		$.each(kineticNodes, function(nodeIndex, nodeValue) {
			nodeValue.children[1].stroke(settings.options.defaultNodeColor);
		});

		nodeLayer.batchDraw();

		// Reset edges
		edgeLayer.removeChildren();
		edgeLayer.batchDraw();

	};

	sociogramMulti.updateNodeState = function() {
		/**
		* Updates visible attributes based on current prompt task
		*/

		// Edge Mode
		if (typeof settings.prompts[currentPrompt] !== 'undefined' && typeof settings.prompts[currentPrompt].showEdges === 'object') {

			var properties = {};
			$.each(settings.prompts[currentPrompt].showEdges, function(index, value) {
				properties[value.label] = value.value;
			});
			var edges = settings.network.getEdges(properties);
			$.each(edges, function(index, edge) {
				sociogramMulti.addEdge(edge);
			});

		}

		// Select Mode
		if (typeof settings.prompts[currentPrompt] !== 'undefined' && typeof settings.prompts[currentPrompt].showSelected === 'object') {

			var selectNodes = settings.network.getNodes();
			$.each(selectNodes, function(index, node) {
				var currentValue = node[settings.prompts[currentPrompt].showSelected.variable];
				if (currentValue == settings.prompts[currentPrompt].showSelected.value) {
					// this node is selected
					var currentNode = sociogramMulti.getNodeByID(node.id);
					console.log(currentNode);
					currentNode.children[1].stroke(colors.selected);
				}
			});

			nodeLayer.draw();

		}

	};

	sociogramMulti.getSelectedNodes = function() {
		return selectedNodes;
	};

	sociogramMulti.destroy = function() {
		window.removeEventListener('nodeAdded', addNodeHandler, false);
		window.removeEventListener('edgeAdded', sociogramMulti.updateNodeState, false);
		window.removeEventListener('nodeRemoved', sociogramMulti.removeNode, false);
		window.removeEventListener('edgeRemoved', sociogramMulti.removeEdge, false);
		window.removeEventListener('changeStageStart', sociogramMulti.destroy, false);
		$(window.document).off('keypress', sociogramMulti.keyPressHandler);
		$(window.document).off('change', '#context-checkbox-show', sociogramMulti.toggleHulls);

	};

	sociogramMulti.addHull = function(label) {
		note.info('sociogramMulti.addHull ['+label+']');
		// ignore groups that already exist
		label = label ? label : 'New Context '+$('li[data-hull]').length;
		if (typeof hullShapes[label] === 'undefined') {
			var thisHull = {};
			thisHull.label = label;
	        thisHull.hull = new ConvexHullGrahamScan();

			var color = hullColors[$('.list-group-item').length];

	        var hullShape = new Konva.Line({
	          points: [window.outerWidth/2, window.outerHeight/2],
	          fill: color,
	          opacity:0.5,
	          stroke: color,
	          lineJoin: 'round',
	          lineCap: 'round',
			  transformsEnabled: 'position',
			  hitGraphEnabled: false,
	          tension : 0.1,
	          strokeWidth: 80,
	          closed : true
	        });
			hullShapes[label] = hullShape;
			$('.context-list').append('<li class="list-group-item hull" data-hull="'+thisHull.label+'"><div class="context-color" style="background:'+color+'"></div> <span class="context-label">'+thisHull.label+'</span> <span class="pull-right fa fa-pencil"></span></li>');
			// $('.context-list').scrollTo('li[data-hull="'+thisHull.label+'"]', 500);
	        hullLayer.add(hullShapes[label]);
			hullLayer.opacity(0);
	        hullLayer.draw();

			// If the data origin is ego, also add the new hull to ego
			if (settings.dataOrigin.Community.type === 'ego') {
				// If ego doesn't have the variable set, create it

				var properties;
				if (typeof window.network.getEgo()[settings.dataOrigin.Community.egoVariable] === 'undefined') {
					properties = {};
					properties[settings.dataOrigin.Community.egoVariable] = [];
					window.network.updateNode(window.network.getEgo().id, properties);
				}

				// get existing data
				var egoContexts = window.network.getEgo()[settings.dataOrigin.Community.egoVariable];
				if (egoContexts.indexOf(thisHull.label) === -1) {
					// Update ego
					egoContexts.push(thisHull.label);
					window.netCanvas.Modules.session.saveData();
				}

			}

		}

    };

	sociogramMulti.hullExists = function(hullLabel) {
		var found = false;
		if ($('li[data-hull="'+hullLabel+'"]').length > 0) {
			found = true;
		}
		return found;
	};

    sociogramMulti.addPointToHull = function(point, hullLabel) {
		// check if hull is already present
		note.info('sociogramMulti.addPointToHull()');
		var properties;
		// if a hull with hullLabel doesnt exist, create one
		if (!sociogramMulti.hullExists(hullLabel)) {
			note.warn('sociogramMulti.addPointToHull(): the hull label didn\'t exist, so a new hull was created.');
			sociogramMulti.addHull(hullLabel);
		}

		// If the point doesn't have the destination attribute, create it
		if (point.attrs.contexts === 'undefined') {
			note.warn('Node did not have the data destinateion community attribute. A blank array was created.');
			properties = {};
			properties.contexts = [];
			window.network.updateNode(point.attrs.id, properties);
		}
		// Only store if the node doesn't already have the hull present
		if (point.attrs.contexts.indexOf(hullLabel) === -1) {
			// Find the node we need to store the hull value in, and update it.

			// Create a dummy object so we can use the variable name set in settings.dataDestination
			properties = {};
			properties.contexts = point.attrs.contexts.concat([hullLabel]);
			point.attrs.contexts = point.attrs.contexts.concat([hullLabel]);

			// Update the node with the object
			settings.network.updateNode(point.attrs.id, properties, function() {
				note.debug('Network node updated', 1);
			});
		}

        // redraw all hulls begins here
        var pointHulls = point.attrs.contexts;

		// For each hull of the current point
        for (var i = 0; i < pointHulls.length; i++) {

			// Create an empty hull
            var newHull = new ConvexHullGrahamScan();

			// For each node
            for (var j = 0; j < nodeLayer.children.length; j++) {
				var thisChildHulls = nodeLayer.children[j].attrs.contexts;

				// Test if the current points current hull is in the current node's hull list

				if (thisChildHulls.indexOf(pointHulls[i]) !== -1) {
					// It is, so get the position of this node.
                    var coords = nodeLayer.children[j].getPosition();

					// Add it to the new hull
                    newHull.addPoint(coords.x, coords.y);
                }
            }

			// At the end of this loop we should have a newHull with points for all nodes

			// We need this check because on load all hull shapes might not be defined yet.
			if (typeof hullShapes[pointHulls[i]] !== 'undefined') {
				var tween = new Konva.Tween({
					node: hullShapes[pointHulls[i]],
					points: toPointFromObject(newHull.getHull()),
					duration: 0.5,
					onFinish: function(){
						tween.destroy();
					}
				}).play();

			}

			hullLayer.batchDraw();
            nodeLayer.draw();

        }

    };

	sociogramMulti.redrawHulls = function() {
		for (var i = 0; i < hullShapes.length; i++) {
			var newHull = new ConvexHullGrahamScan();

			for (var j = 0; j < nodeLayer.children.length; j++) {
				var thisChildHulls = nodeLayer.children[j].attrs.contexts;
				if (thisChildHulls.indexOf(hullShapes[i]) !== -1) {
					var coords = nodeLayer.children[j].getPosition();
					newHull.addPoint(coords.x, coords.y);
				}
			}

			hullShapes[i].setPoints(toPointFromObject(newHull.getHull()));
			hullLayer.batchDraw();

		}

	};

	sociogramMulti.getHullShapes = function() {
		return hullShapes;
	};

	sociogramMulti.removePointFromHull = function(point, hullLabel) {
		note.info('sociogramMulti.removePointFromHull()');
		var properties;

		// store properties according to data destination
		if (settings.dataOrigin.Community.type === 'node') {

			// If the point doesn't have the attribute, fail
			if (point.attrs[settings.dataDestination.Community.variable] === 'undefined') {
				note.error('sociogramMulti.removePointFromHull(): Error! The point wasn\'t attached to a hull named '+hullLabel);
				return false;
			}

			// If the hull isnt in the node, fail
			if (point.attrs[settings.dataDestination.Community.variable].indexOf(hullLabel) === -1) {
				note.error('sociogramMulti.removePointFromHull(): Error! The point wasn\'t attached to a hull named '+hullLabel);
				return false;
			} else {
				// Find the node we need to store the hull value in, and update it.

				// Create a dummy object so we can use the variable name set in settings.dataDestination
				properties = {};
				var nodePointHulls = point.attrs.contexts;
				nodePointHulls.remove(hullLabel);
				properties[settings.dataDestination.Community.variable] = nodePointHulls;
				point.attrs.contexts = nodePointHulls;

				// Update the node with the object
				settings.network.updateNode(point.attrs.id, properties, function() {
					note.info('Network node updated', 1);
					note.debug(properties);
				});
			}

		} else if (settings.dataOrigin.Community.type === 'ego') {

			// If the point doesn't have the attribute, fail
			if (point.attrs[settings.dataOrigin.Community.variable] === 'undefined') {
				note.error('sociogramMulti.removePointFromHull(): Error! The point wasn\'t attached to a hull named '+hullLabel);
				return false;
			}

			// If the hull isnt in the node, fail
			if (point.attrs[settings.dataOrigin.Community.variable].indexOf(hullLabel) === -1) {
				note.error('sociogramMulti.removePointFromHull(): Error! The point wasn\'t attached to a hull named '+hullLabel);
				return false;
			} else {
				// Find the node we need to store the hull value in, and update it.

				// Create a dummy object so we can use the variable name set in settings.dataOrigin
				properties = {};
				var egoPointHulls = point.attrs.contexts;
				egoPointHulls.remove(hullLabel);
				properties[settings.dataOrigin.Community.variable] = egoPointHulls;
				point.attrs.contexts = egoPointHulls;

				// Update the node with the object
				settings.network.updateNode(point.attrs.id, properties, function() {
					note.info('Network node updated', 1);
					note.debug(properties);
				});
			}
		} else if (settings.dataOrigin.Position.type === 'edge') {
			// not yet implemented
		}


		// redraw only the hull that the node has been removed from
		// Create an empty hull
        var newHull = new ConvexHullGrahamScan();

		// For each node
        for (var j = 0; j < nodeLayer.children.length; j++) {
			var thisChildHulls = nodeLayer.children[j].attrs.contexts;

			// Test if the current points current hull is in the current node's hull list
			if (thisChildHulls.indexOf(hullLabel) !== -1) {
				// It is, so get the position of this node.
                var coords = nodeLayer.children[j].getPosition();

				// Add it to the new hull
                newHull.addPoint(coords.x, coords.y);
            }
        }

		// At the end of this loop we should have a newHull with points for all nodes

		// We need this check because on load all hull shapes might not be defined yet.
		if (typeof hullShapes[hullLabel] !== 'undefined') {
			var tween = new Konva.Tween({
				node: hullShapes[hullLabel],
				points: toPointFromObject(newHull.getHull()),
				duration: 0.5,
				onFinish: function(){
					tween.destroy();
				}
			}).play();
		}

		hullLayer.batchDraw();
        nodeLayer.draw();


	};

	sociogramMulti.addNode = function(options) {

		note.info('Sociogram is creating a node.');
		note.debug(options);
		// Placeholder for getting the number of nodes we have.
		var nodeShape;

		var nodeID = 0;
		while (settings.network.getNode(nodeID) !== false) {
			nodeID++;
		}

		var dragStatus = false;
		if (settings.modes.indexOf('Position') !== -1 || settings.modes.indexOf('Edge') !== -1) {
			dragStatus = true;
		}

		// Try to guess at a label if one isn't provided.
		// Is there a better way of doing this?
		if (typeof options.label === 'undefined' && typeof options.nname_t0 !== 'undefined') { // for RADAR use nickname
			options.label = options.nname_t0;
		} else if (typeof options.label === 'undefined' && typeof options.name !== 'undefined'){
			options.label = options.name;
		}

		var nodeOptions = {
			id: nodeID,
			coords: [],
			positioned: false,
			label: 'Undefined',
			type: 'Person',
			transformsEnabled: 'position',
			size: settings.options.defaultNodeSize,
			color: settings.options.defaultNodeColor,
			strokeWidth: settings.options.defaultNodeStrokeWidth,
			stroke: settings.options.defaultNodeColor,
			draggable: dragStatus,
			dragDistance: 20
		};

		nodeOptions.contexts = [];
		window.tools.extend(nodeOptions, options);

		nodeOptions.id = parseInt(nodeOptions.id, 10);
		nodeOptions.x = nodeOptions.coords[0] ? nodeOptions.coords[0] : false;
		nodeOptions.y = nodeOptions.coords[1] ? nodeOptions.coords[1] : false;

		var nodeGroup = new Konva.Group(nodeOptions);

		var selectCircle = new Konva.Circle({
			radius: nodeOptions.size+(nodeOptions.strokeWidth*1.5),
			fill:settings.options.defaultEdgeColor,
			transformsEnabled: 'position',
			opacity:0
		});

		nodeShape = new Konva.Circle({
			radius: nodeOptions.size,
			fill:nodeOptions.color,
			transformsEnabled: 'position',
			strokeWidth: nodeOptions.strokeWidth,
			stroke: nodeOptions.stroke
		});

		var nodeLabel = new Konva.Text({
			text: nodeOptions.label,
			// fontSize: 20,
			fontFamily: 'Lato',
			transformsEnabled: 'position',
			fill: settings.options.defaultLabelColor,
			align: 'center',
			// offsetX: (nodeOptions.size*-1)-10, //left right
			// offsetY:(nodeOptions.size*1)-10, //up down
			fontStyle:500
		});

		note.debug('Putting node '+nodeOptions.label+' at coordinates x:'+nodeOptions.coords[0]+', y:'+nodeOptions.coords[1]);

		padText(nodeLabel,nodeShape,10);

		nodeGroup.add(selectCircle);
		nodeGroup.add(nodeShape);
		nodeGroup.add(nodeLabel);

		nodeLayer.add(nodeGroup);

		setTimeout(function() {
			nodeLayer.draw();
		}, 0);

		if (!options.coords || nodeOptions.coords.length === 0) {
			nodesWithoutPositions++;
			if (!newNodeCircleVisible) {
				newNodeCircleTween.play();
				newNodeCircleVisible = true;
			}
			nodeGroup.position({
				x: 0,
				y:$(window).height()/2
			});
			new Konva.Tween({
				node: nodeGroup,
				x: 145,
				y: $(window).height()/2,
				duration:0.7,
				easing: Konva.Easings.EaseOut
			}).play();
			// settings.network.setProperties(settings.network.getNode(nodeOptions.id),{coords:[$(window).width()-150, $(window).height()-150]});
		} else {

		}

		// Node event handlers
		nodeGroup.on('dragstart', function() {

			window.wedge.anim.stop();
			window.clearTimeout(longPressTimer);
			if (taskComprehended === false) {
				var eventProperties = {
					stage: window.netCanvas.Modules.session.currentStage(),
					timestamp: new Date()
				};
				log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
				window.dispatchEvent(log);
				taskComprehended = true;
			}

			note.debug('dragstart');

			// Add the current position to the node attributes, so we know where it came from when we stop dragging.
			this.attrs.oldx = this.attrs.x;
			this.attrs.oldy = this.attrs.y;
			if (this.attrs.positioned === false ) {
				this.attrs.positioned = true;
				nodesWithoutPositions--;
				if (nodesWithoutPositions < 1) {
					newNodeCircleTween.reverse();
					newNodeCircleVisible = false;
				}
			}

			this.moveToTop();
			nodeLayer.draw();

			var dragNode = nodeOptions.id;

			// Update the position of any connected edges and hulls
			var pointHulls = this.attrs.contexts;
			for (var i = 0; i < pointHulls.length; i++) {
				var newHull = new ConvexHullGrahamScan();

				for (var j = 0; j < nodeLayer.children.length; j++) {
					var thisChildHulls = nodeLayer.children[j].attrs.contexts;
					if (thisChildHulls.indexOf(pointHulls[i]) !== -1) {
						var coords = nodeLayer.children[j].getPosition();
						newHull.addPoint(coords.x, coords.y);
					}
				}

				hullShapes[pointHulls[i]].setPoints(toPointFromObject(newHull.getHull()));
				hullLayer.batchDraw();

			}

			$.each(edgeLayer.children, function(index, value) {

				// value.setPoints([dragNode.getX(), dragNode.getY() ]);
				if (value.attrs.from === dragNode || value.attrs.to === dragNode) {
					var points = [sociogramMulti.getNodeByID(value.attrs.from).getX(), sociogramMulti.getNodeByID(value.attrs.from).getY(), sociogramMulti.getNodeByID(value.attrs.to).getX(), sociogramMulti.getNodeByID(value.attrs.to).getY()];
					value.attrs.points = points;

				}
			});

		});

		nodeGroup.on('dragmove', function() {

			// Cancel wedge actions
			window.wedge.anim.stop();
			var tween = new Konva.Tween({
				 node: window.wedge,
				 opacity: 0,
				 duration: 0,
				 onFinish: function(){
					 tween.destroy();
				 }
			}).play();
			window.clearTimeout(longPressTimer);

			if (taskComprehended === false) {
				var eventProperties = {
					stage: window.netCanvas.Modules.session.currentStage(),
					timestamp: new Date()
				};
				log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
				window.dispatchEvent(log);
				taskComprehended = true;
			}

			note.debug('Dragmove');

			var dragNode = nodeOptions.id;
			// Update the position of any connected edges and hulls
			var pointHulls = this.attrs.contexts;
			for (var i = 0; i < pointHulls.length; i++) {
				var newHull = new ConvexHullGrahamScan();

				for (var j = 0; j < nodeLayer.children.length; j++) {
					var thisChildHulls = nodeLayer.children[j].attrs.contexts;
					if (thisChildHulls.indexOf(pointHulls[i]) !== -1) {
						var coords = nodeLayer.children[j].getPosition();
						newHull.addPoint(coords.x, coords.y);
					}
				}

				hullShapes[pointHulls[i]].setPoints(toPointFromObject(newHull.getHull()));
				hullLayer.batchDraw();

			}

			$.each(edgeLayer.children, function(index, value) {

				// value.setPoints([dragNode.getX(), dragNode.getY() ]);
				if (value.attrs.from === dragNode || value.attrs.to === dragNode) {
					var points = [sociogramMulti.getNodeByID(value.attrs.from).getX(), sociogramMulti.getNodeByID(value.attrs.from).getY(), sociogramMulti.getNodeByID(value.attrs.to).getX(), sociogramMulti.getNodeByID(value.attrs.to).getY()];
					value.attrs.points = points;

				}
			});
			edgeLayer.batchDraw();
		});

		nodeGroup.on('touchstart mousedown', function() {

			var currentNode = this;

			window.wedge.setAbsolutePosition(this.getAbsolutePosition());

			window.wedge.anim = new Konva.Animation(function(frame) {
				var duration = 350;
				if (frame.time >= duration) { // point of selection
					window.wedge.setAngle(360);
					currentNode.fire('longPress');
				} else {
					window.wedge.opacity(frame.time*(1/duration));
					window.wedge.setStrokeWidth(1+(frame.time*(20/duration)));
					window.wedge.setAngle(frame.time*(360/duration));
				}

			}, wedgeLayer);

			longPressTimer = setTimeout(function() {
				touchNotTap = true;
				window.wedge.anim.start();
			}, 150);

		});

		nodeGroup.on('longPress', function() {
			console.log('longpress');
			sociogramMulti.showDetailsPanel();
			selectedNode = this;
			console.log(selectedNode);
			var currentNode = this;
			$('.hull').removeClass('active'); // deselect all groups

			// Update side panel
			$('.context-header h4').html('Details for '+currentNode.attrs.label);
			$.each(currentNode.attrs.contexts, function(index, value) {
				$('[data-hull="'+value+'"]').addClass('active');
			});
			window.wedge.anim.stop();
			window.clearTimeout(longPressTimer);
		});

		nodeGroup.on('touchend mouseup', function() {

			window.wedge.anim.stop();
			var tween = new Konva.Tween({
				 node: window.wedge,
				 opacity: 0,
				 duration: 0.3,
				 onFinish: function(){
					 tween.destroy();
				 }
	 	 	}).play();
			window.clearTimeout(longPressTimer);
		});

		nodeGroup.on('dbltap dblclick', function() {

			selectedNodes = [];
			// var kineticNodes = sociogramMulti.getKineticNodes();
			// $.each(kineticNodes, function(index, value) {
			// 	value.children[0].opacity(0);
			// });
			window.clearTimeout(tapTimer);

			if (taskComprehended === false) {
				var eventProperties = {
					stage: window.netCanvas.Modules.session.currentStage(),
					timestamp: new Date()
				};
				log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
				window.dispatchEvent(log);
				taskComprehended = true;
			}
			log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeClick', 'eventObject':this.attrs.id}});
			window.dispatchEvent(log);

			var currentNode = this;

			// if select mode enabled
			if (typeof settings.prompts[currentPrompt] !== 'undefined' && typeof settings.prompts[currentPrompt].showSelected === 'object') {

				// flip variable

				// Get current variable value
				var properties = {};
				var currentValue = settings.network.getNode(currentNode.attrs.id)[settings.prompts[currentPrompt].showSelected.variable];
				// flip
				if (currentValue != settings.prompts[currentPrompt].showSelected.value || typeof currentValue === 'undefined') {
					properties[settings.prompts[currentPrompt].showSelected.variable] = settings.prompts[currentPrompt].showSelected.value;
					currentNode.children[1].stroke(colors.selected);
				} else {
					// remove static variables, if present
					var node = window.network.getNode(currentNode.attrs.id);
					node[settings.prompts[currentPrompt].showSelected.variable] = 0;
					currentNode.children[1].stroke(settings.options.defaultNodeColor);
				}

				settings.network.updateNode(currentNode.attrs.id, properties);

			}
			this.moveToTop();
			nodeLayer.draw();
		});

		nodeGroup.on('tap click', function() {
			/**
			* Tap (or click when using a mouse) events on a node trigger one of two actions:
			*
			* (1) If a hull is currently selected, tapping a node will add it to the selected hull. Any other events
			* (for example edge creation) will be ignored.
			*
			* (2) If edge creation mode is enabled and there are no selected hulls, tapping a node will mark it as being selected for potential linking.
			* If the node is the first to be selected, nothing more will happen. If it is the second, an edge will be
			* created according to the edge destination settings.
			*/

			var currentNode = this; // Store the context

			if (!touchNotTap) { /** check we aren't in the middle of a touch */

				window.wedge.anim.stop(); // Cancel any existing touch hold animations

				if (tapTimer !== null) { window.clearTimeout(tapTimer); } // clear any previous tapTimer

				/** Conduct all tap actions inside a short timeout to give space for a double tap event to cancel it. */
				tapTimer = setTimeout(function(){
					window.clearTimeout(longPressTimer);
					if (taskComprehended === false) {
						var eventProperties = {
							stage: window.netCanvas.Modules.session.currentStage(),
							timestamp: new Date()
						};
						log = new window.CustomEvent('log', {'detail':{'eventType': 'taskComprehended', 'eventObject':eventProperties}});
						window.dispatchEvent(log);
						taskComprehended = true;
					}
					log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeClick', 'eventObject':currentNode.attrs.id}});
					window.dispatchEvent(log);

					/** Test if edge creation mode is enabled */
					if (typeof settings.prompts[currentPrompt] !== 'undefined' && typeof settings.prompts[currentPrompt].showEdges === 'object') {

						// Ignore two clicks on the same node
						if (selectedNodes[0] === currentNode) {
							selectedNodes[0].children[0].opacity(0);
							selectedNodes = [];
							nodeLayer.draw();
							return false;
						}

						// Push the clicked node into the selected nodes array;
						selectedNodes.push(currentNode);

						// Check the length of the selected nodes array.
						if(selectedNodes.length === 2) {
							//If it containes two nodes, create an edge

							//Reset the styling
							selectedNodes[1].children[0].opacity(0);
							selectedNodes[0].children[0].opacity(0);

							// Create an edge object

								var edgeProperties = {};
								edgeProperties = {
									from: selectedNodes[0].attrs.id,
									to: selectedNodes[1].attrs.id,
								};

								// Add the custom variables
								$.each(settings.prompts[currentPrompt].showEdges, function(index, value) {
									edgeProperties[value.label] = value.value;
								});

								// Try adding the edge. If it returns fals, it already exists, so remove it.
								console.log(edgeProperties);
								if (settings.network.addEdge(edgeProperties) === false) {
									note.debug('Sociogram removing edge.',2);
									settings.network.removeEdge(settings.network.getEdges(edgeProperties));
								} else {
									note.debug('Sociogram added edge.',2);
								}

								// Empty the selected nodes array and draw the layer.
								selectedNodes = [];

						} else { // First node selected. Simply turn the node stroke to the selected style so we can see that it has been selected.
							currentNode.children[0].opacity(1);
						}
					}
					currentNode.moveToTop();
					nodeLayer.draw();
				}, 200);
			} else {
				touchNotTap = false;
			}

		});

		nodeGroup.on('dragend', function() {

			var dragNode = nodeOptions.id;
			// Update the position of any connected edges and hulls
			var pointHulls = this.attrs.contexts;
			for (var i = 0; i < pointHulls.length; i++) {
				var newHull = new ConvexHullGrahamScan();

				for (var j = 0; j < nodeLayer.children.length; j++) {
					var thisChildHulls = nodeLayer.children[j].attrs.contexts;
					if (thisChildHulls.indexOf(pointHulls[i]) !== -1) {
						var coords = nodeLayer.children[j].getPosition();
						newHull.addPoint(coords.x, coords.y);
					}
				}

				hullShapes[pointHulls[i]].setPoints(toPointFromObject(newHull.getHull()));
				hullLayer.draw();

			}

			$.each(edgeLayer.children, function(index, value) {

				// value.setPoints([dragNode.getX(), dragNode.getY() ]);
				if (value.attrs.from === dragNode || value.attrs.to === dragNode) {
					var points = [sociogramMulti.getNodeByID(value.attrs.from).getX(), sociogramMulti.getNodeByID(value.attrs.from).getY(), sociogramMulti.getNodeByID(value.attrs.to).getX(), sociogramMulti.getNodeByID(value.attrs.to).getY()];
					value.attrs.points = points;

				}
			});
			edgeLayer.draw();

			note.debug('Drag ended at x: '+this.attrs.x+' y: '+this.attrs.y);

			// set the context
			var from = {};
			var to = {};

			// Fetch old position from properties populated by dragstart event.
			from.x = this.attrs.oldx;
			from.y = this.attrs.oldy;

			to.x = this.attrs.x;
			to.y = this.attrs.y;

			this.attrs.coords = [this.attrs.x,this.attrs.y];

			// Add them to an event object for the logger.
			var eventObject = {
				from: from,
				to: to,
			};

			// Log the movement and save the graph state.
			log = new window.CustomEvent('log', {'detail':{'eventType': 'nodeMove', 'eventObject':eventObject}});
			window.dispatchEvent(log);

			// store properties according to data destination
			// Find the node we need to store the coordinates on, and update it.

			// Create a dummy object so we can use the variable name set in settings.dataDestination
			var properties = {};
			properties.coords = this.attrs.coords;

			// Update the node with the object
			settings.network.updateNode(this.attrs.id, properties, function() {
				window.tools.notify('Network node updated', 1);
			});
			// remove the attributes, just incase.
			delete this.attrs.oldx;
			delete this.attrs.oldy;

		});

		return nodeGroup;
	};

	// Edge manipulation functions

	sociogramMulti.addEdge = function(properties) {

		// This doesn't *usually* get called directly. Rather, it responds to an event fired by the network module.

		var egoID = settings.network.getEgo().id;

		if(typeof properties.detail !== 'undefined' && typeof properties.detail.from !== 'undefined' && properties.detail.from !== egoID) {
			// We have been called by an event
			properties = properties.detail;
		} else if (typeof properties.from !== 'undefined' && typeof properties.to !== 'undefined' && properties.from !== egoID) {
			// We have been called by another sociogram method
			properties = properties;
		} else {
			return false;
		}

		// the below won't work because we are storing the coords in an edge now...
		note.debug('Sociogram is adding an edge.');
		var toObject = sociogramMulti.getNodeByID(properties.to);
	 	var fromObject = sociogramMulti.getNodeByID(properties.from);
		var points = [fromObject.attrs.coords[0], fromObject.attrs.coords[1], toObject.attrs.coords[0], toObject.attrs.coords[1]];

		var edge = new Konva.Line({
			// dashArray: [10, 10, 00, 10],
			strokeWidth: 4,
			transformsEnabled: 'position',
			hitGraphEnabled: false,
			opacity:1,
			stroke: settings.options.defaultEdgeColor,
			// opacity: 0.8,
			points: points
		});

		edge.setAttrs({
			from: properties.from,
			to: properties.to
		});

		edgeLayer.add(edge);

		setTimeout(function() {
			edgeLayer.draw();
		},0);
		nodeLayer.draw();
		note.trace('Created Edge between '+fromObject.attrs.label+' and '+toObject.attrs.label);

		return true;

	};

	sociogramMulti.removeEdge = function(properties) {

		note.debug('sociogramMulti.removeEdge() called.');
		if (!properties) {
			note.error('No properties passed to sociogramMulti.removeEdge()!');
		}

		// Test if we are being called by an event, or directly
		if (typeof properties.detail !== 'undefined' && typeof properties.detail.from !== 'undefined' && properties.detail.from !== settings.network.getEgo().id) {
			properties = properties.detail;
		}

		var toObject = properties.to;
	 	var fromObject = properties.from;

		// This function is failing because two nodes are matching below
		var found = false;
		$.each(sociogramMulti.getKineticEdges(), function(index, value) {
			if (value !== undefined) {
				if (value.attrs.from === fromObject && value.attrs.to === toObject || value.attrs.from === toObject && value.attrs.to === fromObject ) {
					found = true;
					edgeLayer.children[index].remove();
					edgeLayer.draw();
				}
			}

		});

		if (!found) {
			note.error('sociogramMulti.removeEdge() failed! Couldn\'t find the specified edge.');
		} else {
			return true;
		}

	};

	sociogramMulti.removeNode = function() {
	};

	// Misc functions

	sociogramMulti.clearGraph = function() {
		edgeLayer.removeChildren();
		edgeLayer.clear();
		nodeLayer.removeChildren();
		nodeLayer.clear();

	};

	sociogramMulti.getStage = function() {
		return stage;
	};

	// Main initialisation functions

	sociogramMulti.initKinetic = function () {
		// Initialise KineticJS stage
		stage = new Konva.Stage({
			container: settings.targetEl,
			width: window.innerWidth,
			height: window.innerHeight
		});

		circleLayer = new Konva.Layer();
		hullLayer = new Konva.FastLayer();
		wedgeLayer = new Konva.FastLayer();
		nodeLayer = new Konva.Layer();
		edgeLayer = new Konva.FastLayer();

		/**
		* This hack allows us to detect clicks that happen outside of nodes, hulls, or edges.
		* We create a transparent rectangle on a special background layer which sits between the UI layer and the interaction layers.
		* We then listen to click events on this shape.
 		*/
		var backgroundLayer = new Konva.Layer();
		var backgroundRect = new Konva.Rect({
	        x: 0,
	        y: 0,
	        width: stage.width(),
	        height: stage.height(),
	        fill: 'transparent',
	      });
		backgroundLayer.add(backgroundRect);
		backgroundRect.on('tap click', function() {
			sociogramMulti.hideDetailsPanel();
			selectedNode = null;
			$('.hull').removeClass('active'); // deselect all groups

			//deselect Nodes
			selectedNodes = [];
			$.each(sociogramMulti.getKineticNodes(), function(nodesIndex, nodesValue) {
				nodesValue.children[0].opacity(0);
			});

			nodeLayer.draw();

		});

		stage.add(circleLayer);
		stage.add(backgroundLayer);
		stage.add(hullLayer);
		stage.add(edgeLayer);
		stage.add(wedgeLayer);
		stage.add(nodeLayer);

		note.debug('Konva stage initialised.');

	};

	sociogramMulti.showDetailsPanel = function() {
		$('.details-panel').addClass('show');
	};

	sociogramMulti.hideDetailsPanel = function() {
		$('.details-panel').removeClass('show');
	};

	sociogramMulti.generateHull = function(points) {

        var newHull = new ConvexHullGrahamScan();

        for (var i = 0; i < points.length; i++) {
            var coords = points[i].getPosition();
            newHull.addPoint(coords.x, coords.y);
        }

		return toPointFromObject(newHull.getHull());


	};

	sociogramMulti.showNewNodeForm = function() {
		window.forms.nameGenForm.removeTemporaryFields();
		var properties = {};
		// if (settings.prompts[currentPrompt].dataType === 'namegenerator') {
		// 	// add fields from dataTarget
	    //     properties = {};
		// 	$.each(settings.prompts[currentPrompt].formVariables, function(formIndex,formValue) {
		// 		properties[formValue.label] = {
	    //             type:formValue.type,
	    //             title: formValue.label
	    //         };
		// 	});
		//
	    //     window.forms.nameGenForm.addTemporaryFields(properties);
		//
	    //     // Add data from fields
	    //     properties = {};
		// 	$.each(settings.prompts[currentPrompt].formVariables, function(formIndex,formValue) {
		// 	properties[formValue.label] = formValue.value;
		// 	});
		//
	    //     window.forms.nameGenForm.addData(properties);
		// }


		for (var i =0; i <= currentPrompt; i++) {
			// check if current previous prompt has a select element
			if (typeof settings.prompts[i].showSelected === 'object') {
				// add fields from dataTarget
				properties = {};

				properties[settings.prompts[i].showSelected.group] = {
					'type': 'button-checkbox',
					'inline': true,
					'title':settings.prompts[i].showSelected.group,
					'variables':[
						{label:settings.prompts[i].showSelected.shortLabel, id:settings.prompts[i].showSelected.variable},
					]
				};

				window.forms.nameGenForm.addTemporaryFields(properties);

				// Add data from fields
				properties = {};
				properties[settings.prompts[currentPrompt].showSelected.variable] = 1;

				window.forms.nameGenForm.addData(properties);
			}
		}

	    window.forms.nameGenForm.show();
	};

	sociogramMulti.drawUIComponents = function (callback) {

		// Load the image
		var imageObj = new Image();
		imageObj.src = 'img/drag-text.png';
		imageObj.onload = function() {

			// New node button
			$('#'+settings.targetEl).append('<div class="new-node-button text-center"><span class="fa fa-2x fa-plus"></span></div>');
			var events = [{
				event: 'click',
				handler: sociogramMulti.showNewNodeForm,
				targetEl:  '.new-node-button'
			}, {
				event: 'click',
				handler: hullListClickHandler,
				targetEl:  window.document,
				subTarget:  '.list-group-item',
			},
			{
				event: 'submit',
				handler: function() {
					setTimeout(function() {
						sociogramMulti.updateNodeState();
					},100);
				},
				targetEl: window.document,
				subtarget: window.forms.nameGenForm.getID()
			}
		];
			window.tools.Events.register(moduleEvents, events);

			// Draw all UI components
			var previousSkew = 0;
			var circleFills, circleLines;
			var currentColor = settings.options.concentricCircleColor;
			var totalHeight = window.innerHeight-(settings.options.defaultNodeSize); // Our sociogram area is the window height minus twice the node radius (for spacing)
			var currentOpacity = 0.1;

			//draw concentric circles
			for(var i = 0; i < settings.options.concentricCircleNumber; i++) {
				var ratio = (1-(i/settings.options.concentricCircleNumber));
				var skew = i > 0 ? (ratio * 5) * (totalHeight/70) : 0;
				var currentRadius = totalHeight/2 * ratio;
				currentRadius = settings.options.concentricCircleSkew? currentRadius + skew + previousSkew : currentRadius;
				previousSkew = skew;
				circleLines = new Konva.Circle({
					x: window.innerWidth / 2,
					y: window.innerHeight / 2,
					radius: currentRadius,
					hitGraphEnabled: false,
					stroke: 'white',
					strokeWidth: 1.5,
					opacity: 0
				});

				circleFills = new Konva.Circle({
					x: window.innerWidth / 2,
					y: (window.innerHeight / 2),
					radius: currentRadius,
					fill: currentColor,
					hitGraphEnabled: false,
					opacity: currentOpacity,
					strokeWidth: 0,
				});

				// currentColor = tinycolor.darken(currentColor, amount = 15).toHexString();
				currentOpacity = currentOpacity+((0.3-currentOpacity)/settings.options.concentricCircleNumber);
				circleLayer.add(circleFills);
				circleLayer.add(circleLines);

			}

			// Node container
			var newNodeCircle = new Konva.Circle({
				radius: 60,
				transformsEnabled: 'none',
				hitGraphEnabled: false,
				stroke: 'white',
				strokeWidth: 7
			});

			// var newNodeText = new Konva.Text({
			// 	text: 'Need Positioning',
			// 	align: 'center',
			// 	offset: {x:55,y:100},
			// 	fontSize: 15,
			// 	fontFamily: 'Helvetica',
			// 	fill: 'white'
			//  });



			var newNodeText = new Konva.Image({
			 x: -20,
			 y: -180,
			 image: imageObj,
			 width: 200,
			 height: 105
			});

			// add the shape to the layer

			var newNodeCircleGroup = new Konva.Group({
			 x: 145,
			 opacity:0,
			 y: window.innerHeight / 2,
			});

			newNodeCircleGroup.add(newNodeText);
			newNodeCircleGroup.add(newNodeCircle);
			circleLayer.add(newNodeCircleGroup);

			newNodeCircleTween = new Konva.Tween({
			 node: newNodeCircleGroup,
			 opacity: 1,
			 duration: 1
			});


			// Draw 'me'
			if (settings.options.showMe === true) {

				var meCircle = new Konva.Circle({
					radius: 50,
					x: window.innerWidth / 2,
					y: window.innerHeight / 2,
					hitGraphEnabled: false,
					fill: '#D0D2DC',
				});

				var meText = new Konva.Text({
					x: window.innerWidth / 2,
					y: window.innerHeight / 2,
					text: 'me',
					align: 'center',
					offset: {x:28,y:22},
					fontSize: 40,
					fontFamily: 'Helvetica',
					fill: 'black'
				 });
				circleLayer.add(meCircle);
				circleLayer.add(meText);
			}

			// draw wedgex

			Konva.selectWedge = function(config) {
				this._initselectWedge(config);
			};

			Konva.selectWedge.prototype = {
				_initselectWedge: function(config) {
					Konva.Circle.call(this, config);
				},
				_sceneFunc: function(context) {
					context.beginPath();
					context.arc(0, 0, this.getRadius(), 0, Konva.getAngle(this.getAngle()), this.getClockwise());
					context.fillStrokeShape(this);
				}
			};

			Konva.Util.extend(Konva.selectWedge, Konva.Wedge);

			window.wedge = new Konva.selectWedge({
				radius: settings.options.defaultNodeSize+5,
				angle: 0,
				fill: 'transparent',
				stroke: colors.selected,
				rotation:-90,
				opacity:0,
				strokeWidth: 10,
			});

			wedgeLayer.add(window.wedge);
			window.wedge.moveToBottom();

			circleLayer.draw();

			note.debug('User interface initialised.');

			if (callback) {
				callback();
			}
		};
	};

	// Get & set functions

	sociogramMulti.getKineticNodes = function() {
		return nodeLayer.children;
	};

	sociogramMulti.getKineticEdges = function() {
		return edgeLayer.children;
	};

	sociogramMulti.getSimpleNodes = function() {
		// We need to create a simple representation of the nodes for storing.
		var simpleNodes = {};
		var nodes = sociogramMulti.getKineticNodes();
		$.each(nodes, function (index, value) {
			simpleNodes[value.attrs.id] = {};
			simpleNodes[value.attrs.id].x = value.attrs.x;
			simpleNodes[value.attrs.id].y = value.attrs.y;
			simpleNodes[value.attrs.id].name = value.attrs.name;
			simpleNodes[value.attrs.id].type = value.attrs.type;
			simpleNodes[value.attrs.id].size = value.attrs.size;
			simpleNodes[value.attrs.id].color = value.attrs.color;
		});
		return simpleNodes;
	};

	sociogramMulti.getSimpleEdges = function() {
		var simpleEdges = {},
		edgeCounter = 0;

		$.each(edgeLayer.children, function(index, value) {
			simpleEdges[edgeCounter] = {};
			simpleEdges[edgeCounter].from = value.attrs.from.attrs.id;
			simpleEdges[edgeCounter].to = value.attrs.to.attrs.id;
			edgeCounter++;
		});

		return simpleEdges;
	};

	sociogramMulti.getSimpleEdge = function(id) {
		var simpleEdges = sociogramMulti.getSimpleEdges();
		if (!id) { return false; }

		var simpleEdge = simpleEdges[id];
		return simpleEdge;
	};

	sociogramMulti.getEdgeLayer = function() {
		return edgeLayer;
	};

	sociogramMulti.getNodeLayer = function() {
		return nodeLayer;
	};

	sociogramMulti.getUILayer = function() {
		return uiLayer;
	};

	sociogramMulti.getHullLayer = function() {
			return hullLayer;
	};

	sociogramMulti.getNodeByID = function(id) {
		var node = {},
		nodes = sociogramMulti.getKineticNodes();

		$.each(nodes, function(index, value) {
			if (value.attrs.id === id) {
				node = value;
			}
		});

		return node;
	};

	sociogramMulti.getNodeColorByType = function(type) {
		var returnVal = null;
		$.each(settings.nodeTypes, function(index, value) {
			if (value.name === type) {returnVal = value.color;}
		});

		if (returnVal) {
			return returnVal;
		} else {
			return false;
		}
	};

	return sociogramMulti;

};
;/*jshint unused:false*/
/*global Set, window, $, localStorage, Storage, debugLevel, deepEquals, Notification, alert */
/*jshint bitwise: false*/
'use strict';
// Storage prototypes

window.Storage.prototype.showTotalUsage = function() {
    var total = 0;
    for(var x in localStorage) {
        if (localStorage.hasOwnProperty(x)) {
            var amount = (localStorage[x].length * 2) / 1024 / 1024;
            total += amount;
            console.log( x + ' = ' + amount.toFixed(2) + ' MB');
        }
    }
    console.log( 'Total: ' + total.toFixed(2) + ' MB');
};

window.Storage.prototype.getKeyUsage = function(key) {
    if (localStorage.hasOwnProperty(key)) {
        var amount = (localStorage[key].length * 2) / 1024 / 1024;
        return amount.toFixed(2);
    }
};

window.Storage.prototype.setObject = function(key, value) {
    this.setItem(key, JSON.stringify(value));
};

window.Storage.prototype.getObject = function(key) {
    if (this.getItem(key) === null) {
        return false;
    } else {
        var value = this.getItem(key);
        return value && JSON.parse(value);
    }
};

jQuery.fn.scrollTo = function(elem, speed) {
    $(this).animate({
        scrollTop:  $(this).scrollTop() - $(this).offset().top + $(elem).offset().top
    }, speed == undefined ? 1000 : speed);
    return this;
};


// Array prototypes

Object.defineProperty(Array.prototype, 'toUnique', {
    enumerable: false,
    value: function() {
        var b,c;
        b=this.length;
        if (this.length > 0) {
            while(c=--b) while(c--) this[b]!==this[c]||this.splice(c,1)
        } else {
            return this;
        }

        // return  // not needed ;)
    }
});

Object.defineProperty(Array.prototype, 'remove', {
    enumerable: false,
    value: function (item) {
        var removeCounter = 0;

        for (var index = 0; index < this.length; index++) {
            if (this[index] === item) {
                this.splice(index, 1);
                removeCounter++;
                index--;
            }
        }
        return removeCounter;
    }
});


// Returns an array of linearly spaced numbers within a range.
exports.getLinearRange = function(min, max, number) {
    number++;
    var increment =  Math.round(100/number);
    var returnArray = [];
    for (var i = 1; i < number; i++) {
        returnArray.push(increment*i);
    }

    return returnArray;
};


//
exports.Events = {
    register: function(eventsArray, eventsList) {
        for (var i = 0; i < eventsList.length; i++) {
            eventsArray.push(eventsList[i]);
            if (typeof eventsList[i].subTarget !== 'undefined') {
                $(eventsList[i].targetEl).on(eventsList[i].event, eventsList[i].subTarget, eventsList[i].handler);
            } else {
                $(eventsList[i].targetEl).on(eventsList[i].event, eventsList[i].handler);
            }

        }

    },
    unbind: function(eventsArray) {
        for (var i = 0; i < eventsArray.length; i++) {
            if (typeof eventsArray[i].subTarget !== 'undefined') {
                $(eventsArray[i].targetEl).off(eventsArray[i].event, eventsArray[i].subTarget, eventsArray[i].handler);
            } else {
                $(eventsArray[i].targetEl).off(eventsArray[i].event, eventsArray[i].handler);
            }
        }
    }
};

exports.arrayDifference = function(a1, a2) {
  var a2Set = new Set(a2);
  return a1.filter(function(x) { return !a2Set.has(x); });
};

exports.euclideanDistance = function(point1, point2) {
    var d1 = point1[0] - point2[0], d2 = point1[1] - point2[1];
    return Math.sqrt(d1 * d1 + d2 * d2);
};

exports.removeFromObject = function(item, object) {
    var removeCounter = 0;

    for (var index = 0; index < object.length; index++) {
        if (object[index] === item) {
            object.splice(index, 1);
            removeCounter++;
            index--;
        }
    }
    return removeCounter;
};


// HTML entity encode/decode
exports.htmlEscape = function(str) {
    return String(str)
            .replace(/&/g, '&amp;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&#39;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;');
};

// I needed the opposite function today, so adding here too:
exports.htmlUnEscape = function (value) {
    return String(value)
        .replace(/&quot;/g, '"')
        .replace(/&#39;/g, "'")
        .replace(/&lt;/g, '<')
        .replace(/&gt;/g, '>')
        .replace(/&amp;/g, '&');
};


// helper functions

exports.nwNotification = function(options) {
    var notification = new Notification('Network Canvas:',options);
    notification.onclick = function () {
        // alert('Notification Clicked');
    };

    notification.onshow = function () {
        // play sound on show
        // myAud=document.getElementById("audio1");
        // myAud.play();

        // auto close after 1 second
        // setTimeout(function() {
        //     notification.close();
        // }, 1000);
    };
};

exports.deepEquals = function(a, x) {
    var p;
    for (p in a) {
        if (typeof(x[p]) === 'undefined') {
            return false;
        }
    }

    for (p in a) {
        if (a[p]) {

            switch (typeof(a[p])) {
                case 'object':
                    if (a[p].sort) {
                        a[p].sort();
                        x[p].sort();
                    }
                    if (!deepEquals(a[p], x[p])) {
                        return false;
                    }
                    break;
                case 'function':
                    if (typeof(x[p]) === 'undefined' || a[p].toString() !== x[p].toString()) {
                        return false;
                    }
                    break;
                default:
                    if (a[p] !== x[p]) {
                        return false;
                    }
            }
        } else {
            if (x[p]) {
                return false;
            }

        }
    }
    for (p in x) {
        if (typeof(a[p]) === 'undefined') {
            return false;
        }
    }

    return true;
};

exports.isInNestedObject = function(targetArray, objectKey, objectKeyValue) {
    // This function is for checking for keys in arrays of objects.
    for (var i = 0; i<targetArray.length; i++){
        for (var prop in targetArray[i]){
            if (prop === objectKey && targetArray[i][prop] === objectKeyValue) { return true; }
        }
    }

    return false;
};

exports.getKValueFromNestedObject = function(targetArray, objectKey) {
    // This function is for checking for keys in arrays of objects.
    for (var i = 0; i<targetArray.length; i++){
        for (var prop in targetArray[i]){
            if (prop === objectKey) { return targetArray[i][prop]; }
        }
    }

    return false;
};

exports.getValueFromName = function(targetArray, name) {
    // This function is for checking for keys in arrays of objects.
    for (var i = 0; i<targetArray.length; i++){
        if (typeof targetArray[i].name !== 'undefined' && typeof targetArray[i].value !== 'undefined' && targetArray[i].name === name) {
            return targetArray[i].value;
        }
    }

    return false;
};


exports.extend = function( a, b ) {
    for( var key in b ) {
        if( b.hasOwnProperty( key ) ) {
            a[key] = b[key];
        }
    }
    return a;
};

exports.notify = function(text, level){
    level = level || 0;
    if (level <= window.debugLevel) {
        console.log(text);
    }
};

exports.randomBetween = function(min,max) {
    return Math.random() * (max - min) + min;
};


exports.hex = function (x){
    return ('0' + parseInt(x).toString(16)).slice(-2);
};

$.cssHooks.backgroundColor = {
    get: function(elem) {
        var bg;
        if (elem.currentStyle) {
            bg = elem.currentStyle.backgroundColor;
        } else if (window.getComputedStyle) {
            bg = window.document.defaultView.getComputedStyle(elem,null).getPropertyValue('background-color');
        }

        if (bg.search('rgb') === -1) {
            return bg;
        } else {
            bg = bg.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
            return '#' + window.tools.hex(bg[1]) + window.tools.hex(bg[2]) + window.tools.hex(bg[3]);
        }
    }
};

exports.getRandomColor = function() {
    return '#' + (Math.round(Math.random() * 0XFFFFFF)).toString(16);
};

exports.modifyColor = function(hex, lum) {

    // validate hex string
    hex = String(hex).replace(/[^0-9a-f]/gi, '');
    if (hex.length < 6) {
        hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
    }
    lum = lum || 0;

    // convert to decimal and change luminosity
    var rgb = '#', c, i;
    for (i = 0; i < 3; i++) {
        c = parseInt(hex.substr(i*2,2), 16);
        c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
        rgb += ('00'+c).substr(c.length);
    }

    return rgb;

};
